{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tripper \u00b6 Triplestore wrapper for Python providing a simple and consistent interface to a range of triplestore backends - the best ride when handling any triplestore. Basic concepts \u00b6 Tripper provides a simple and consistent interface to a range of triplestore backends. It strives for simplicity and is modelled after rdflib (with a few simplifications). In Tripper: All IRIs are represented by Python strings. Example: \"http://emmo.info/emmo#Atom\" Blank nodes are strings starting with \"_:\". Example: \"_:bnode1\" Literals are constructed with tripper.Literal . Example: tripper.Literal(3.14, datatype=XSD.float) To make it easy to work with IRIs, provide Tripper a set of pre-defined namespaces, like XSD.float . New namespaces can be defined with the tripper.Namespace class. A triplestore wrapper is created with the tripper.Triplestore class. Documentation \u00b6 Getting started: Take a look at the tutorial . Reference manual: API Reference Installation \u00b6 Tripper has by itself no dependencies outside the standard library, but the triplestore backends may have specific dependencies. The package can be installed from PyPI using pip : pip install tripper License and copyright \u00b6 All files in this repository are licensed under the MIT license . If not stated otherwise in the top of the files, they have copyright \u00a9 2022 SINTEF.","title":"Home"},{"location":"#tripper","text":"Triplestore wrapper for Python providing a simple and consistent interface to a range of triplestore backends - the best ride when handling any triplestore.","title":"Tripper"},{"location":"#basic-concepts","text":"Tripper provides a simple and consistent interface to a range of triplestore backends. It strives for simplicity and is modelled after rdflib (with a few simplifications). In Tripper: All IRIs are represented by Python strings. Example: \"http://emmo.info/emmo#Atom\" Blank nodes are strings starting with \"_:\". Example: \"_:bnode1\" Literals are constructed with tripper.Literal . Example: tripper.Literal(3.14, datatype=XSD.float) To make it easy to work with IRIs, provide Tripper a set of pre-defined namespaces, like XSD.float . New namespaces can be defined with the tripper.Namespace class. A triplestore wrapper is created with the tripper.Triplestore class.","title":"Basic concepts"},{"location":"#documentation","text":"Getting started: Take a look at the tutorial . Reference manual: API Reference","title":"Documentation"},{"location":"#installation","text":"Tripper has by itself no dependencies outside the standard library, but the triplestore backends may have specific dependencies. The package can be installed from PyPI using pip : pip install tripper","title":"Installation"},{"location":"#license-and-copyright","text":"All files in this repository are licensed under the MIT license . If not stated otherwise in the top of the files, they have copyright \u00a9 2022 SINTEF.","title":"License and copyright"},{"location":"CHANGELOG/","text":"Changelog \u00b6 Unreleased (2022-11-23) \u00b6 Full Changelog Implemented enhancements: Refactor triplestore.py (triplestore module API) #3 Closed issues: Revert to using the proper general version for SINTEF/ci-cd #35 Write in type annotations #33 Improve README file #18 Add support for simple persistent storage in the rdflib backend #14 Merged pull requests: Updated import statements in the tutorial #40 ( jesper-friis ) Use the proper version of SINTEF/ci-cd #36 ( CasperWA ) bumped ci-cd version to remove --strict mkdocs command #32 ( daniel-sintef ) 3 refactor triplestorepy triplestore module api #31 ( daniel-sintef ) [Auto-generated] Update dependencies #28 ( TEAM4-0 ) 3 refactor triplestore #27 ( jesper-friis ) Corrected copyright #21 ( jesper-friis ) Add a useful description to README file. #19 ( jesper-friis ) Added support for simple persistent storage in the rdflib backend #15 ( jesper-friis ) Documented return value of the Triplestore.query() and added a test for it #9 ( jesper-friis ) v0.1.1 (2022-10-13) \u00b6 Full Changelog Implemented enhancements: Change package name to tripper on PyPI #13 Clean up newly initialized Python API #1 Fixed bugs: Enable proper release workflow #8 Fix workflows so they succeed #2 Merged pull requests: [Auto-generated] Update dependencies #17 ( TEAM4-0 ) Use the package name tripper (not tripperpy ) #16 ( CasperWA ) Clean up repository & fix workflows #5 ( CasperWA ) Added version number in __init__ to enable local pip install #4 ( quaat ) * This Changelog was automatically generated by github_changelog_generator","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#unreleased-2022-11-23","text":"Full Changelog Implemented enhancements: Refactor triplestore.py (triplestore module API) #3 Closed issues: Revert to using the proper general version for SINTEF/ci-cd #35 Write in type annotations #33 Improve README file #18 Add support for simple persistent storage in the rdflib backend #14 Merged pull requests: Updated import statements in the tutorial #40 ( jesper-friis ) Use the proper version of SINTEF/ci-cd #36 ( CasperWA ) bumped ci-cd version to remove --strict mkdocs command #32 ( daniel-sintef ) 3 refactor triplestorepy triplestore module api #31 ( daniel-sintef ) [Auto-generated] Update dependencies #28 ( TEAM4-0 ) 3 refactor triplestore #27 ( jesper-friis ) Corrected copyright #21 ( jesper-friis ) Add a useful description to README file. #19 ( jesper-friis ) Added support for simple persistent storage in the rdflib backend #15 ( jesper-friis ) Documented return value of the Triplestore.query() and added a test for it #9 ( jesper-friis )","title":"Unreleased (2022-11-23)"},{"location":"CHANGELOG/#v011-2022-10-13","text":"Full Changelog Implemented enhancements: Change package name to tripper on PyPI #13 Clean up newly initialized Python API #1 Fixed bugs: Enable proper release workflow #8 Fix workflows so they succeed #2 Merged pull requests: [Auto-generated] Update dependencies #17 ( TEAM4-0 ) Use the package name tripper (not tripperpy ) #16 ( CasperWA ) Clean up repository & fix workflows #5 ( CasperWA ) Added version number in __init__ to enable local pip install #4 ( quaat ) * This Changelog was automatically generated by github_changelog_generator","title":"v0.1.1 (2022-10-13)"},{"location":"LICENSE/","text":"MIT License Copyright (c) 2022 SINTEF Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"planned-backends/","text":"Planned backends \u00b6 In addition to the currently existing backends, the following additional backends may be supported in upcoming versions: OntoRec/OntoFlowKB Stardog DLite triplestore (based on Redland librdf) Redland librdf Apache Jena Fuseki Allegrograph Wikidata","title":"Planned backends"},{"location":"planned-backends/#planned-backends","text":"In addition to the currently existing backends, the following additional backends may be supported in upcoming versions: OntoRec/OntoFlowKB Stardog DLite triplestore (based on Redland librdf) Redland librdf Apache Jena Fuseki Allegrograph Wikidata","title":"Planned backends"},{"location":"tutorial/","text":"Tutorial \u00b6 Create a triplestore instance using the rdflib backend: from tripper import Triplestore ts = Triplestore ( backend = \"rdflib\" ) The module already provides a set of pre-defined namespaces that simplifies writing IRIs. For example: from tripper import RDFS , OWL RDFS . subClassOf # -> 'http://www.w3.org/2000/01/rdf-schema#subClassOf' New namespaces can be created using the Namespace class, but are usually added with the bind() method: ONTO = ts . bind ( \"onto\" , \"http://example.com/onto#\" ) ONTO . MyConcept # -> 'http://example.com/onto#MyConcept' Namespace also supports access by label and IRI checking. Both of these features requires loading an ontology. The following example shows how to create an EMMO namespace with IRI checking. The keyword argument label_annotations=True enables access by skos:prefLabel , rdfs:label or skos:altLabel . The check=True enables checking for existing IRIs. The triplestore_url=... is a resolvable URL that can be read by the 'rdflib' backend. It is needed, because the 'rdflib' backend is currently not able to load EMMO from the http://emmo.info/emmo# namespace. EMMO = ts . bind ( \"emmo\" , \"http://emmo.info/emmo#\" , label_annotations = True , check = True , triplestore_url = \"https://emmo-repo.github.io/versions/1.0.0-beta4/emmo-inferred.ttl\" , ) EMMO . Atom # -> 'http://emmo.info/emmo#EMMO_eb77076b_a104_42ac_a065_798b2d2809ad' EMMO . invalid_name # -> NoSuchIRIError: http://emmo.info/emmo#invalid_name New triples can be added either with the parse() method (for backends that support it) or the add() and add_triples() methods: # en(msg) is a convenient function for adding english literals. # It is equivalent to ``tripper.Literal(msg, lang=\"en\")``. from tripper.utils import en ts . parse ( \"onto.ttl\" , format = \"turtle\" ) ts . add_triples ([ ( ONTO . MyConcept , RDFS . subClassOf , OWL . Thing ), ( ONTO . MyConcept , RDFS . label , en ( \"My briliant ontological concept.\" )), ]) For backends that support it the triplestore can be serialised using serialize() : ts . serialize ( \"onto2.ttl\" ) A set of convenient functions exists for simple queries, including triples() , subjects() , predicates() , objects() , subject_predicates() , subject_objects() , predicate_objects() and value() . Except for value() , they return the result as generators. For example: ts . objects ( subject = ONTO . MyConcept , predicate = RDFS . subClassOf ) # -> <generator object Triplestore.objects at 0x7fa502590200> list ( ts . objects ( subject = ONTO . MyConcept , predicate = RDFS . subClassOf )) # -> ['http://www.w3.org/2002/07/owl#Thing'] The query() and update() methods can be used to query and update the triplestore using SPARQL. Finally Triplestore has two specialised methods add_mapsTo() and add_function() that simplify working with mappings. add_mapsTo() is convinient for defining new mappings: from tripper import Namespace META = Namespace ( \"http://onto-ns.com/meta/0.1/MyEntity#\" ) ts . add_mapsTo ( ONTO . MyConcept , META . my_property ) It can also be used with DLite and SOFT7 data models. Here we repeat the above with DLite: import dlite meta = dlite . get_instance ( \"http://onto-ns.com/meta/0.1/MyEntity\" ) ts . add_mapsTo ( ONTO . MyConcept , meta , \"my_property\" ) The add_function() describes a function and adds mappings for its arguments and return value(s). Currently it only supports the Function Ontology (FnO) . def mean ( x , y ): \"\"\"Returns the mean value of `x` and `y`.\"\"\" return ( x + y ) / 2 ts . add_function ( mean , expects = ( ONTO . RightArmLength , ONTO . LeftArmLength ), returns = ONTO . AverageArmLength , )","title":"Tutorial"},{"location":"tutorial/#tutorial","text":"Create a triplestore instance using the rdflib backend: from tripper import Triplestore ts = Triplestore ( backend = \"rdflib\" ) The module already provides a set of pre-defined namespaces that simplifies writing IRIs. For example: from tripper import RDFS , OWL RDFS . subClassOf # -> 'http://www.w3.org/2000/01/rdf-schema#subClassOf' New namespaces can be created using the Namespace class, but are usually added with the bind() method: ONTO = ts . bind ( \"onto\" , \"http://example.com/onto#\" ) ONTO . MyConcept # -> 'http://example.com/onto#MyConcept' Namespace also supports access by label and IRI checking. Both of these features requires loading an ontology. The following example shows how to create an EMMO namespace with IRI checking. The keyword argument label_annotations=True enables access by skos:prefLabel , rdfs:label or skos:altLabel . The check=True enables checking for existing IRIs. The triplestore_url=... is a resolvable URL that can be read by the 'rdflib' backend. It is needed, because the 'rdflib' backend is currently not able to load EMMO from the http://emmo.info/emmo# namespace. EMMO = ts . bind ( \"emmo\" , \"http://emmo.info/emmo#\" , label_annotations = True , check = True , triplestore_url = \"https://emmo-repo.github.io/versions/1.0.0-beta4/emmo-inferred.ttl\" , ) EMMO . Atom # -> 'http://emmo.info/emmo#EMMO_eb77076b_a104_42ac_a065_798b2d2809ad' EMMO . invalid_name # -> NoSuchIRIError: http://emmo.info/emmo#invalid_name New triples can be added either with the parse() method (for backends that support it) or the add() and add_triples() methods: # en(msg) is a convenient function for adding english literals. # It is equivalent to ``tripper.Literal(msg, lang=\"en\")``. from tripper.utils import en ts . parse ( \"onto.ttl\" , format = \"turtle\" ) ts . add_triples ([ ( ONTO . MyConcept , RDFS . subClassOf , OWL . Thing ), ( ONTO . MyConcept , RDFS . label , en ( \"My briliant ontological concept.\" )), ]) For backends that support it the triplestore can be serialised using serialize() : ts . serialize ( \"onto2.ttl\" ) A set of convenient functions exists for simple queries, including triples() , subjects() , predicates() , objects() , subject_predicates() , subject_objects() , predicate_objects() and value() . Except for value() , they return the result as generators. For example: ts . objects ( subject = ONTO . MyConcept , predicate = RDFS . subClassOf ) # -> <generator object Triplestore.objects at 0x7fa502590200> list ( ts . objects ( subject = ONTO . MyConcept , predicate = RDFS . subClassOf )) # -> ['http://www.w3.org/2002/07/owl#Thing'] The query() and update() methods can be used to query and update the triplestore using SPARQL. Finally Triplestore has two specialised methods add_mapsTo() and add_function() that simplify working with mappings. add_mapsTo() is convinient for defining new mappings: from tripper import Namespace META = Namespace ( \"http://onto-ns.com/meta/0.1/MyEntity#\" ) ts . add_mapsTo ( ONTO . MyConcept , META . my_property ) It can also be used with DLite and SOFT7 data models. Here we repeat the above with DLite: import dlite meta = dlite . get_instance ( \"http://onto-ns.com/meta/0.1/MyEntity\" ) ts . add_mapsTo ( ONTO . MyConcept , meta , \"my_property\" ) The add_function() describes a function and adds mappings for its arguments and return value(s). Currently it only supports the Function Ontology (FnO) . def mean ( x , y ): \"\"\"Returns the mean value of `x` and `y`.\"\"\" return ( x + y ) / 2 ts . add_function ( mean , expects = ( ONTO . RightArmLength , ONTO . LeftArmLength ), returns = ONTO . AverageArmLength , )","title":"Tutorial"},{"location":"api_reference/errors/","text":"errors \u00b6 Exceptions for the triplestore package. NamespaceError ( TriplestoreError ) \u00b6 Namespace error. Source code in tripper/errors.py class NamespaceError ( TriplestoreError ): \"\"\"Namespace error.\"\"\" NoSuchIRIError ( NamespaceError ) \u00b6 Namespace has no such IRI. Source code in tripper/errors.py class NoSuchIRIError ( NamespaceError ): \"\"\"Namespace has no such IRI.\"\"\" TriplestoreError ( Exception ) \u00b6 Base exception for triplestore errors. Source code in tripper/errors.py class TriplestoreError ( Exception ): \"\"\"Base exception for triplestore errors.\"\"\" UniquenessError ( TriplestoreError ) \u00b6 More than one matching triple. Source code in tripper/errors.py class UniquenessError ( TriplestoreError ): \"\"\"More than one matching triple.\"\"\"","title":"errors"},{"location":"api_reference/errors/#errors","text":"Exceptions for the triplestore package.","title":"errors"},{"location":"api_reference/errors/#tripper.errors.NamespaceError","text":"Namespace error. Source code in tripper/errors.py class NamespaceError ( TriplestoreError ): \"\"\"Namespace error.\"\"\"","title":"NamespaceError"},{"location":"api_reference/errors/#tripper.errors.NoSuchIRIError","text":"Namespace has no such IRI. Source code in tripper/errors.py class NoSuchIRIError ( NamespaceError ): \"\"\"Namespace has no such IRI.\"\"\"","title":"NoSuchIRIError"},{"location":"api_reference/errors/#tripper.errors.TriplestoreError","text":"Base exception for triplestore errors. Source code in tripper/errors.py class TriplestoreError ( Exception ): \"\"\"Base exception for triplestore errors.\"\"\"","title":"TriplestoreError"},{"location":"api_reference/errors/#tripper.errors.UniquenessError","text":"More than one matching triple. Source code in tripper/errors.py class UniquenessError ( TriplestoreError ): \"\"\"More than one matching triple.\"\"\"","title":"UniquenessError"},{"location":"api_reference/interface/","text":"interface \u00b6 Provides the ITriplestore protocol class, that documents the interface of the triplestore backends. ITriplestore ( Protocol ) \u00b6 Interface for triplestore backends. In addition to the methods specified by this interface, a backend may also implement the following optional methods: def __init__ ( self , base_iri : str = None , ** kwargs ): \"\"\"Initialise triplestore. Arguments: base_iri: Optional base IRI to initiate the triplestore from. kwargs: Additional keyword arguments passed to the backend. \"\"\" def parse ( self , source : Union [ str , Path , IO ] = None , location : str = None , data : str = None , format : str = None , ** kwargs ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Arguments: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. kwargs: Additional backend-specific parameters controlling the parsing. \"\"\" def serialize ( self , destination : Union [ str , Path , IO ] = None , format : str = 'xml' , ** kwargs ): \"\"\"Serialise to destination. Arguments: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Additional backend-specific parameters controlling the serialisation. Returns: Serialised string if `destination` is None. \"\"\" def query ( self , query_object : str , ** kwargs ) -> List : \"\"\"SPARQL query. Arguments: query_object: String with the SPARQL query. kwargs: Additional backend-specific keyword arguments. Returns: List of tuples of IRIs for each matching row. \"\"\" def update ( self , update_object : str , ** kwargs ): \"\"\"Update triplestore with SPARQL. Arguments: query_object: String with the SPARQL query. kwargs: Additional backend-specific keyword arguments. Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" def bind ( self , prefix : str , namespace : str ) -> Namespace : \"\"\"Bind prefix to namespace. Should only be defined if the backend supports namespaces. \"\"\" def namespaces ( self ) -> dict : \"\"\"Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. \"\"\" Source code in tripper/interface.py class ITriplestore ( Protocol ): '''Interface for triplestore backends. In addition to the methods specified by this interface, a backend may also implement the following optional methods: ```python def __init__(self, base_iri: str = None, **kwargs): \"\"\"Initialise triplestore. Arguments: base_iri: Optional base IRI to initiate the triplestore from. kwargs: Additional keyword arguments passed to the backend. \"\"\" def parse( self, source: Union[str, Path, IO] = None, location: str = None, data: str = None, format: str = None, **kwargs ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Arguments: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. kwargs: Additional backend-specific parameters controlling the parsing. \"\"\" def serialize( self, destination: Union[str, Path, IO] = None, format: str ='xml', **kwargs ): \"\"\"Serialise to destination. Arguments: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Additional backend-specific parameters controlling the serialisation. Returns: Serialised string if `destination` is None. \"\"\" def query(self, query_object: str, **kwargs) -> List: \"\"\"SPARQL query. Arguments: query_object: String with the SPARQL query. kwargs: Additional backend-specific keyword arguments. Returns: List of tuples of IRIs for each matching row. \"\"\" def update(self, update_object: str, **kwargs): \"\"\"Update triplestore with SPARQL. Arguments: query_object: String with the SPARQL query. kwargs: Additional backend-specific keyword arguments. Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" def bind(self, prefix: str, namespace: str) -> Namespace: \"\"\"Bind prefix to namespace. Should only be defined if the backend supports namespaces. \"\"\" def namespaces(self) -> dict: \"\"\"Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. \"\"\" ``` ''' def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples. Arguments: triple: A `(s, p, o)` tuple where `s`, `p` and `o` should either be None (matching anything) or an exact IRI to match. \"\"\" def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples. Arguments: triples: A sequence of `(s, p, o)` tuples to add to the triplestore. \"\"\" def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" add_triples ( self , triples ) \u00b6 Add a sequence of triples. Parameters: Name Type Description Default triples Sequence[Triple] A sequence of (s, p, o) tuples to add to the triplestore. required Source code in tripper/interface.py def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples. Arguments: triples: A sequence of `(s, p, o)` tuples to add to the triplestore. \"\"\" remove ( self , triple ) \u00b6 Remove all matching triples from the backend. Source code in tripper/interface.py def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" triples ( self , triple ) \u00b6 Returns a generator over matching triples. Parameters: Name Type Description Default triple Triple A (s, p, o) tuple where s , p and o should either be None (matching anything) or an exact IRI to match. required Source code in tripper/interface.py def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples. Arguments: triple: A `(s, p, o)` tuple where `s`, `p` and `o` should either be None (matching anything) or an exact IRI to match. \"\"\"","title":"interface"},{"location":"api_reference/interface/#interface","text":"Provides the ITriplestore protocol class, that documents the interface of the triplestore backends.","title":"interface"},{"location":"api_reference/interface/#tripper.interface.ITriplestore","text":"Interface for triplestore backends. In addition to the methods specified by this interface, a backend may also implement the following optional methods: def __init__ ( self , base_iri : str = None , ** kwargs ): \"\"\"Initialise triplestore. Arguments: base_iri: Optional base IRI to initiate the triplestore from. kwargs: Additional keyword arguments passed to the backend. \"\"\" def parse ( self , source : Union [ str , Path , IO ] = None , location : str = None , data : str = None , format : str = None , ** kwargs ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Arguments: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. kwargs: Additional backend-specific parameters controlling the parsing. \"\"\" def serialize ( self , destination : Union [ str , Path , IO ] = None , format : str = 'xml' , ** kwargs ): \"\"\"Serialise to destination. Arguments: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Additional backend-specific parameters controlling the serialisation. Returns: Serialised string if `destination` is None. \"\"\" def query ( self , query_object : str , ** kwargs ) -> List : \"\"\"SPARQL query. Arguments: query_object: String with the SPARQL query. kwargs: Additional backend-specific keyword arguments. Returns: List of tuples of IRIs for each matching row. \"\"\" def update ( self , update_object : str , ** kwargs ): \"\"\"Update triplestore with SPARQL. Arguments: query_object: String with the SPARQL query. kwargs: Additional backend-specific keyword arguments. Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" def bind ( self , prefix : str , namespace : str ) -> Namespace : \"\"\"Bind prefix to namespace. Should only be defined if the backend supports namespaces. \"\"\" def namespaces ( self ) -> dict : \"\"\"Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. \"\"\" Source code in tripper/interface.py class ITriplestore ( Protocol ): '''Interface for triplestore backends. In addition to the methods specified by this interface, a backend may also implement the following optional methods: ```python def __init__(self, base_iri: str = None, **kwargs): \"\"\"Initialise triplestore. Arguments: base_iri: Optional base IRI to initiate the triplestore from. kwargs: Additional keyword arguments passed to the backend. \"\"\" def parse( self, source: Union[str, Path, IO] = None, location: str = None, data: str = None, format: str = None, **kwargs ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Arguments: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. kwargs: Additional backend-specific parameters controlling the parsing. \"\"\" def serialize( self, destination: Union[str, Path, IO] = None, format: str ='xml', **kwargs ): \"\"\"Serialise to destination. Arguments: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Additional backend-specific parameters controlling the serialisation. Returns: Serialised string if `destination` is None. \"\"\" def query(self, query_object: str, **kwargs) -> List: \"\"\"SPARQL query. Arguments: query_object: String with the SPARQL query. kwargs: Additional backend-specific keyword arguments. Returns: List of tuples of IRIs for each matching row. \"\"\" def update(self, update_object: str, **kwargs): \"\"\"Update triplestore with SPARQL. Arguments: query_object: String with the SPARQL query. kwargs: Additional backend-specific keyword arguments. Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" def bind(self, prefix: str, namespace: str) -> Namespace: \"\"\"Bind prefix to namespace. Should only be defined if the backend supports namespaces. \"\"\" def namespaces(self) -> dict: \"\"\"Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. \"\"\" ``` ''' def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples. Arguments: triple: A `(s, p, o)` tuple where `s`, `p` and `o` should either be None (matching anything) or an exact IRI to match. \"\"\" def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples. Arguments: triples: A sequence of `(s, p, o)` tuples to add to the triplestore. \"\"\" def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\"","title":"ITriplestore"},{"location":"api_reference/interface/#tripper.interface.ITriplestore.add_triples","text":"Add a sequence of triples. Parameters: Name Type Description Default triples Sequence[Triple] A sequence of (s, p, o) tuples to add to the triplestore. required Source code in tripper/interface.py def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples. Arguments: triples: A sequence of `(s, p, o)` tuples to add to the triplestore. \"\"\"","title":"add_triples()"},{"location":"api_reference/interface/#tripper.interface.ITriplestore.remove","text":"Remove all matching triples from the backend. Source code in tripper/interface.py def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\"","title":"remove()"},{"location":"api_reference/interface/#tripper.interface.ITriplestore.triples","text":"Returns a generator over matching triples. Parameters: Name Type Description Default triple Triple A (s, p, o) tuple where s , p and o should either be None (matching anything) or an exact IRI to match. required Source code in tripper/interface.py def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples. Arguments: triple: A `(s, p, o)` tuple where `s`, `p` and `o` should either be None (matching anything) or an exact IRI to match. \"\"\"","title":"triples()"},{"location":"api_reference/literal/","text":"literal \u00b6 Literal rdf values. Literal ( str ) \u00b6 A literal RDF value. Parameters: Name Type Description Default value Union[datetime, bytes, bytearray, bool, int, float, str] The literal value. See the datatypes class attribute for valid supported data types. A localised string is provided as a string with lang set to a language code. required lang Optional[str] A standard language code, like \"en\", \"no\", etc. Implies that the value is a localised string. required datatype Any Explicit specification of the type of value . Should not be combined with lang . required Source code in tripper/literal.py class Literal ( str ): \"\"\"A literal RDF value. Arguments: value (Union[datetime, bytes, bytearray, bool, int, float, str]): The literal value. See the `datatypes` class attribute for valid supported data types. A localised string is provided as a string with `lang` set to a language code. lang (Optional[str]): A standard language code, like \"en\", \"no\", etc. Implies that the `value` is a localised string. datatype (Any): Explicit specification of the type of `value`. Should not be combined with `lang`. \"\"\" lang : \"Union[str, None]\" datatype : \"Any\" # Note that the order of datatypes matters - it is used by # utils.parse_literal() when inferring the datatype of a literal. datatypes = { datetime : XSD . dateTime , bytes : XSD . hexBinary , bytearray : XSD . hexBinary , bool : XSD . boolean , int : XSD . integer , float : XSD . double , str : XSD . string , } def __new__ ( cls , value : \"Union[datetime, bytes, bytearray, bool, int, float, str]\" , lang : \"Optional[str]\" = None , datatype : \"Optional[Any]\" = None , ): string = super () . __new__ ( cls , value ) if lang : if datatype : raise TypeError ( \"A literal can only have one of `lang` or `datatype`.\" ) string . lang = str ( lang ) string . datatype = None else : string . lang = None if datatype : string . datatype = cls . datatypes . get ( datatype , datatype ) elif isinstance ( value , str ): string . datatype = None elif isinstance ( value , bool ): string . datatype = XSD . boolean elif isinstance ( value , int ): string . datatype = XSD . integer elif isinstance ( value , float ): string . datatype = XSD . double elif isinstance ( value , ( bytes , bytearray )): # Re-initialize the value anew, similarly to what is done in the first # line of this method. string = super () . __new__ ( cls , value . hex ()) string . lang = None string . datatype = XSD . hexBinary elif isinstance ( value , datetime ): string . datatype = XSD . dateTime # TODO: # - XSD.base64Binary # - XSD.byte, XSD.unsignedByte else : string . datatype = None return string def __repr__ ( self ) -> str : lang = f \", lang= { self . lang !r} \" if self . lang else \"\" datatype = f \", datatype= { self . datatype !r} \" if self . datatype else \"\" return f \"Literal( { self !r}{ lang }{ datatype } )\" value = property ( fget = lambda self : self . to_python (), doc = \"Appropriate python datatype derived from this RDF literal.\" , ) def to_python ( self ): \"\"\"Returns an appropriate python datatype derived from this RDF literal.\"\"\" value = str ( self ) if self . datatype == XSD . boolean : value = False if self == \"False\" else bool ( self ) elif self . datatype in ( XSD . integer , XSD . int , XSD . short , XSD . long , XSD . nonPositiveInteger , XSD . negativeInteger , XSD . nonNegativeInteger , XSD . unsignedInt , XSD . unsignedShort , XSD . unsignedLong , XSD . byte , XSD . unsignedByte , ): value = int ( self ) elif self . datatype in ( XSD . double , XSD . decimal , XSD . dataTimeStamp , OWL . real , OWL . rational , ): value = float ( self ) elif self . datatype == XSD . hexBinary : value = self . encode () elif self . datatype == XSD . dateTime : value = datetime . fromisoformat ( self ) elif self . datatype and self . datatype not in ( RDF . PlainLiteral , RDF . XMLLiteral , RDFS . Literal , XSD . anyURI , XSD . language , XSD . Name , XSD . NMName , XSD . normalizedString , XSD . string , XSD . token , XSD . NMTOKEN , ): warnings . warn ( f \"unknown datatype: { self . datatype } - assuming string\" ) return value def n3 ( self ) -> str : # pylint: disable=invalid-name \"\"\"Returns a representation in n3 format.\"\"\" if self . lang : return f '\" { self } \"@ { self . lang } ' if self . datatype : return f '\" { self } \"^^ { self . datatype } ' return f '\" { self } \"' value property readonly \u00b6 Appropriate python datatype derived from this RDF literal. __new__ ( cls , value , lang = None , datatype = None ) special staticmethod \u00b6 Create and return a new object. See help(type) for accurate signature. Source code in tripper/literal.py def __new__ ( cls , value : \"Union[datetime, bytes, bytearray, bool, int, float, str]\" , lang : \"Optional[str]\" = None , datatype : \"Optional[Any]\" = None , ): string = super () . __new__ ( cls , value ) if lang : if datatype : raise TypeError ( \"A literal can only have one of `lang` or `datatype`.\" ) string . lang = str ( lang ) string . datatype = None else : string . lang = None if datatype : string . datatype = cls . datatypes . get ( datatype , datatype ) elif isinstance ( value , str ): string . datatype = None elif isinstance ( value , bool ): string . datatype = XSD . boolean elif isinstance ( value , int ): string . datatype = XSD . integer elif isinstance ( value , float ): string . datatype = XSD . double elif isinstance ( value , ( bytes , bytearray )): # Re-initialize the value anew, similarly to what is done in the first # line of this method. string = super () . __new__ ( cls , value . hex ()) string . lang = None string . datatype = XSD . hexBinary elif isinstance ( value , datetime ): string . datatype = XSD . dateTime # TODO: # - XSD.base64Binary # - XSD.byte, XSD.unsignedByte else : string . datatype = None return string n3 ( self ) \u00b6 Returns a representation in n3 format. Source code in tripper/literal.py def n3 ( self ) -> str : # pylint: disable=invalid-name \"\"\"Returns a representation in n3 format.\"\"\" if self . lang : return f '\" { self } \"@ { self . lang } ' if self . datatype : return f '\" { self } \"^^ { self . datatype } ' return f '\" { self } \"' to_python ( self ) \u00b6 Returns an appropriate python datatype derived from this RDF literal. Source code in tripper/literal.py def to_python ( self ): \"\"\"Returns an appropriate python datatype derived from this RDF literal.\"\"\" value = str ( self ) if self . datatype == XSD . boolean : value = False if self == \"False\" else bool ( self ) elif self . datatype in ( XSD . integer , XSD . int , XSD . short , XSD . long , XSD . nonPositiveInteger , XSD . negativeInteger , XSD . nonNegativeInteger , XSD . unsignedInt , XSD . unsignedShort , XSD . unsignedLong , XSD . byte , XSD . unsignedByte , ): value = int ( self ) elif self . datatype in ( XSD . double , XSD . decimal , XSD . dataTimeStamp , OWL . real , OWL . rational , ): value = float ( self ) elif self . datatype == XSD . hexBinary : value = self . encode () elif self . datatype == XSD . dateTime : value = datetime . fromisoformat ( self ) elif self . datatype and self . datatype not in ( RDF . PlainLiteral , RDF . XMLLiteral , RDFS . Literal , XSD . anyURI , XSD . language , XSD . Name , XSD . NMName , XSD . normalizedString , XSD . string , XSD . token , XSD . NMTOKEN , ): warnings . warn ( f \"unknown datatype: { self . datatype } - assuming string\" ) return value","title":"literal"},{"location":"api_reference/literal/#literal","text":"Literal rdf values.","title":"literal"},{"location":"api_reference/literal/#tripper.literal.Literal","text":"A literal RDF value. Parameters: Name Type Description Default value Union[datetime, bytes, bytearray, bool, int, float, str] The literal value. See the datatypes class attribute for valid supported data types. A localised string is provided as a string with lang set to a language code. required lang Optional[str] A standard language code, like \"en\", \"no\", etc. Implies that the value is a localised string. required datatype Any Explicit specification of the type of value . Should not be combined with lang . required Source code in tripper/literal.py class Literal ( str ): \"\"\"A literal RDF value. Arguments: value (Union[datetime, bytes, bytearray, bool, int, float, str]): The literal value. See the `datatypes` class attribute for valid supported data types. A localised string is provided as a string with `lang` set to a language code. lang (Optional[str]): A standard language code, like \"en\", \"no\", etc. Implies that the `value` is a localised string. datatype (Any): Explicit specification of the type of `value`. Should not be combined with `lang`. \"\"\" lang : \"Union[str, None]\" datatype : \"Any\" # Note that the order of datatypes matters - it is used by # utils.parse_literal() when inferring the datatype of a literal. datatypes = { datetime : XSD . dateTime , bytes : XSD . hexBinary , bytearray : XSD . hexBinary , bool : XSD . boolean , int : XSD . integer , float : XSD . double , str : XSD . string , } def __new__ ( cls , value : \"Union[datetime, bytes, bytearray, bool, int, float, str]\" , lang : \"Optional[str]\" = None , datatype : \"Optional[Any]\" = None , ): string = super () . __new__ ( cls , value ) if lang : if datatype : raise TypeError ( \"A literal can only have one of `lang` or `datatype`.\" ) string . lang = str ( lang ) string . datatype = None else : string . lang = None if datatype : string . datatype = cls . datatypes . get ( datatype , datatype ) elif isinstance ( value , str ): string . datatype = None elif isinstance ( value , bool ): string . datatype = XSD . boolean elif isinstance ( value , int ): string . datatype = XSD . integer elif isinstance ( value , float ): string . datatype = XSD . double elif isinstance ( value , ( bytes , bytearray )): # Re-initialize the value anew, similarly to what is done in the first # line of this method. string = super () . __new__ ( cls , value . hex ()) string . lang = None string . datatype = XSD . hexBinary elif isinstance ( value , datetime ): string . datatype = XSD . dateTime # TODO: # - XSD.base64Binary # - XSD.byte, XSD.unsignedByte else : string . datatype = None return string def __repr__ ( self ) -> str : lang = f \", lang= { self . lang !r} \" if self . lang else \"\" datatype = f \", datatype= { self . datatype !r} \" if self . datatype else \"\" return f \"Literal( { self !r}{ lang }{ datatype } )\" value = property ( fget = lambda self : self . to_python (), doc = \"Appropriate python datatype derived from this RDF literal.\" , ) def to_python ( self ): \"\"\"Returns an appropriate python datatype derived from this RDF literal.\"\"\" value = str ( self ) if self . datatype == XSD . boolean : value = False if self == \"False\" else bool ( self ) elif self . datatype in ( XSD . integer , XSD . int , XSD . short , XSD . long , XSD . nonPositiveInteger , XSD . negativeInteger , XSD . nonNegativeInteger , XSD . unsignedInt , XSD . unsignedShort , XSD . unsignedLong , XSD . byte , XSD . unsignedByte , ): value = int ( self ) elif self . datatype in ( XSD . double , XSD . decimal , XSD . dataTimeStamp , OWL . real , OWL . rational , ): value = float ( self ) elif self . datatype == XSD . hexBinary : value = self . encode () elif self . datatype == XSD . dateTime : value = datetime . fromisoformat ( self ) elif self . datatype and self . datatype not in ( RDF . PlainLiteral , RDF . XMLLiteral , RDFS . Literal , XSD . anyURI , XSD . language , XSD . Name , XSD . NMName , XSD . normalizedString , XSD . string , XSD . token , XSD . NMTOKEN , ): warnings . warn ( f \"unknown datatype: { self . datatype } - assuming string\" ) return value def n3 ( self ) -> str : # pylint: disable=invalid-name \"\"\"Returns a representation in n3 format.\"\"\" if self . lang : return f '\" { self } \"@ { self . lang } ' if self . datatype : return f '\" { self } \"^^ { self . datatype } ' return f '\" { self } \"'","title":"Literal"},{"location":"api_reference/literal/#tripper.literal.Literal.value","text":"Appropriate python datatype derived from this RDF literal.","title":"value"},{"location":"api_reference/literal/#tripper.literal.Literal.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in tripper/literal.py def __new__ ( cls , value : \"Union[datetime, bytes, bytearray, bool, int, float, str]\" , lang : \"Optional[str]\" = None , datatype : \"Optional[Any]\" = None , ): string = super () . __new__ ( cls , value ) if lang : if datatype : raise TypeError ( \"A literal can only have one of `lang` or `datatype`.\" ) string . lang = str ( lang ) string . datatype = None else : string . lang = None if datatype : string . datatype = cls . datatypes . get ( datatype , datatype ) elif isinstance ( value , str ): string . datatype = None elif isinstance ( value , bool ): string . datatype = XSD . boolean elif isinstance ( value , int ): string . datatype = XSD . integer elif isinstance ( value , float ): string . datatype = XSD . double elif isinstance ( value , ( bytes , bytearray )): # Re-initialize the value anew, similarly to what is done in the first # line of this method. string = super () . __new__ ( cls , value . hex ()) string . lang = None string . datatype = XSD . hexBinary elif isinstance ( value , datetime ): string . datatype = XSD . dateTime # TODO: # - XSD.base64Binary # - XSD.byte, XSD.unsignedByte else : string . datatype = None return string","title":"__new__()"},{"location":"api_reference/literal/#tripper.literal.Literal.n3","text":"Returns a representation in n3 format. Source code in tripper/literal.py def n3 ( self ) -> str : # pylint: disable=invalid-name \"\"\"Returns a representation in n3 format.\"\"\" if self . lang : return f '\" { self } \"@ { self . lang } ' if self . datatype : return f '\" { self } \"^^ { self . datatype } ' return f '\" { self } \"'","title":"n3()"},{"location":"api_reference/literal/#tripper.literal.Literal.to_python","text":"Returns an appropriate python datatype derived from this RDF literal. Source code in tripper/literal.py def to_python ( self ): \"\"\"Returns an appropriate python datatype derived from this RDF literal.\"\"\" value = str ( self ) if self . datatype == XSD . boolean : value = False if self == \"False\" else bool ( self ) elif self . datatype in ( XSD . integer , XSD . int , XSD . short , XSD . long , XSD . nonPositiveInteger , XSD . negativeInteger , XSD . nonNegativeInteger , XSD . unsignedInt , XSD . unsignedShort , XSD . unsignedLong , XSD . byte , XSD . unsignedByte , ): value = int ( self ) elif self . datatype in ( XSD . double , XSD . decimal , XSD . dataTimeStamp , OWL . real , OWL . rational , ): value = float ( self ) elif self . datatype == XSD . hexBinary : value = self . encode () elif self . datatype == XSD . dateTime : value = datetime . fromisoformat ( self ) elif self . datatype and self . datatype not in ( RDF . PlainLiteral , RDF . XMLLiteral , RDFS . Literal , XSD . anyURI , XSD . language , XSD . Name , XSD . NMName , XSD . normalizedString , XSD . string , XSD . token , XSD . NMTOKEN , ): warnings . warn ( f \"unknown datatype: { self . datatype } - assuming string\" ) return value","title":"to_python()"},{"location":"api_reference/namespace/","text":"namespace \u00b6 Provides a simple representation of namespaces. Namespace \u00b6 Represent a namespace. Parameters: Name Type Description Default iri IRI of namespace to represent. required label_annotations Sequence of label annotations. If given, check the underlying ontology during attribute access if the name correspond to a label. The label annotations should be ordered from highest to lowest precedense. If True is provided, label_annotations is set to (SKOS.prefLabel, RDF.label, SKOS.altLabel) . () check Whether to check underlying ontology if the IRI exists during attribute access. If true, NoSuchIRIError will be raised if the IRI does not exist in this namespace. False cachemode Should be one of: - Namespace.NO_CACHE: Turn off caching. - Namespace.USE_CACHE: Cache attributes as they are looked up. - Namespace.ONLY_CACHE: Cache all names at initialisation time. Do not access the triplestore after that. Default is NO_CACHE if neither label_annotations or check is given, otherwise USE_CACHE . -1 triplestore Use this triplestore for label lookup and checking. If not given, and either label_annotations or check are enabled, a new rdflib triplestore will be created. None triplestore_url Alternative URL to use for loading the underlying ontology if triplestore is not given. Defaults to iri . None Source code in tripper/namespace.py class Namespace : \"\"\"Represent a namespace. Arguments: iri: IRI of namespace to represent. label_annotations: Sequence of label annotations. If given, check the underlying ontology during attribute access if the name correspond to a label. The label annotations should be ordered from highest to lowest precedense. If True is provided, `label_annotations` is set to ``(SKOS.prefLabel, RDF.label, SKOS.altLabel)``. check: Whether to check underlying ontology if the IRI exists during attribute access. If true, NoSuchIRIError will be raised if the IRI does not exist in this namespace. cachemode: Should be one of: - Namespace.NO_CACHE: Turn off caching. - Namespace.USE_CACHE: Cache attributes as they are looked up. - Namespace.ONLY_CACHE: Cache all names at initialisation time. Do not access the triplestore after that. Default is `NO_CACHE` if neither `label_annotations` or `check` is given, otherwise `USE_CACHE`. triplestore: Use this triplestore for label lookup and checking. If not given, and either `label_annotations` or `check` are enabled, a new rdflib triplestore will be created. triplestore_url: Alternative URL to use for loading the underlying ontology if `triplestore` is not given. Defaults to `iri`. \"\"\" NO_CACHE = 0 USE_CACHE = 1 ONLY_CACHE = 2 __slots__ = ( \"_iri\" , \"_label_annotations\" , \"_check\" , \"_cache\" , \"_triplestore\" , ) def __init__ ( self , iri , label_annotations = (), check = False , cachemode =- 1 , triplestore = None , triplestore_url = None , ): if label_annotations is True : label_annotations = ( SKOS . prefLabel , RDF . label , SKOS . altLabel ) self . _iri = str ( iri ) self . _label_annotations = tuple ( label_annotations ) self . _check = bool ( check ) need_triplestore = bool ( check or label_annotations ) if cachemode == - 1 : cachemode = Namespace . ONLY_CACHE if need_triplestore else Namespace . NO_CACHE if need_triplestore and triplestore is None : # Import Triplestore here to break cyclic-import from .triplestore import ( # pylint: disable=import-outside-toplevel,cyclic-import Triplestore , ) triplestore = Triplestore ( \"rdflib\" , base_iri = iri , triplestore_url = triplestore_url ) self . _cache = {} if cachemode != Namespace . NO_CACHE else None # # FIXME: # Change this to only assigning the triplestore if cachemode is # ONLY_CACHE when we figure out a good way to pre-populate the # cache with IRIs from the triplestore. # # self._triplestore = ( # triplestore if cachemode != Namespace.ONLY_CACHE else None # ) self . _triplestore = triplestore if need_triplestore else None if cachemode != Namespace . NO_CACHE : self . _update_cache ( triplestore ) def _update_cache ( self , triplestore = None ): \"\"\"Update the internal cache from `triplestore`.\"\"\" if not triplestore : triplestore = self . _triplestore if not triplestore : raise NamespaceError ( \"`triplestore` argument needed for updating the cache\" ) if self . _cache is None : self . _cache = {} # Add (label, full_iri) pairs to cache for label in reversed ( self . _label_annotations ): self . _cache . update ( ( o , s ) for s , o in triplestore . subject_objects ( label ) if s . startswith ( self . _iri ) ) # Add (name, full_iri) pairs to cache # Currently we only check concepts that defines RDFS.isDefinedBy # relations. # Is there an efficient way to loop over all IRIs in this namespace? self . _cache . update ( ( s [ len ( self . _iri ) :], s ) for s in triplestore . subjects ( RDFS . isDefinedBy , self . _iri ) if s . startswith ( self . _iri ) ) def __getattr__ ( self , name ): if self . _cache and name in self . _cache : return self . _cache [ name ] if self . _triplestore : # Check if ``iri = self._iri + name`` is in the triplestore. # If so, add it to the cache. # We only need to check that generator returned by # `self._triplestore.predicate_objects(iri)` is non-empty. iri = self . _iri + name predicate_object = self . _triplestore . predicate_objects ( iri ) try : predicate_object . __next__ () except StopIteration : pass else : if self . _cache is not None : self . _cache [ name ] = iri return iri # Check for label annotations matching `name`. for label in self . _label_annotations : for s , o in self . _triplestore . subject_objects ( label ): if o == name and s . startswith ( self . _iri ): if self . _cache is not None : self . _cache [ name ] = s return s if self . _check : raise NoSuchIRIError ( self . _iri + name ) return self . _iri + name def __getitem__ ( self , key ): return self . __getattr__ ( key ) def __repr__ ( self ): return f \"Namespace( { self . _iri } )\" def __str__ ( self ): return self . _iri def __add__ ( self , other ): return self . _iri + str ( other )","title":"namespace"},{"location":"api_reference/namespace/#namespace","text":"Provides a simple representation of namespaces.","title":"namespace"},{"location":"api_reference/namespace/#tripper.namespace.Namespace","text":"Represent a namespace. Parameters: Name Type Description Default iri IRI of namespace to represent. required label_annotations Sequence of label annotations. If given, check the underlying ontology during attribute access if the name correspond to a label. The label annotations should be ordered from highest to lowest precedense. If True is provided, label_annotations is set to (SKOS.prefLabel, RDF.label, SKOS.altLabel) . () check Whether to check underlying ontology if the IRI exists during attribute access. If true, NoSuchIRIError will be raised if the IRI does not exist in this namespace. False cachemode Should be one of: - Namespace.NO_CACHE: Turn off caching. - Namespace.USE_CACHE: Cache attributes as they are looked up. - Namespace.ONLY_CACHE: Cache all names at initialisation time. Do not access the triplestore after that. Default is NO_CACHE if neither label_annotations or check is given, otherwise USE_CACHE . -1 triplestore Use this triplestore for label lookup and checking. If not given, and either label_annotations or check are enabled, a new rdflib triplestore will be created. None triplestore_url Alternative URL to use for loading the underlying ontology if triplestore is not given. Defaults to iri . None Source code in tripper/namespace.py class Namespace : \"\"\"Represent a namespace. Arguments: iri: IRI of namespace to represent. label_annotations: Sequence of label annotations. If given, check the underlying ontology during attribute access if the name correspond to a label. The label annotations should be ordered from highest to lowest precedense. If True is provided, `label_annotations` is set to ``(SKOS.prefLabel, RDF.label, SKOS.altLabel)``. check: Whether to check underlying ontology if the IRI exists during attribute access. If true, NoSuchIRIError will be raised if the IRI does not exist in this namespace. cachemode: Should be one of: - Namespace.NO_CACHE: Turn off caching. - Namespace.USE_CACHE: Cache attributes as they are looked up. - Namespace.ONLY_CACHE: Cache all names at initialisation time. Do not access the triplestore after that. Default is `NO_CACHE` if neither `label_annotations` or `check` is given, otherwise `USE_CACHE`. triplestore: Use this triplestore for label lookup and checking. If not given, and either `label_annotations` or `check` are enabled, a new rdflib triplestore will be created. triplestore_url: Alternative URL to use for loading the underlying ontology if `triplestore` is not given. Defaults to `iri`. \"\"\" NO_CACHE = 0 USE_CACHE = 1 ONLY_CACHE = 2 __slots__ = ( \"_iri\" , \"_label_annotations\" , \"_check\" , \"_cache\" , \"_triplestore\" , ) def __init__ ( self , iri , label_annotations = (), check = False , cachemode =- 1 , triplestore = None , triplestore_url = None , ): if label_annotations is True : label_annotations = ( SKOS . prefLabel , RDF . label , SKOS . altLabel ) self . _iri = str ( iri ) self . _label_annotations = tuple ( label_annotations ) self . _check = bool ( check ) need_triplestore = bool ( check or label_annotations ) if cachemode == - 1 : cachemode = Namespace . ONLY_CACHE if need_triplestore else Namespace . NO_CACHE if need_triplestore and triplestore is None : # Import Triplestore here to break cyclic-import from .triplestore import ( # pylint: disable=import-outside-toplevel,cyclic-import Triplestore , ) triplestore = Triplestore ( \"rdflib\" , base_iri = iri , triplestore_url = triplestore_url ) self . _cache = {} if cachemode != Namespace . NO_CACHE else None # # FIXME: # Change this to only assigning the triplestore if cachemode is # ONLY_CACHE when we figure out a good way to pre-populate the # cache with IRIs from the triplestore. # # self._triplestore = ( # triplestore if cachemode != Namespace.ONLY_CACHE else None # ) self . _triplestore = triplestore if need_triplestore else None if cachemode != Namespace . NO_CACHE : self . _update_cache ( triplestore ) def _update_cache ( self , triplestore = None ): \"\"\"Update the internal cache from `triplestore`.\"\"\" if not triplestore : triplestore = self . _triplestore if not triplestore : raise NamespaceError ( \"`triplestore` argument needed for updating the cache\" ) if self . _cache is None : self . _cache = {} # Add (label, full_iri) pairs to cache for label in reversed ( self . _label_annotations ): self . _cache . update ( ( o , s ) for s , o in triplestore . subject_objects ( label ) if s . startswith ( self . _iri ) ) # Add (name, full_iri) pairs to cache # Currently we only check concepts that defines RDFS.isDefinedBy # relations. # Is there an efficient way to loop over all IRIs in this namespace? self . _cache . update ( ( s [ len ( self . _iri ) :], s ) for s in triplestore . subjects ( RDFS . isDefinedBy , self . _iri ) if s . startswith ( self . _iri ) ) def __getattr__ ( self , name ): if self . _cache and name in self . _cache : return self . _cache [ name ] if self . _triplestore : # Check if ``iri = self._iri + name`` is in the triplestore. # If so, add it to the cache. # We only need to check that generator returned by # `self._triplestore.predicate_objects(iri)` is non-empty. iri = self . _iri + name predicate_object = self . _triplestore . predicate_objects ( iri ) try : predicate_object . __next__ () except StopIteration : pass else : if self . _cache is not None : self . _cache [ name ] = iri return iri # Check for label annotations matching `name`. for label in self . _label_annotations : for s , o in self . _triplestore . subject_objects ( label ): if o == name and s . startswith ( self . _iri ): if self . _cache is not None : self . _cache [ name ] = s return s if self . _check : raise NoSuchIRIError ( self . _iri + name ) return self . _iri + name def __getitem__ ( self , key ): return self . __getattr__ ( key ) def __repr__ ( self ): return f \"Namespace( { self . _iri } )\" def __str__ ( self ): return self . _iri def __add__ ( self , other ): return self . _iri + str ( other )","title":"Namespace"},{"location":"api_reference/triplestore/","text":"triplestore \u00b6 A module encapsulating different triplestores using the strategy design pattern. See https://raw.githubusercontent.com/EMMC-ASBL/tripper/master/README.md for an introduction. This module has no dependencies outside the standard library, but the triplestore backends may have. For developers: The usage of s , p , and o represent the different parts of an RDF Triple: subject, predicate, and object. Triplestore \u00b6 Provides a common frontend to a range of triplestore backends. Source code in tripper/triplestore.py class Triplestore : \"\"\"Provides a common frontend to a range of triplestore backends.\"\"\" default_namespaces = { \"xml\" : XML , \"rdf\" : RDF , \"rdfs\" : RDFS , \"xsd\" : XSD , \"owl\" : OWL , # \"skos\": SKOS, # \"dc\": DC, # \"dcterms\": DCTERMS, # \"foaf\": FOAF, # \"doap\": DOAP, # \"fno\": FNO, # \"emmo\": EMMO, # \"map\": MAP, # \"dm\": DM, } def __init__ ( self , backend : str , base_iri : \"Optional[str]\" = None , ** kwargs ) -> None : \"\"\"Initialise triplestore using the backend with the given name. Parameters: backend: Name of the backend module. base_iri: Base IRI used by the add_function() method when adding new triples. kwargs: Keyword arguments passed to the backend's __init__() method. \"\"\" module = import_module ( backend if \".\" in backend else f \"tripper.backends. { backend } \" ) cls = getattr ( module , f \" { backend . title () } Strategy\" ) self . base_iri = base_iri self . namespaces : \"Dict[str, Namespace]\" = {} self . closed = False self . backend_name = backend self . backend = cls ( base_iri = base_iri , ** kwargs ) # Keep functions in the triplestore for convienence even though # they usually do not belong to the triplestore per se. self . function_repo : \"Dict[str, Union[float, Callable[[], float], None]]\" = {} for prefix , namespace in self . default_namespaces . items (): self . bind ( prefix , namespace ) # Methods implemented by backend # ------------------------------ def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples. Arguments: triple: A `(s, p, o)` tuple where `s`, `p` and `o` should either be None (matching anything) or an exact IRI to match. \"\"\" return self . backend . triples ( triple ) def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples. Arguments: triples: A sequence of `(s, p, o)` tuples to add to the triplestore. \"\"\" self . backend . add_triples ( triples ) def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" self . backend . remove ( triple ) # Methods optionally implemented by backend # ----------------------------------------- def close ( self ): \"\"\"Calls the backend close() method if it is implemented. Otherwise, this method has no effect. \"\"\" # It should be ok to call close() regardless of whether the backend # implements this method or not. Hence, don't call _check_method(). if not self . closed and hasattr ( self . backend , \"close\" ): self . backend . close () self . closed = True def parse ( self , source = None , format = None , ** kwargs # pylint: disable=redefined-builtin ): \"\"\"Parse source and add the resulting triples to triplestore. Parameters: source: File-like object or file name. format: Needed if format can not be inferred from source. kwargs: Keyword arguments passed to the backend. The rdflib backend supports e.g. `location` (absolute or relative URL) and `data` (string containing the data to be parsed) arguments. \"\"\" self . _check_method ( \"parse\" ) self . backend . parse ( source = source , format = format , ** kwargs ) if hasattr ( self . backend , \"namespaces\" ): for prefix , namespace in self . backend . namespaces () . items (): if prefix and prefix not in self . namespaces : self . namespaces [ prefix ] = Namespace ( namespace ) def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise triplestore. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the backend serialize() method. Returns: Serialized string if `destination` is None. \"\"\" self . _check_method ( \"serialize\" ) return self . backend . serialize ( destination = destination , format = format , ** kwargs ) def query ( self , query_object , ** kwargs ) -> \"List[Tuple[str, ...]]\" : \"\"\"SPARQL query. Parameters: query_object: String with the SPARQL query. kwargs: Keyword arguments passed to the backend query() method. Returns: List of tuples of IRIs for each matching row. Note: This method is intended for SELECT queries. Use the update() method for INSERT and DELETE queries. \"\"\" self . _check_method ( \"query\" ) return self . backend . query ( query_object = query_object , ** kwargs ) def update ( self , update_object , ** kwargs ) -> None : \"\"\"Update triplestore with SPARQL. Parameters: update_object: String with the SPARQL query. kwargs: Keyword arguments passed to the backend update() method. Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" self . _check_method ( \"update\" ) return self . backend . update ( update_object = update_object , ** kwargs ) def bind ( self , prefix : str , namespace : \"Union[str, Namespace]\" , ** kwargs ): \"\"\"Bind prefix to namespace and return the new Namespace object. The new Namespace is created with `namespace` as IRI. Keyword arguments are passed to the Namespace() constructor. If `namespace` is None, the corresponding prefix is removed. \"\"\" if hasattr ( self . backend , \"bind\" ): self . backend . bind ( prefix , namespace ) if namespace is None : del self . namespaces [ prefix ] return None self . namespaces [ prefix ] = ( namespace if isinstance ( namespace , Namespace ) else Namespace ( namespace , ** kwargs ) ) return self . namespaces [ prefix ] # Convenient methods # ------------------ # These methods are modelled after rdflib and provide some convinient # interfaces to the triples(), add_triples() and remove() methods # implemented by all backends. def _check_method ( self , name ): \"\"\"Check that backend implements the given method.\"\"\" if not hasattr ( self . backend , name ): raise NotImplementedError ( f \"Triplestore backend { self . backend_name !r} do not implement a \" f '\" { name } ()\" method.' ) def add ( self , triple : \"Triple\" ): \"\"\"Add `triple` to triplestore.\"\"\" self . add_triples ([ triple ]) def value ( # pylint: disable=redefined-builtin self , subject = None , predicate = None , object = None , default = None , any = False ): \"\"\"Return the value for a pair of two criteria. Useful if one knows that there may only be one value. Parameters: subject, predicate, object: Triple to match. default: Value to return if no matches are found. any: If true, return any matching value, otherwise raise UniquenessError. \"\"\" triple = self . triples (( subject , predicate , object )) try : value = next ( triple ) except StopIteration : return default if any : return value try : next ( triple ) except StopIteration : return value else : raise UniquenessError ( \"More than one match\" ) def subjects ( self , predicate = None , object = None # pylint: disable=redefined-builtin ): \"\"\"Returns a generator of subjects for given predicate and object.\"\"\" for s , _ , _ in self . triples (( None , predicate , object )): yield s def predicates ( self , subject = None , object = None # pylint: disable=redefined-builtin ): \"\"\"Returns a generator of predicates for given subject and object.\"\"\" for _ , p , _ in self . triples (( subject , None , object )): yield p def objects ( self , subject = None , predicate = None ): \"\"\"Returns a generator of objects for given subject and predicate.\"\"\" for _ , _ , o in self . triples (( subject , predicate , None )): yield o def subject_predicates ( self , object = None ): # pylint: disable=redefined-builtin \"\"\"Returns a generator of (subject, predicate) tuples for given object.\"\"\" for s , p , _ in self . triples (( None , None , object )): yield s , p def subject_objects ( self , predicate = None ): \"\"\"Returns a generator of (subject, object) tuples for given predicate.\"\"\" for s , _ , o in self . triples (( None , predicate , None )): yield s , o def predicate_objects ( self , subject = None ): \"\"\"Returns a generator of (predicate, object) tuples for given subject.\"\"\" for _ , p , o in self . triples (( subject , None , None )): yield p , o def set ( self , triple ): \"\"\"Convenience method to update the value of object. Removes any existing triples for subject and predicate before adding the given `triple`. \"\"\" s , p , _ = triple self . remove (( s , p , None )) self . add ( triple ) def has ( self , subject = None , predicate = None , object = None ): # pylint: disable=redefined-builtin \"\"\"Returns true if the triplestore has any triple matching the give subject, predicate and/or object.\"\"\" triple = self . triples (( subject , predicate , object )) try : next ( triple ) except StopIteration : return False return True # Methods providing additional functionality # ------------------------------------------ def expand_iri ( self , iri : str ): \"\"\"Return the full IRI if `iri` is prefixed. Otherwise `iri` is returned.\"\"\" match = re . match ( _MATCH_PREFIXED_IRI , iri ) if match : prefix , name = match . groups () if prefix not in self . namespaces : raise NamespaceError ( f \"unknown namespace: { prefix } \" ) return f \" { self . namespaces [ prefix ] }{ name } \" return iri def prefix_iri ( self , iri : str , require_prefixed : bool = False ): \"\"\"Return prefixed IRI. This is the reverse of expand_iri(). If `require_prefixed` is true, a NamespaceError exception is raised if no prefix can be found. \"\"\" if not re . match ( _MATCH_PREFIXED_IRI , iri ): for prefix , namespace in self . namespaces . items (): if iri . startswith ( str ( namespace )): return f \" { prefix } : { iri [ len ( str ( namespace )):] } \" if require_prefixed : raise NamespaceError ( f \"No prefix defined for IRI: { iri } \" ) return iri def add_mapsTo ( # pylint: disable=invalid-name self , target : str , source : str , property_name : \"Optional[str]\" = None , cost : \"Optional[Union[float, Callable]]\" = None , target_cost : bool = True , ): \"\"\"Add 'mapsTo' relation to triplestore. Parameters: target: IRI of target ontological concept. source: Source IRI (or entity object). property_name: Name of property if `source` is an entity or an entity IRI. cost: User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the value of the mapped quantity as input and returning the cost as a float. target_cost: Whether the cost is assigned to mapping steps that have `target` as output. \"\"\" self . bind ( \"map\" , MAP ) if not property_name and not isinstance ( source , str ): raise TriplestoreError ( \"`property_name` is required when `target` is not a string.\" ) target = self . expand_iri ( target ) source = self . expand_iri ( infer_iri ( source )) if property_name : self . add (( f \" { source } # { property_name } \" , MAP . mapsTo , target )) else : self . add (( source , MAP . mapsTo , target )) if cost is not None : dest = target if target_cost else source self . _add_cost ( cost , dest ) def add_function ( self , func : \"Union[Callable, str]\" , expects : \"Union[str, Sequence, Mapping]\" = (), returns : \"Union[str, Sequence]\" = (), base_iri : \"Optional[str]\" = None , standard : str = \"fno\" , cost : \"Optional[Union[float, Callable]]\" = None , ): \"\"\"Inspect function and add triples describing it to the triplestore. Parameters: func: Function to describe. Should either be a callable or a string with a unique function IRI. expects: Sequence of IRIs to ontological concepts corresponding to positional arguments of `func`. May also be given as a dict mapping argument names to corresponding ontological IRIs. returns: IRI of return value. May also be given as a sequence of IRIs, if multiple values are returned. base_iri: Base of the IRI representing the function in the knowledge base. Defaults to the base IRI of the triplestore. standard: Name of ontology to use when describing the function. Defaults to the Function Ontology (FnO). cost: User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the same arguments as `func` returning the cost as a float. Returns: func_iri: IRI of the added function. \"\"\" if isinstance ( expects , str ): expects = [ expects ] if isinstance ( returns , str ): returns = [ returns ] method = getattr ( self , f \"_add_function_ { standard } \" ) func_iri = method ( func , expects , returns , base_iri ) self . function_repo [ func_iri ] = func if callable ( func ) else None if cost is not None : self . _add_cost ( cost , func_iri ) return func_iri def _add_cost ( self , cost : \"Union[float, Callable[[], float]]\" , dest_iri ): \"\"\"Help function that adds `cost` to destination IRI `dest_iri`. `cost` should be either a float or a Callable returning a float. If `cost` is a callable it is just referred to with a literal id and is not ontologically described as a function. The expected input arguments depends on the context, which is why this function is not part of the public API. Use the add_mapsTo() and add_function() methods instead. \"\"\" if self . has ( dest_iri , DM . hasCost ): warnings . warn ( f \"A cost is already assigned to IRI: { dest_iri } \" ) elif callable ( cost ): cost_id = f \"cost_function { function_id ( cost ) } \" self . add (( dest_iri , DM . hasCost , Literal ( cost_id ))) self . function_repo [ cost_id ] = cost else : self . add (( dest_iri , DM . hasCost , Literal ( cost ))) def _add_function_fno ( self , func , expects , returns , base_iri ): \"\"\"Implementing add_function() for FnO.\"\"\" self . bind ( \"fno\" , FNO ) self . bind ( \"dcterms\" , DCTERMS ) self . bind ( \"map\" , MAP ) if base_iri is None : base_iri = self . base_iri if self . base_iri else \":\" if callable ( func ): fid = function_id ( func ) # Function id func_iri = f \" { base_iri }{ func . __name__ } _ { fid } \" doc_string = inspect . getdoc ( func ) parlist = f \"_: { func . __name__ }{ fid } _parlist\" outlist = f \"_: { func . __name__ }{ fid } _outlist\" if isinstance ( expects , Sequence ): pars = list ( zip ( expects , inspect . signature ( func ) . parameters )) else : pars = [ ( expects [ par ], par ) for par in inspect . signature ( func ) . parameters ] elif isinstance ( func , str ): func_iri = func doc_string = \"\" parlist = f \"_: { func_iri } _parlist\" outlist = f \"_: { func_iri } _outlist\" pariris = expects if isinstance ( expects , Sequence ) else expects . values () parnames = [ split_iri ( pariri )[ 1 ] for pariri in pariris ] pars = list ( zip ( pariris , parnames )) else : raise TypeError ( \"`func` should be either a callable or an IRI\" ) self . add (( func_iri , RDF . type , FNO . Function )) self . add (( func_iri , FNO . expects , parlist )) self . add (( func_iri , FNO . returns , outlist )) if doc_string : self . add (( func_iri , DCTERMS . description , en ( doc_string ))) lst = parlist for i , ( iri , parname ) in enumerate ( pars ): lst_next = f \" { parlist }{ i + 2 } \" if i < len ( pars ) - 1 else RDF . nil par = f \" { func_iri } _parameter { i + 1 } _ { parname } \" self . add (( par , RDF . type , FNO . Parameter )) self . add (( par , RDFS . label , en ( parname ))) self . add (( par , MAP . mapsTo , iri )) self . add (( lst , RDF . first , par )) self . add (( lst , RDF . rest , lst_next )) lst = lst_next lst = outlist for i , iri in enumerate ( returns ): lst_next = f \" { outlist }{ i + 2 } \" if i < len ( returns ) - 1 else RDF . nil val = f \" { func_iri } _output { i + 1 } \" self . add (( val , RDF . type , FNO . Output )) self . add (( val , MAP . mapsTo , iri )) self . add (( lst , RDF . first , val )) self . add (( lst , RDF . rest , lst_next )) lst = lst_next return func_iri __init__ ( self , backend , base_iri = None , ** kwargs ) special \u00b6 Initialise triplestore using the backend with the given name. Parameters: Name Type Description Default backend str Name of the backend module. required base_iri 'Optional[str]' Base IRI used by the add_function() method when adding new triples. None kwargs Keyword arguments passed to the backend's init () method. {} Source code in tripper/triplestore.py def __init__ ( self , backend : str , base_iri : \"Optional[str]\" = None , ** kwargs ) -> None : \"\"\"Initialise triplestore using the backend with the given name. Parameters: backend: Name of the backend module. base_iri: Base IRI used by the add_function() method when adding new triples. kwargs: Keyword arguments passed to the backend's __init__() method. \"\"\" module = import_module ( backend if \".\" in backend else f \"tripper.backends. { backend } \" ) cls = getattr ( module , f \" { backend . title () } Strategy\" ) self . base_iri = base_iri self . namespaces : \"Dict[str, Namespace]\" = {} self . closed = False self . backend_name = backend self . backend = cls ( base_iri = base_iri , ** kwargs ) # Keep functions in the triplestore for convienence even though # they usually do not belong to the triplestore per se. self . function_repo : \"Dict[str, Union[float, Callable[[], float], None]]\" = {} for prefix , namespace in self . default_namespaces . items (): self . bind ( prefix , namespace ) add ( self , triple ) \u00b6 Add triple to triplestore. Source code in tripper/triplestore.py def add ( self , triple : \"Triple\" ): \"\"\"Add `triple` to triplestore.\"\"\" self . add_triples ([ triple ]) add_function ( self , func , expects = (), returns = (), base_iri = None , standard = 'fno' , cost = None ) \u00b6 Inspect function and add triples describing it to the triplestore. Parameters: Name Type Description Default func 'Union[Callable, str]' Function to describe. Should either be a callable or a string with a unique function IRI. required expects 'Union[str, Sequence, Mapping]' Sequence of IRIs to ontological concepts corresponding to positional arguments of func . May also be given as a dict mapping argument names to corresponding ontological IRIs. () returns 'Union[str, Sequence]' IRI of return value. May also be given as a sequence of IRIs, if multiple values are returned. () base_iri 'Optional[str]' Base of the IRI representing the function in the knowledge base. Defaults to the base IRI of the triplestore. None standard str Name of ontology to use when describing the function. Defaults to the Function Ontology (FnO). 'fno' cost 'Optional[Union[float, Callable]]' User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the same arguments as func returning the cost as a float. None Returns: Type Description func_iri IRI of the added function. Source code in tripper/triplestore.py def add_function ( self , func : \"Union[Callable, str]\" , expects : \"Union[str, Sequence, Mapping]\" = (), returns : \"Union[str, Sequence]\" = (), base_iri : \"Optional[str]\" = None , standard : str = \"fno\" , cost : \"Optional[Union[float, Callable]]\" = None , ): \"\"\"Inspect function and add triples describing it to the triplestore. Parameters: func: Function to describe. Should either be a callable or a string with a unique function IRI. expects: Sequence of IRIs to ontological concepts corresponding to positional arguments of `func`. May also be given as a dict mapping argument names to corresponding ontological IRIs. returns: IRI of return value. May also be given as a sequence of IRIs, if multiple values are returned. base_iri: Base of the IRI representing the function in the knowledge base. Defaults to the base IRI of the triplestore. standard: Name of ontology to use when describing the function. Defaults to the Function Ontology (FnO). cost: User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the same arguments as `func` returning the cost as a float. Returns: func_iri: IRI of the added function. \"\"\" if isinstance ( expects , str ): expects = [ expects ] if isinstance ( returns , str ): returns = [ returns ] method = getattr ( self , f \"_add_function_ { standard } \" ) func_iri = method ( func , expects , returns , base_iri ) self . function_repo [ func_iri ] = func if callable ( func ) else None if cost is not None : self . _add_cost ( cost , func_iri ) return func_iri add_mapsTo ( self , target , source , property_name = None , cost = None , target_cost = True ) \u00b6 Add 'mapsTo' relation to triplestore. Parameters: Name Type Description Default target str IRI of target ontological concept. required source str Source IRI (or entity object). required property_name 'Optional[str]' Name of property if source is an entity or an entity IRI. None cost 'Optional[Union[float, Callable]]' User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the value of the mapped quantity as input and returning the cost as a float. None target_cost bool Whether the cost is assigned to mapping steps that have target as output. True Source code in tripper/triplestore.py def add_mapsTo ( # pylint: disable=invalid-name self , target : str , source : str , property_name : \"Optional[str]\" = None , cost : \"Optional[Union[float, Callable]]\" = None , target_cost : bool = True , ): \"\"\"Add 'mapsTo' relation to triplestore. Parameters: target: IRI of target ontological concept. source: Source IRI (or entity object). property_name: Name of property if `source` is an entity or an entity IRI. cost: User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the value of the mapped quantity as input and returning the cost as a float. target_cost: Whether the cost is assigned to mapping steps that have `target` as output. \"\"\" self . bind ( \"map\" , MAP ) if not property_name and not isinstance ( source , str ): raise TriplestoreError ( \"`property_name` is required when `target` is not a string.\" ) target = self . expand_iri ( target ) source = self . expand_iri ( infer_iri ( source )) if property_name : self . add (( f \" { source } # { property_name } \" , MAP . mapsTo , target )) else : self . add (( source , MAP . mapsTo , target )) if cost is not None : dest = target if target_cost else source self . _add_cost ( cost , dest ) add_triples ( self , triples ) \u00b6 Add a sequence of triples. Parameters: Name Type Description Default triples 'Sequence[Triple]' A sequence of (s, p, o) tuples to add to the triplestore. required Source code in tripper/triplestore.py def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples. Arguments: triples: A sequence of `(s, p, o)` tuples to add to the triplestore. \"\"\" self . backend . add_triples ( triples ) bind ( self , prefix , namespace , ** kwargs ) \u00b6 Bind prefix to namespace and return the new Namespace object. The new Namespace is created with namespace as IRI. Keyword arguments are passed to the Namespace() constructor. If namespace is None, the corresponding prefix is removed. Source code in tripper/triplestore.py def bind ( self , prefix : str , namespace : \"Union[str, Namespace]\" , ** kwargs ): \"\"\"Bind prefix to namespace and return the new Namespace object. The new Namespace is created with `namespace` as IRI. Keyword arguments are passed to the Namespace() constructor. If `namespace` is None, the corresponding prefix is removed. \"\"\" if hasattr ( self . backend , \"bind\" ): self . backend . bind ( prefix , namespace ) if namespace is None : del self . namespaces [ prefix ] return None self . namespaces [ prefix ] = ( namespace if isinstance ( namespace , Namespace ) else Namespace ( namespace , ** kwargs ) ) return self . namespaces [ prefix ] close ( self ) \u00b6 Calls the backend close() method if it is implemented. Otherwise, this method has no effect. Source code in tripper/triplestore.py def close ( self ): \"\"\"Calls the backend close() method if it is implemented. Otherwise, this method has no effect. \"\"\" # It should be ok to call close() regardless of whether the backend # implements this method or not. Hence, don't call _check_method(). if not self . closed and hasattr ( self . backend , \"close\" ): self . backend . close () self . closed = True expand_iri ( self , iri ) \u00b6 Return the full IRI if iri is prefixed. Otherwise iri is returned. Source code in tripper/triplestore.py def expand_iri ( self , iri : str ): \"\"\"Return the full IRI if `iri` is prefixed. Otherwise `iri` is returned.\"\"\" match = re . match ( _MATCH_PREFIXED_IRI , iri ) if match : prefix , name = match . groups () if prefix not in self . namespaces : raise NamespaceError ( f \"unknown namespace: { prefix } \" ) return f \" { self . namespaces [ prefix ] }{ name } \" return iri has ( self , subject = None , predicate = None , object = None ) \u00b6 Returns true if the triplestore has any triple matching the give subject, predicate and/or object. Source code in tripper/triplestore.py def has ( self , subject = None , predicate = None , object = None ): # pylint: disable=redefined-builtin \"\"\"Returns true if the triplestore has any triple matching the give subject, predicate and/or object.\"\"\" triple = self . triples (( subject , predicate , object )) try : next ( triple ) except StopIteration : return False return True objects ( self , subject = None , predicate = None ) \u00b6 Returns a generator of objects for given subject and predicate. Source code in tripper/triplestore.py def objects ( self , subject = None , predicate = None ): \"\"\"Returns a generator of objects for given subject and predicate.\"\"\" for _ , _ , o in self . triples (( subject , predicate , None )): yield o parse ( self , source = None , format = None , ** kwargs ) \u00b6 Parse source and add the resulting triples to triplestore. Parameters: Name Type Description Default source File-like object or file name. None format Needed if format can not be inferred from source. None kwargs Keyword arguments passed to the backend. The rdflib backend supports e.g. location (absolute or relative URL) and data (string containing the data to be parsed) arguments. {} Source code in tripper/triplestore.py def parse ( self , source = None , format = None , ** kwargs # pylint: disable=redefined-builtin ): \"\"\"Parse source and add the resulting triples to triplestore. Parameters: source: File-like object or file name. format: Needed if format can not be inferred from source. kwargs: Keyword arguments passed to the backend. The rdflib backend supports e.g. `location` (absolute or relative URL) and `data` (string containing the data to be parsed) arguments. \"\"\" self . _check_method ( \"parse\" ) self . backend . parse ( source = source , format = format , ** kwargs ) if hasattr ( self . backend , \"namespaces\" ): for prefix , namespace in self . backend . namespaces () . items (): if prefix and prefix not in self . namespaces : self . namespaces [ prefix ] = Namespace ( namespace ) predicate_objects ( self , subject = None ) \u00b6 Returns a generator of (predicate, object) tuples for given subject. Source code in tripper/triplestore.py def predicate_objects ( self , subject = None ): \"\"\"Returns a generator of (predicate, object) tuples for given subject.\"\"\" for _ , p , o in self . triples (( subject , None , None )): yield p , o predicates ( self , subject = None , object = None ) \u00b6 Returns a generator of predicates for given subject and object. Source code in tripper/triplestore.py def predicates ( self , subject = None , object = None # pylint: disable=redefined-builtin ): \"\"\"Returns a generator of predicates for given subject and object.\"\"\" for _ , p , _ in self . triples (( subject , None , object )): yield p prefix_iri ( self , iri , require_prefixed = False ) \u00b6 Return prefixed IRI. This is the reverse of expand_iri(). If require_prefixed is true, a NamespaceError exception is raised if no prefix can be found. Source code in tripper/triplestore.py def prefix_iri ( self , iri : str , require_prefixed : bool = False ): \"\"\"Return prefixed IRI. This is the reverse of expand_iri(). If `require_prefixed` is true, a NamespaceError exception is raised if no prefix can be found. \"\"\" if not re . match ( _MATCH_PREFIXED_IRI , iri ): for prefix , namespace in self . namespaces . items (): if iri . startswith ( str ( namespace )): return f \" { prefix } : { iri [ len ( str ( namespace )):] } \" if require_prefixed : raise NamespaceError ( f \"No prefix defined for IRI: { iri } \" ) return iri query ( self , query_object , ** kwargs ) \u00b6 SPARQL query. Parameters: Name Type Description Default query_object String with the SPARQL query. required kwargs Keyword arguments passed to the backend query() method. {} Returns: Type Description 'List[Tuple[str, ...]]' List of tuples of IRIs for each matching row. Note This method is intended for SELECT queries. Use the update() method for INSERT and DELETE queries. Source code in tripper/triplestore.py def query ( self , query_object , ** kwargs ) -> \"List[Tuple[str, ...]]\" : \"\"\"SPARQL query. Parameters: query_object: String with the SPARQL query. kwargs: Keyword arguments passed to the backend query() method. Returns: List of tuples of IRIs for each matching row. Note: This method is intended for SELECT queries. Use the update() method for INSERT and DELETE queries. \"\"\" self . _check_method ( \"query\" ) return self . backend . query ( query_object = query_object , ** kwargs ) remove ( self , triple ) \u00b6 Remove all matching triples from the backend. Source code in tripper/triplestore.py def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" self . backend . remove ( triple ) serialize ( self , destination = None , format = 'turtle' , ** kwargs ) \u00b6 Serialise triplestore. Parameters: Name Type Description Default destination File name or object to write to. If None, the serialisation is returned. None format Format to serialise as. Supported formats, depends on the backend. 'turtle' kwargs Passed to the backend serialize() method. {} Returns: Type Description 'Union[None, str]' Serialized string if destination is None. Source code in tripper/triplestore.py def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise triplestore. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the backend serialize() method. Returns: Serialized string if `destination` is None. \"\"\" self . _check_method ( \"serialize\" ) return self . backend . serialize ( destination = destination , format = format , ** kwargs ) set ( self , triple ) \u00b6 Convenience method to update the value of object. Removes any existing triples for subject and predicate before adding the given triple . Source code in tripper/triplestore.py def set ( self , triple ): \"\"\"Convenience method to update the value of object. Removes any existing triples for subject and predicate before adding the given `triple`. \"\"\" s , p , _ = triple self . remove (( s , p , None )) self . add ( triple ) subject_objects ( self , predicate = None ) \u00b6 Returns a generator of (subject, object) tuples for given predicate. Source code in tripper/triplestore.py def subject_objects ( self , predicate = None ): \"\"\"Returns a generator of (subject, object) tuples for given predicate.\"\"\" for s , _ , o in self . triples (( None , predicate , None )): yield s , o subject_predicates ( self , object = None ) \u00b6 Returns a generator of (subject, predicate) tuples for given object. Source code in tripper/triplestore.py def subject_predicates ( self , object = None ): # pylint: disable=redefined-builtin \"\"\"Returns a generator of (subject, predicate) tuples for given object.\"\"\" for s , p , _ in self . triples (( None , None , object )): yield s , p subjects ( self , predicate = None , object = None ) \u00b6 Returns a generator of subjects for given predicate and object. Source code in tripper/triplestore.py def subjects ( self , predicate = None , object = None # pylint: disable=redefined-builtin ): \"\"\"Returns a generator of subjects for given predicate and object.\"\"\" for s , _ , _ in self . triples (( None , predicate , object )): yield s triples ( self , triple ) \u00b6 Returns a generator over matching triples. Parameters: Name Type Description Default triple 'Triple' A (s, p, o) tuple where s , p and o should either be None (matching anything) or an exact IRI to match. required Source code in tripper/triplestore.py def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples. Arguments: triple: A `(s, p, o)` tuple where `s`, `p` and `o` should either be None (matching anything) or an exact IRI to match. \"\"\" return self . backend . triples ( triple ) update ( self , update_object , ** kwargs ) \u00b6 Update triplestore with SPARQL. Parameters: Name Type Description Default update_object String with the SPARQL query. required kwargs Keyword arguments passed to the backend update() method. {} Note This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. Source code in tripper/triplestore.py def update ( self , update_object , ** kwargs ) -> None : \"\"\"Update triplestore with SPARQL. Parameters: update_object: String with the SPARQL query. kwargs: Keyword arguments passed to the backend update() method. Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" self . _check_method ( \"update\" ) return self . backend . update ( update_object = update_object , ** kwargs ) value ( self , subject = None , predicate = None , object = None , default = None , any = False ) \u00b6 Return the value for a pair of two criteria. Useful if one knows that there may only be one value. Parameters: Name Type Description Default subject, predicate, object Triple to match. required default Value to return if no matches are found. None any If true, return any matching value, otherwise raise UniquenessError. False Source code in tripper/triplestore.py def value ( # pylint: disable=redefined-builtin self , subject = None , predicate = None , object = None , default = None , any = False ): \"\"\"Return the value for a pair of two criteria. Useful if one knows that there may only be one value. Parameters: subject, predicate, object: Triple to match. default: Value to return if no matches are found. any: If true, return any matching value, otherwise raise UniquenessError. \"\"\" triple = self . triples (( subject , predicate , object )) try : value = next ( triple ) except StopIteration : return default if any : return value try : next ( triple ) except StopIteration : return value else : raise UniquenessError ( \"More than one match\" )","title":"triplestore"},{"location":"api_reference/triplestore/#triplestore","text":"A module encapsulating different triplestores using the strategy design pattern. See https://raw.githubusercontent.com/EMMC-ASBL/tripper/master/README.md for an introduction. This module has no dependencies outside the standard library, but the triplestore backends may have. For developers: The usage of s , p , and o represent the different parts of an RDF Triple: subject, predicate, and object.","title":"triplestore"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore","text":"Provides a common frontend to a range of triplestore backends. Source code in tripper/triplestore.py class Triplestore : \"\"\"Provides a common frontend to a range of triplestore backends.\"\"\" default_namespaces = { \"xml\" : XML , \"rdf\" : RDF , \"rdfs\" : RDFS , \"xsd\" : XSD , \"owl\" : OWL , # \"skos\": SKOS, # \"dc\": DC, # \"dcterms\": DCTERMS, # \"foaf\": FOAF, # \"doap\": DOAP, # \"fno\": FNO, # \"emmo\": EMMO, # \"map\": MAP, # \"dm\": DM, } def __init__ ( self , backend : str , base_iri : \"Optional[str]\" = None , ** kwargs ) -> None : \"\"\"Initialise triplestore using the backend with the given name. Parameters: backend: Name of the backend module. base_iri: Base IRI used by the add_function() method when adding new triples. kwargs: Keyword arguments passed to the backend's __init__() method. \"\"\" module = import_module ( backend if \".\" in backend else f \"tripper.backends. { backend } \" ) cls = getattr ( module , f \" { backend . title () } Strategy\" ) self . base_iri = base_iri self . namespaces : \"Dict[str, Namespace]\" = {} self . closed = False self . backend_name = backend self . backend = cls ( base_iri = base_iri , ** kwargs ) # Keep functions in the triplestore for convienence even though # they usually do not belong to the triplestore per se. self . function_repo : \"Dict[str, Union[float, Callable[[], float], None]]\" = {} for prefix , namespace in self . default_namespaces . items (): self . bind ( prefix , namespace ) # Methods implemented by backend # ------------------------------ def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples. Arguments: triple: A `(s, p, o)` tuple where `s`, `p` and `o` should either be None (matching anything) or an exact IRI to match. \"\"\" return self . backend . triples ( triple ) def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples. Arguments: triples: A sequence of `(s, p, o)` tuples to add to the triplestore. \"\"\" self . backend . add_triples ( triples ) def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" self . backend . remove ( triple ) # Methods optionally implemented by backend # ----------------------------------------- def close ( self ): \"\"\"Calls the backend close() method if it is implemented. Otherwise, this method has no effect. \"\"\" # It should be ok to call close() regardless of whether the backend # implements this method or not. Hence, don't call _check_method(). if not self . closed and hasattr ( self . backend , \"close\" ): self . backend . close () self . closed = True def parse ( self , source = None , format = None , ** kwargs # pylint: disable=redefined-builtin ): \"\"\"Parse source and add the resulting triples to triplestore. Parameters: source: File-like object or file name. format: Needed if format can not be inferred from source. kwargs: Keyword arguments passed to the backend. The rdflib backend supports e.g. `location` (absolute or relative URL) and `data` (string containing the data to be parsed) arguments. \"\"\" self . _check_method ( \"parse\" ) self . backend . parse ( source = source , format = format , ** kwargs ) if hasattr ( self . backend , \"namespaces\" ): for prefix , namespace in self . backend . namespaces () . items (): if prefix and prefix not in self . namespaces : self . namespaces [ prefix ] = Namespace ( namespace ) def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise triplestore. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the backend serialize() method. Returns: Serialized string if `destination` is None. \"\"\" self . _check_method ( \"serialize\" ) return self . backend . serialize ( destination = destination , format = format , ** kwargs ) def query ( self , query_object , ** kwargs ) -> \"List[Tuple[str, ...]]\" : \"\"\"SPARQL query. Parameters: query_object: String with the SPARQL query. kwargs: Keyword arguments passed to the backend query() method. Returns: List of tuples of IRIs for each matching row. Note: This method is intended for SELECT queries. Use the update() method for INSERT and DELETE queries. \"\"\" self . _check_method ( \"query\" ) return self . backend . query ( query_object = query_object , ** kwargs ) def update ( self , update_object , ** kwargs ) -> None : \"\"\"Update triplestore with SPARQL. Parameters: update_object: String with the SPARQL query. kwargs: Keyword arguments passed to the backend update() method. Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" self . _check_method ( \"update\" ) return self . backend . update ( update_object = update_object , ** kwargs ) def bind ( self , prefix : str , namespace : \"Union[str, Namespace]\" , ** kwargs ): \"\"\"Bind prefix to namespace and return the new Namespace object. The new Namespace is created with `namespace` as IRI. Keyword arguments are passed to the Namespace() constructor. If `namespace` is None, the corresponding prefix is removed. \"\"\" if hasattr ( self . backend , \"bind\" ): self . backend . bind ( prefix , namespace ) if namespace is None : del self . namespaces [ prefix ] return None self . namespaces [ prefix ] = ( namespace if isinstance ( namespace , Namespace ) else Namespace ( namespace , ** kwargs ) ) return self . namespaces [ prefix ] # Convenient methods # ------------------ # These methods are modelled after rdflib and provide some convinient # interfaces to the triples(), add_triples() and remove() methods # implemented by all backends. def _check_method ( self , name ): \"\"\"Check that backend implements the given method.\"\"\" if not hasattr ( self . backend , name ): raise NotImplementedError ( f \"Triplestore backend { self . backend_name !r} do not implement a \" f '\" { name } ()\" method.' ) def add ( self , triple : \"Triple\" ): \"\"\"Add `triple` to triplestore.\"\"\" self . add_triples ([ triple ]) def value ( # pylint: disable=redefined-builtin self , subject = None , predicate = None , object = None , default = None , any = False ): \"\"\"Return the value for a pair of two criteria. Useful if one knows that there may only be one value. Parameters: subject, predicate, object: Triple to match. default: Value to return if no matches are found. any: If true, return any matching value, otherwise raise UniquenessError. \"\"\" triple = self . triples (( subject , predicate , object )) try : value = next ( triple ) except StopIteration : return default if any : return value try : next ( triple ) except StopIteration : return value else : raise UniquenessError ( \"More than one match\" ) def subjects ( self , predicate = None , object = None # pylint: disable=redefined-builtin ): \"\"\"Returns a generator of subjects for given predicate and object.\"\"\" for s , _ , _ in self . triples (( None , predicate , object )): yield s def predicates ( self , subject = None , object = None # pylint: disable=redefined-builtin ): \"\"\"Returns a generator of predicates for given subject and object.\"\"\" for _ , p , _ in self . triples (( subject , None , object )): yield p def objects ( self , subject = None , predicate = None ): \"\"\"Returns a generator of objects for given subject and predicate.\"\"\" for _ , _ , o in self . triples (( subject , predicate , None )): yield o def subject_predicates ( self , object = None ): # pylint: disable=redefined-builtin \"\"\"Returns a generator of (subject, predicate) tuples for given object.\"\"\" for s , p , _ in self . triples (( None , None , object )): yield s , p def subject_objects ( self , predicate = None ): \"\"\"Returns a generator of (subject, object) tuples for given predicate.\"\"\" for s , _ , o in self . triples (( None , predicate , None )): yield s , o def predicate_objects ( self , subject = None ): \"\"\"Returns a generator of (predicate, object) tuples for given subject.\"\"\" for _ , p , o in self . triples (( subject , None , None )): yield p , o def set ( self , triple ): \"\"\"Convenience method to update the value of object. Removes any existing triples for subject and predicate before adding the given `triple`. \"\"\" s , p , _ = triple self . remove (( s , p , None )) self . add ( triple ) def has ( self , subject = None , predicate = None , object = None ): # pylint: disable=redefined-builtin \"\"\"Returns true if the triplestore has any triple matching the give subject, predicate and/or object.\"\"\" triple = self . triples (( subject , predicate , object )) try : next ( triple ) except StopIteration : return False return True # Methods providing additional functionality # ------------------------------------------ def expand_iri ( self , iri : str ): \"\"\"Return the full IRI if `iri` is prefixed. Otherwise `iri` is returned.\"\"\" match = re . match ( _MATCH_PREFIXED_IRI , iri ) if match : prefix , name = match . groups () if prefix not in self . namespaces : raise NamespaceError ( f \"unknown namespace: { prefix } \" ) return f \" { self . namespaces [ prefix ] }{ name } \" return iri def prefix_iri ( self , iri : str , require_prefixed : bool = False ): \"\"\"Return prefixed IRI. This is the reverse of expand_iri(). If `require_prefixed` is true, a NamespaceError exception is raised if no prefix can be found. \"\"\" if not re . match ( _MATCH_PREFIXED_IRI , iri ): for prefix , namespace in self . namespaces . items (): if iri . startswith ( str ( namespace )): return f \" { prefix } : { iri [ len ( str ( namespace )):] } \" if require_prefixed : raise NamespaceError ( f \"No prefix defined for IRI: { iri } \" ) return iri def add_mapsTo ( # pylint: disable=invalid-name self , target : str , source : str , property_name : \"Optional[str]\" = None , cost : \"Optional[Union[float, Callable]]\" = None , target_cost : bool = True , ): \"\"\"Add 'mapsTo' relation to triplestore. Parameters: target: IRI of target ontological concept. source: Source IRI (or entity object). property_name: Name of property if `source` is an entity or an entity IRI. cost: User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the value of the mapped quantity as input and returning the cost as a float. target_cost: Whether the cost is assigned to mapping steps that have `target` as output. \"\"\" self . bind ( \"map\" , MAP ) if not property_name and not isinstance ( source , str ): raise TriplestoreError ( \"`property_name` is required when `target` is not a string.\" ) target = self . expand_iri ( target ) source = self . expand_iri ( infer_iri ( source )) if property_name : self . add (( f \" { source } # { property_name } \" , MAP . mapsTo , target )) else : self . add (( source , MAP . mapsTo , target )) if cost is not None : dest = target if target_cost else source self . _add_cost ( cost , dest ) def add_function ( self , func : \"Union[Callable, str]\" , expects : \"Union[str, Sequence, Mapping]\" = (), returns : \"Union[str, Sequence]\" = (), base_iri : \"Optional[str]\" = None , standard : str = \"fno\" , cost : \"Optional[Union[float, Callable]]\" = None , ): \"\"\"Inspect function and add triples describing it to the triplestore. Parameters: func: Function to describe. Should either be a callable or a string with a unique function IRI. expects: Sequence of IRIs to ontological concepts corresponding to positional arguments of `func`. May also be given as a dict mapping argument names to corresponding ontological IRIs. returns: IRI of return value. May also be given as a sequence of IRIs, if multiple values are returned. base_iri: Base of the IRI representing the function in the knowledge base. Defaults to the base IRI of the triplestore. standard: Name of ontology to use when describing the function. Defaults to the Function Ontology (FnO). cost: User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the same arguments as `func` returning the cost as a float. Returns: func_iri: IRI of the added function. \"\"\" if isinstance ( expects , str ): expects = [ expects ] if isinstance ( returns , str ): returns = [ returns ] method = getattr ( self , f \"_add_function_ { standard } \" ) func_iri = method ( func , expects , returns , base_iri ) self . function_repo [ func_iri ] = func if callable ( func ) else None if cost is not None : self . _add_cost ( cost , func_iri ) return func_iri def _add_cost ( self , cost : \"Union[float, Callable[[], float]]\" , dest_iri ): \"\"\"Help function that adds `cost` to destination IRI `dest_iri`. `cost` should be either a float or a Callable returning a float. If `cost` is a callable it is just referred to with a literal id and is not ontologically described as a function. The expected input arguments depends on the context, which is why this function is not part of the public API. Use the add_mapsTo() and add_function() methods instead. \"\"\" if self . has ( dest_iri , DM . hasCost ): warnings . warn ( f \"A cost is already assigned to IRI: { dest_iri } \" ) elif callable ( cost ): cost_id = f \"cost_function { function_id ( cost ) } \" self . add (( dest_iri , DM . hasCost , Literal ( cost_id ))) self . function_repo [ cost_id ] = cost else : self . add (( dest_iri , DM . hasCost , Literal ( cost ))) def _add_function_fno ( self , func , expects , returns , base_iri ): \"\"\"Implementing add_function() for FnO.\"\"\" self . bind ( \"fno\" , FNO ) self . bind ( \"dcterms\" , DCTERMS ) self . bind ( \"map\" , MAP ) if base_iri is None : base_iri = self . base_iri if self . base_iri else \":\" if callable ( func ): fid = function_id ( func ) # Function id func_iri = f \" { base_iri }{ func . __name__ } _ { fid } \" doc_string = inspect . getdoc ( func ) parlist = f \"_: { func . __name__ }{ fid } _parlist\" outlist = f \"_: { func . __name__ }{ fid } _outlist\" if isinstance ( expects , Sequence ): pars = list ( zip ( expects , inspect . signature ( func ) . parameters )) else : pars = [ ( expects [ par ], par ) for par in inspect . signature ( func ) . parameters ] elif isinstance ( func , str ): func_iri = func doc_string = \"\" parlist = f \"_: { func_iri } _parlist\" outlist = f \"_: { func_iri } _outlist\" pariris = expects if isinstance ( expects , Sequence ) else expects . values () parnames = [ split_iri ( pariri )[ 1 ] for pariri in pariris ] pars = list ( zip ( pariris , parnames )) else : raise TypeError ( \"`func` should be either a callable or an IRI\" ) self . add (( func_iri , RDF . type , FNO . Function )) self . add (( func_iri , FNO . expects , parlist )) self . add (( func_iri , FNO . returns , outlist )) if doc_string : self . add (( func_iri , DCTERMS . description , en ( doc_string ))) lst = parlist for i , ( iri , parname ) in enumerate ( pars ): lst_next = f \" { parlist }{ i + 2 } \" if i < len ( pars ) - 1 else RDF . nil par = f \" { func_iri } _parameter { i + 1 } _ { parname } \" self . add (( par , RDF . type , FNO . Parameter )) self . add (( par , RDFS . label , en ( parname ))) self . add (( par , MAP . mapsTo , iri )) self . add (( lst , RDF . first , par )) self . add (( lst , RDF . rest , lst_next )) lst = lst_next lst = outlist for i , iri in enumerate ( returns ): lst_next = f \" { outlist }{ i + 2 } \" if i < len ( returns ) - 1 else RDF . nil val = f \" { func_iri } _output { i + 1 } \" self . add (( val , RDF . type , FNO . Output )) self . add (( val , MAP . mapsTo , iri )) self . add (( lst , RDF . first , val )) self . add (( lst , RDF . rest , lst_next )) lst = lst_next return func_iri","title":"Triplestore"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.__init__","text":"Initialise triplestore using the backend with the given name. Parameters: Name Type Description Default backend str Name of the backend module. required base_iri 'Optional[str]' Base IRI used by the add_function() method when adding new triples. None kwargs Keyword arguments passed to the backend's init () method. {} Source code in tripper/triplestore.py def __init__ ( self , backend : str , base_iri : \"Optional[str]\" = None , ** kwargs ) -> None : \"\"\"Initialise triplestore using the backend with the given name. Parameters: backend: Name of the backend module. base_iri: Base IRI used by the add_function() method when adding new triples. kwargs: Keyword arguments passed to the backend's __init__() method. \"\"\" module = import_module ( backend if \".\" in backend else f \"tripper.backends. { backend } \" ) cls = getattr ( module , f \" { backend . title () } Strategy\" ) self . base_iri = base_iri self . namespaces : \"Dict[str, Namespace]\" = {} self . closed = False self . backend_name = backend self . backend = cls ( base_iri = base_iri , ** kwargs ) # Keep functions in the triplestore for convienence even though # they usually do not belong to the triplestore per se. self . function_repo : \"Dict[str, Union[float, Callable[[], float], None]]\" = {} for prefix , namespace in self . default_namespaces . items (): self . bind ( prefix , namespace )","title":"__init__()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.add","text":"Add triple to triplestore. Source code in tripper/triplestore.py def add ( self , triple : \"Triple\" ): \"\"\"Add `triple` to triplestore.\"\"\" self . add_triples ([ triple ])","title":"add()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.add_function","text":"Inspect function and add triples describing it to the triplestore. Parameters: Name Type Description Default func 'Union[Callable, str]' Function to describe. Should either be a callable or a string with a unique function IRI. required expects 'Union[str, Sequence, Mapping]' Sequence of IRIs to ontological concepts corresponding to positional arguments of func . May also be given as a dict mapping argument names to corresponding ontological IRIs. () returns 'Union[str, Sequence]' IRI of return value. May also be given as a sequence of IRIs, if multiple values are returned. () base_iri 'Optional[str]' Base of the IRI representing the function in the knowledge base. Defaults to the base IRI of the triplestore. None standard str Name of ontology to use when describing the function. Defaults to the Function Ontology (FnO). 'fno' cost 'Optional[Union[float, Callable]]' User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the same arguments as func returning the cost as a float. None Returns: Type Description func_iri IRI of the added function. Source code in tripper/triplestore.py def add_function ( self , func : \"Union[Callable, str]\" , expects : \"Union[str, Sequence, Mapping]\" = (), returns : \"Union[str, Sequence]\" = (), base_iri : \"Optional[str]\" = None , standard : str = \"fno\" , cost : \"Optional[Union[float, Callable]]\" = None , ): \"\"\"Inspect function and add triples describing it to the triplestore. Parameters: func: Function to describe. Should either be a callable or a string with a unique function IRI. expects: Sequence of IRIs to ontological concepts corresponding to positional arguments of `func`. May also be given as a dict mapping argument names to corresponding ontological IRIs. returns: IRI of return value. May also be given as a sequence of IRIs, if multiple values are returned. base_iri: Base of the IRI representing the function in the knowledge base. Defaults to the base IRI of the triplestore. standard: Name of ontology to use when describing the function. Defaults to the Function Ontology (FnO). cost: User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the same arguments as `func` returning the cost as a float. Returns: func_iri: IRI of the added function. \"\"\" if isinstance ( expects , str ): expects = [ expects ] if isinstance ( returns , str ): returns = [ returns ] method = getattr ( self , f \"_add_function_ { standard } \" ) func_iri = method ( func , expects , returns , base_iri ) self . function_repo [ func_iri ] = func if callable ( func ) else None if cost is not None : self . _add_cost ( cost , func_iri ) return func_iri","title":"add_function()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.add_mapsTo","text":"Add 'mapsTo' relation to triplestore. Parameters: Name Type Description Default target str IRI of target ontological concept. required source str Source IRI (or entity object). required property_name 'Optional[str]' Name of property if source is an entity or an entity IRI. None cost 'Optional[Union[float, Callable]]' User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the value of the mapped quantity as input and returning the cost as a float. None target_cost bool Whether the cost is assigned to mapping steps that have target as output. True Source code in tripper/triplestore.py def add_mapsTo ( # pylint: disable=invalid-name self , target : str , source : str , property_name : \"Optional[str]\" = None , cost : \"Optional[Union[float, Callable]]\" = None , target_cost : bool = True , ): \"\"\"Add 'mapsTo' relation to triplestore. Parameters: target: IRI of target ontological concept. source: Source IRI (or entity object). property_name: Name of property if `source` is an entity or an entity IRI. cost: User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the value of the mapped quantity as input and returning the cost as a float. target_cost: Whether the cost is assigned to mapping steps that have `target` as output. \"\"\" self . bind ( \"map\" , MAP ) if not property_name and not isinstance ( source , str ): raise TriplestoreError ( \"`property_name` is required when `target` is not a string.\" ) target = self . expand_iri ( target ) source = self . expand_iri ( infer_iri ( source )) if property_name : self . add (( f \" { source } # { property_name } \" , MAP . mapsTo , target )) else : self . add (( source , MAP . mapsTo , target )) if cost is not None : dest = target if target_cost else source self . _add_cost ( cost , dest )","title":"add_mapsTo()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.add_triples","text":"Add a sequence of triples. Parameters: Name Type Description Default triples 'Sequence[Triple]' A sequence of (s, p, o) tuples to add to the triplestore. required Source code in tripper/triplestore.py def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples. Arguments: triples: A sequence of `(s, p, o)` tuples to add to the triplestore. \"\"\" self . backend . add_triples ( triples )","title":"add_triples()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.bind","text":"Bind prefix to namespace and return the new Namespace object. The new Namespace is created with namespace as IRI. Keyword arguments are passed to the Namespace() constructor. If namespace is None, the corresponding prefix is removed. Source code in tripper/triplestore.py def bind ( self , prefix : str , namespace : \"Union[str, Namespace]\" , ** kwargs ): \"\"\"Bind prefix to namespace and return the new Namespace object. The new Namespace is created with `namespace` as IRI. Keyword arguments are passed to the Namespace() constructor. If `namespace` is None, the corresponding prefix is removed. \"\"\" if hasattr ( self . backend , \"bind\" ): self . backend . bind ( prefix , namespace ) if namespace is None : del self . namespaces [ prefix ] return None self . namespaces [ prefix ] = ( namespace if isinstance ( namespace , Namespace ) else Namespace ( namespace , ** kwargs ) ) return self . namespaces [ prefix ]","title":"bind()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.close","text":"Calls the backend close() method if it is implemented. Otherwise, this method has no effect. Source code in tripper/triplestore.py def close ( self ): \"\"\"Calls the backend close() method if it is implemented. Otherwise, this method has no effect. \"\"\" # It should be ok to call close() regardless of whether the backend # implements this method or not. Hence, don't call _check_method(). if not self . closed and hasattr ( self . backend , \"close\" ): self . backend . close () self . closed = True","title":"close()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.expand_iri","text":"Return the full IRI if iri is prefixed. Otherwise iri is returned. Source code in tripper/triplestore.py def expand_iri ( self , iri : str ): \"\"\"Return the full IRI if `iri` is prefixed. Otherwise `iri` is returned.\"\"\" match = re . match ( _MATCH_PREFIXED_IRI , iri ) if match : prefix , name = match . groups () if prefix not in self . namespaces : raise NamespaceError ( f \"unknown namespace: { prefix } \" ) return f \" { self . namespaces [ prefix ] }{ name } \" return iri","title":"expand_iri()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.has","text":"Returns true if the triplestore has any triple matching the give subject, predicate and/or object. Source code in tripper/triplestore.py def has ( self , subject = None , predicate = None , object = None ): # pylint: disable=redefined-builtin \"\"\"Returns true if the triplestore has any triple matching the give subject, predicate and/or object.\"\"\" triple = self . triples (( subject , predicate , object )) try : next ( triple ) except StopIteration : return False return True","title":"has()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.objects","text":"Returns a generator of objects for given subject and predicate. Source code in tripper/triplestore.py def objects ( self , subject = None , predicate = None ): \"\"\"Returns a generator of objects for given subject and predicate.\"\"\" for _ , _ , o in self . triples (( subject , predicate , None )): yield o","title":"objects()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.parse","text":"Parse source and add the resulting triples to triplestore. Parameters: Name Type Description Default source File-like object or file name. None format Needed if format can not be inferred from source. None kwargs Keyword arguments passed to the backend. The rdflib backend supports e.g. location (absolute or relative URL) and data (string containing the data to be parsed) arguments. {} Source code in tripper/triplestore.py def parse ( self , source = None , format = None , ** kwargs # pylint: disable=redefined-builtin ): \"\"\"Parse source and add the resulting triples to triplestore. Parameters: source: File-like object or file name. format: Needed if format can not be inferred from source. kwargs: Keyword arguments passed to the backend. The rdflib backend supports e.g. `location` (absolute or relative URL) and `data` (string containing the data to be parsed) arguments. \"\"\" self . _check_method ( \"parse\" ) self . backend . parse ( source = source , format = format , ** kwargs ) if hasattr ( self . backend , \"namespaces\" ): for prefix , namespace in self . backend . namespaces () . items (): if prefix and prefix not in self . namespaces : self . namespaces [ prefix ] = Namespace ( namespace )","title":"parse()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.predicate_objects","text":"Returns a generator of (predicate, object) tuples for given subject. Source code in tripper/triplestore.py def predicate_objects ( self , subject = None ): \"\"\"Returns a generator of (predicate, object) tuples for given subject.\"\"\" for _ , p , o in self . triples (( subject , None , None )): yield p , o","title":"predicate_objects()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.predicates","text":"Returns a generator of predicates for given subject and object. Source code in tripper/triplestore.py def predicates ( self , subject = None , object = None # pylint: disable=redefined-builtin ): \"\"\"Returns a generator of predicates for given subject and object.\"\"\" for _ , p , _ in self . triples (( subject , None , object )): yield p","title":"predicates()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.prefix_iri","text":"Return prefixed IRI. This is the reverse of expand_iri(). If require_prefixed is true, a NamespaceError exception is raised if no prefix can be found. Source code in tripper/triplestore.py def prefix_iri ( self , iri : str , require_prefixed : bool = False ): \"\"\"Return prefixed IRI. This is the reverse of expand_iri(). If `require_prefixed` is true, a NamespaceError exception is raised if no prefix can be found. \"\"\" if not re . match ( _MATCH_PREFIXED_IRI , iri ): for prefix , namespace in self . namespaces . items (): if iri . startswith ( str ( namespace )): return f \" { prefix } : { iri [ len ( str ( namespace )):] } \" if require_prefixed : raise NamespaceError ( f \"No prefix defined for IRI: { iri } \" ) return iri","title":"prefix_iri()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.query","text":"SPARQL query. Parameters: Name Type Description Default query_object String with the SPARQL query. required kwargs Keyword arguments passed to the backend query() method. {} Returns: Type Description 'List[Tuple[str, ...]]' List of tuples of IRIs for each matching row. Note This method is intended for SELECT queries. Use the update() method for INSERT and DELETE queries. Source code in tripper/triplestore.py def query ( self , query_object , ** kwargs ) -> \"List[Tuple[str, ...]]\" : \"\"\"SPARQL query. Parameters: query_object: String with the SPARQL query. kwargs: Keyword arguments passed to the backend query() method. Returns: List of tuples of IRIs for each matching row. Note: This method is intended for SELECT queries. Use the update() method for INSERT and DELETE queries. \"\"\" self . _check_method ( \"query\" ) return self . backend . query ( query_object = query_object , ** kwargs )","title":"query()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.remove","text":"Remove all matching triples from the backend. Source code in tripper/triplestore.py def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" self . backend . remove ( triple )","title":"remove()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.serialize","text":"Serialise triplestore. Parameters: Name Type Description Default destination File name or object to write to. If None, the serialisation is returned. None format Format to serialise as. Supported formats, depends on the backend. 'turtle' kwargs Passed to the backend serialize() method. {} Returns: Type Description 'Union[None, str]' Serialized string if destination is None. Source code in tripper/triplestore.py def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise triplestore. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the backend serialize() method. Returns: Serialized string if `destination` is None. \"\"\" self . _check_method ( \"serialize\" ) return self . backend . serialize ( destination = destination , format = format , ** kwargs )","title":"serialize()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.set","text":"Convenience method to update the value of object. Removes any existing triples for subject and predicate before adding the given triple . Source code in tripper/triplestore.py def set ( self , triple ): \"\"\"Convenience method to update the value of object. Removes any existing triples for subject and predicate before adding the given `triple`. \"\"\" s , p , _ = triple self . remove (( s , p , None )) self . add ( triple )","title":"set()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.subject_objects","text":"Returns a generator of (subject, object) tuples for given predicate. Source code in tripper/triplestore.py def subject_objects ( self , predicate = None ): \"\"\"Returns a generator of (subject, object) tuples for given predicate.\"\"\" for s , _ , o in self . triples (( None , predicate , None )): yield s , o","title":"subject_objects()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.subject_predicates","text":"Returns a generator of (subject, predicate) tuples for given object. Source code in tripper/triplestore.py def subject_predicates ( self , object = None ): # pylint: disable=redefined-builtin \"\"\"Returns a generator of (subject, predicate) tuples for given object.\"\"\" for s , p , _ in self . triples (( None , None , object )): yield s , p","title":"subject_predicates()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.subjects","text":"Returns a generator of subjects for given predicate and object. Source code in tripper/triplestore.py def subjects ( self , predicate = None , object = None # pylint: disable=redefined-builtin ): \"\"\"Returns a generator of subjects for given predicate and object.\"\"\" for s , _ , _ in self . triples (( None , predicate , object )): yield s","title":"subjects()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.triples","text":"Returns a generator over matching triples. Parameters: Name Type Description Default triple 'Triple' A (s, p, o) tuple where s , p and o should either be None (matching anything) or an exact IRI to match. required Source code in tripper/triplestore.py def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples. Arguments: triple: A `(s, p, o)` tuple where `s`, `p` and `o` should either be None (matching anything) or an exact IRI to match. \"\"\" return self . backend . triples ( triple )","title":"triples()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.update","text":"Update triplestore with SPARQL. Parameters: Name Type Description Default update_object String with the SPARQL query. required kwargs Keyword arguments passed to the backend update() method. {} Note This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. Source code in tripper/triplestore.py def update ( self , update_object , ** kwargs ) -> None : \"\"\"Update triplestore with SPARQL. Parameters: update_object: String with the SPARQL query. kwargs: Keyword arguments passed to the backend update() method. Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" self . _check_method ( \"update\" ) return self . backend . update ( update_object = update_object , ** kwargs )","title":"update()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.value","text":"Return the value for a pair of two criteria. Useful if one knows that there may only be one value. Parameters: Name Type Description Default subject, predicate, object Triple to match. required default Value to return if no matches are found. None any If true, return any matching value, otherwise raise UniquenessError. False Source code in tripper/triplestore.py def value ( # pylint: disable=redefined-builtin self , subject = None , predicate = None , object = None , default = None , any = False ): \"\"\"Return the value for a pair of two criteria. Useful if one knows that there may only be one value. Parameters: subject, predicate, object: Triple to match. default: Value to return if no matches are found. any: If true, return any matching value, otherwise raise UniquenessError. \"\"\" triple = self . triples (( subject , predicate , object )) try : value = next ( triple ) except StopIteration : return default if any : return value try : next ( triple ) except StopIteration : return value else : raise UniquenessError ( \"More than one match\" )","title":"value()"},{"location":"api_reference/utils/","text":"utils \u00b6 Utility functions. en ( value ) \u00b6 Convenience function that returns value as a plain english literal. Equivalent to Literal(value, lang=\"en\") . Source code in tripper/utils.py def en ( value ) -> \"Literal\" : # pylint: disable=invalid-name \"\"\"Convenience function that returns value as a plain english literal. Equivalent to ``Literal(value, lang=\"en\")``. \"\"\" return Literal ( value , lang = \"en\" ) function_id ( func , length = 4 ) \u00b6 Return a checksum for function func . The returned object is a string of hexadecimal digits. length is the number of bytes in the returned checksum. Since the current implementation is based on the shake_128 algorithm, it make no sense to set length larger than 32 bytes. Source code in tripper/utils.py def function_id ( func : \"Callable\" , length : int = 4 ) -> str : \"\"\"Return a checksum for function `func`. The returned object is a string of hexadecimal digits. `length` is the number of bytes in the returned checksum. Since the current implementation is based on the shake_128 algorithm, it make no sense to set `length` larger than 32 bytes. \"\"\" return hashlib . shake_128 ( # pylint: disable=too-many-function-args inspect . getsource ( func ) . encode () ) . hexdigest ( length ) infer_iri ( obj ) \u00b6 Return IRI of the individual that stands for object obj . Source code in tripper/utils.py def infer_iri ( obj ): \"\"\"Return IRI of the individual that stands for object `obj`.\"\"\" if isinstance ( obj , str ): return obj if hasattr ( obj , \"uri\" ) and obj . uri : # dlite.Metadata or dataclass (or instance with uri) return obj . uri if hasattr ( obj , \"uuid\" ) and obj . uuid : # dlite.Instance or dataclass return obj . uuid if hasattr ( obj , \"schema\" ) and callable ( obj . schema ): # pydantic.BaseModel schema = obj . schema () properties = schema [ \"properties\" ] if \"uri\" in properties and properties [ \"uri\" ]: return properties [ \"uri\" ] if \"uuid\" in properties and properties [ \"uuid\" ]: return properties [ \"uuid\" ] raise TypeError ( \"cannot infer IRI from object {obj!r} \" ) parse_literal ( literal ) \u00b6 Parse literal and return it as an instance of Literal. The main difference between this function and the Literal constructor, is that this function correctly interprets n3-encoded literal strings. Source code in tripper/utils.py def parse_literal ( literal : \"Any\" ) -> \"Literal\" : \"\"\"Parse `literal` and return it as an instance of Literal. The main difference between this function and the Literal constructor, is that this function correctly interprets n3-encoded literal strings. \"\"\" # pylint: disable=invalid-name,too-many-branches lang , datatype = None , None if isinstance ( literal , Literal ): return literal if not isinstance ( literal , str ): if isinstance ( literal , tuple ( Literal . datatypes )): return Literal ( literal , lang = lang , datatype = Literal . datatypes . get ( type ( literal )) ) TypeError ( f \"unsupported literal type: { type ( literal ) } \" ) match = re . match ( r '^\\s*(\"\"\"(.*)\"\"\"|\"(.*)\")\\s*$' , literal , flags = re . DOTALL ) if match : _ , v1 , v2 = match . groups () value , datatype = v1 if v1 else v2 , XSD . string else : match = re . match ( r '^\\s*(\"\"\"(.*)\"\"\"|\"(.*)\")\\^\\^(.*)\\s*$' , literal , flags = re . DOTALL ) if match : _ , v1 , v2 , datatype = match . groups () value = v1 if v1 else v2 else : match = re . match ( r '^\\s*(\"\"\"(.*)\"\"\"|\"(.*)\")@(.*)\\s*$' , literal , flags = re . DOTALL ) if match : _ , v1 , v2 , lang = match . groups () value = v1 if v1 else v2 else : value = literal if lang or datatype : if datatype : types = { v : k for k , v in Literal . datatypes . items ()} type_ = types [ datatype ] try : value = type_ ( value ) except TypeError : pass return Literal ( value , lang = lang , datatype = datatype ) for type_ , datatype in Literal . datatypes . items (): if type_ is not bool : try : return Literal ( type_ ( literal ), lang = lang , datatype = datatype ) except ( ValueError , TypeError ): pass raise ValueError ( \"cannot parse {literal=}\" ) split_iri ( iri ) \u00b6 Split iri into namespace and name parts and return them as a tuple. Parameters: Name Type Description Default iri str The IRI to be split. required Returns: Type Description Tuple[str, str] A split IRI. Split into namespace and name. Source code in tripper/utils.py def split_iri ( iri : str ) -> \"Tuple[str, str]\" : \"\"\"Split iri into namespace and name parts and return them as a tuple. Parameters: iri: The IRI to be split. Returns: A split IRI. Split into namespace and name. \"\"\" if \"#\" in iri : namespace , name = iri . rsplit ( \"#\" , 1 ) return f \" { namespace } #\" , name if \"/\" in iri : namespace , name = iri . rsplit ( \"/\" , 1 ) return f \" { namespace } /\" , name raise ValueError ( \"all IRIs should contain a slash\" )","title":"utils"},{"location":"api_reference/utils/#utils","text":"Utility functions.","title":"utils"},{"location":"api_reference/utils/#tripper.utils.en","text":"Convenience function that returns value as a plain english literal. Equivalent to Literal(value, lang=\"en\") . Source code in tripper/utils.py def en ( value ) -> \"Literal\" : # pylint: disable=invalid-name \"\"\"Convenience function that returns value as a plain english literal. Equivalent to ``Literal(value, lang=\"en\")``. \"\"\" return Literal ( value , lang = \"en\" )","title":"en()"},{"location":"api_reference/utils/#tripper.utils.function_id","text":"Return a checksum for function func . The returned object is a string of hexadecimal digits. length is the number of bytes in the returned checksum. Since the current implementation is based on the shake_128 algorithm, it make no sense to set length larger than 32 bytes. Source code in tripper/utils.py def function_id ( func : \"Callable\" , length : int = 4 ) -> str : \"\"\"Return a checksum for function `func`. The returned object is a string of hexadecimal digits. `length` is the number of bytes in the returned checksum. Since the current implementation is based on the shake_128 algorithm, it make no sense to set `length` larger than 32 bytes. \"\"\" return hashlib . shake_128 ( # pylint: disable=too-many-function-args inspect . getsource ( func ) . encode () ) . hexdigest ( length )","title":"function_id()"},{"location":"api_reference/utils/#tripper.utils.infer_iri","text":"Return IRI of the individual that stands for object obj . Source code in tripper/utils.py def infer_iri ( obj ): \"\"\"Return IRI of the individual that stands for object `obj`.\"\"\" if isinstance ( obj , str ): return obj if hasattr ( obj , \"uri\" ) and obj . uri : # dlite.Metadata or dataclass (or instance with uri) return obj . uri if hasattr ( obj , \"uuid\" ) and obj . uuid : # dlite.Instance or dataclass return obj . uuid if hasattr ( obj , \"schema\" ) and callable ( obj . schema ): # pydantic.BaseModel schema = obj . schema () properties = schema [ \"properties\" ] if \"uri\" in properties and properties [ \"uri\" ]: return properties [ \"uri\" ] if \"uuid\" in properties and properties [ \"uuid\" ]: return properties [ \"uuid\" ] raise TypeError ( \"cannot infer IRI from object {obj!r} \" )","title":"infer_iri()"},{"location":"api_reference/utils/#tripper.utils.parse_literal","text":"Parse literal and return it as an instance of Literal. The main difference between this function and the Literal constructor, is that this function correctly interprets n3-encoded literal strings. Source code in tripper/utils.py def parse_literal ( literal : \"Any\" ) -> \"Literal\" : \"\"\"Parse `literal` and return it as an instance of Literal. The main difference between this function and the Literal constructor, is that this function correctly interprets n3-encoded literal strings. \"\"\" # pylint: disable=invalid-name,too-many-branches lang , datatype = None , None if isinstance ( literal , Literal ): return literal if not isinstance ( literal , str ): if isinstance ( literal , tuple ( Literal . datatypes )): return Literal ( literal , lang = lang , datatype = Literal . datatypes . get ( type ( literal )) ) TypeError ( f \"unsupported literal type: { type ( literal ) } \" ) match = re . match ( r '^\\s*(\"\"\"(.*)\"\"\"|\"(.*)\")\\s*$' , literal , flags = re . DOTALL ) if match : _ , v1 , v2 = match . groups () value , datatype = v1 if v1 else v2 , XSD . string else : match = re . match ( r '^\\s*(\"\"\"(.*)\"\"\"|\"(.*)\")\\^\\^(.*)\\s*$' , literal , flags = re . DOTALL ) if match : _ , v1 , v2 , datatype = match . groups () value = v1 if v1 else v2 else : match = re . match ( r '^\\s*(\"\"\"(.*)\"\"\"|\"(.*)\")@(.*)\\s*$' , literal , flags = re . DOTALL ) if match : _ , v1 , v2 , lang = match . groups () value = v1 if v1 else v2 else : value = literal if lang or datatype : if datatype : types = { v : k for k , v in Literal . datatypes . items ()} type_ = types [ datatype ] try : value = type_ ( value ) except TypeError : pass return Literal ( value , lang = lang , datatype = datatype ) for type_ , datatype in Literal . datatypes . items (): if type_ is not bool : try : return Literal ( type_ ( literal ), lang = lang , datatype = datatype ) except ( ValueError , TypeError ): pass raise ValueError ( \"cannot parse {literal=}\" )","title":"parse_literal()"},{"location":"api_reference/utils/#tripper.utils.split_iri","text":"Split iri into namespace and name parts and return them as a tuple. Parameters: Name Type Description Default iri str The IRI to be split. required Returns: Type Description Tuple[str, str] A split IRI. Split into namespace and name. Source code in tripper/utils.py def split_iri ( iri : str ) -> \"Tuple[str, str]\" : \"\"\"Split iri into namespace and name parts and return them as a tuple. Parameters: iri: The IRI to be split. Returns: A split IRI. Split into namespace and name. \"\"\" if \"#\" in iri : namespace , name = iri . rsplit ( \"#\" , 1 ) return f \" { namespace } #\" , name if \"/\" in iri : namespace , name = iri . rsplit ( \"/\" , 1 ) return f \" { namespace } /\" , name raise ValueError ( \"all IRIs should contain a slash\" )","title":"split_iri()"},{"location":"api_reference/backends/ontopy/","text":"ontopy \u00b6 Backend for EMMOntoPy. For developers: The usage of s , p , and o represent the different parts of an RDF Triple: subject, predicate, and object. OntopyStrategy \u00b6 Triplestore strategy for EMMOntoPy. Parameters: Name Type Description Default base_iri Optional[str] The base iri of the ontology. Default to \"http://example.com/onto#\" if onto is not given. None onto Optional[Ontology] Ontology to initiate the triplestore from. Defaults to an new ontology with the given base_iri . None load bool Whether to load the ontology. False kwargs Keyword arguments passed to the ontology load() method. {} Either the base_iri or onto argument must be provided. Source code in tripper/backends/ontopy.py class OntopyStrategy : \"\"\"Triplestore strategy for EMMOntoPy. Arguments: base_iri: The base iri of the ontology. Default to \"http://example.com/onto#\" if `onto` is not given. onto: Ontology to initiate the triplestore from. Defaults to an new ontology with the given `base_iri`. load: Whether to load the ontology. kwargs: Keyword arguments passed to the ontology load() method. Either the `base_iri` or `onto` argument must be provided. \"\"\" def __init__ ( self , base_iri : \"Optional[str]\" = None , onto : \"Optional[Ontology]\" = None , load : bool = False , ** kwargs , ): if onto is None : if base_iri is None : base_iri = \"http://example.com/onto#\" self . onto = get_ontology ( base_iri ) elif isinstance ( onto , Ontology ): self . onto = onto else : raise TypeError ( \"`onto` must be either an ontology or None\" ) if load : self . onto . load ( ** kwargs ) def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples.\"\"\" def to_literal ( o , datatype ) -> Literal : \"\"\"Returns a literal from (o, datatype).\"\"\" if isinstance ( datatype , str ) and datatype . startswith ( \"@\" ): return Literal ( o , lang = datatype [ 1 :], datatype = None ) return Literal ( o , lang = None , datatype = datatype ) s , p , o = triple abb = ( None if ( s ) is None else self . onto . _abbreviate ( s ), None if ( p ) is None else self . onto . _abbreviate ( p ), None if ( o ) is None else self . onto . _abbreviate ( o ), ) for s , p , o in self . onto . _get_obj_triples_spo_spo ( * abb ): yield ( _unabbreviate ( self . onto , s ), _unabbreviate ( self . onto , p ), _unabbreviate ( self . onto , o ), ) for s , p , o , datatype in self . onto . _get_data_triples_spod_spod ( * abb , d = \"\" ): yield ( _unabbreviate ( self . onto , s ), _unabbreviate ( self . onto , p ), to_literal ( o , datatype ), ) def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" if TYPE_CHECKING : # pragma: no cover datatype : \"Union[int, str]\" for s , p , o in triples : if isinstance ( o , Literal ): if o . lang : datatype = f \"@ { o . lang } \" elif o . datatype : datatype = f \"^^ { o . datatype } \" else : datatype = 0 self . onto . _add_data_triple_spod ( self . onto . _abbreviate ( s ), self . onto . _abbreviate ( p ), self . onto . _abbreviate ( o ), datatype , ) else : self . onto . _add_obj_triple_spo ( self . onto . _abbreviate ( s ), self . onto . _abbreviate ( p ), self . onto . _abbreviate ( o ), ) def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" s , p , o = triple to_remove = list ( self . onto . _get_triples_spod_spod ( self . onto . _abbreviate ( s ) if ( s ) is not None else None , self . onto . _abbreviate ( p ) if ( s ) is not None else None , self . onto . _abbreviate ( o ) if ( s ) is not None else None , ) ) for s , p , o , datatype in to_remove : if datatype : self . onto . _del_data_triple_spod ( s , p , o , datatype ) else : self . onto . _del_obj_triple_spo ( s , p , o ) # Optional methods def parse ( self , source = None , location = None , data = None , format = None , # pylint: disable=redefined-builtin encoding = None , ** kwargs , ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Parameters: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. encoding: Encoding argument to io.open(). kwargs: Additional keyword arguments passed to Ontology.load(). \"\"\" if source : self . onto . load ( filename = source , format = format , ** kwargs ) elif location : self . onto . load ( filename = location , format = format , ** kwargs ) elif data : # s = io.StringIO(data) # self.onto.load(filename=s, format=format, **kwargs) # Could have been done much nicer if it hasn't been for Windows filename = None try : tmpfile_options = { \"delete\" : False } if isinstance ( data , str ): tmpfile_options . update ( mode = \"w+t\" , encoding = encoding ) with tempfile . NamedTemporaryFile ( ** tmpfile_options ) as handle : handle . write ( data ) filename = handle . name self . onto . load ( filename = filename , format = format , ** kwargs ) finally : if filename : os . remove ( filename ) else : raise ValueError ( \"either `source`, `location` or `data` must be given\" ) def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise to destination. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the Ontology.save() method. Returns: Serialised string if `destination` is None. \"\"\" if destination : self . onto . save ( destination , format = format , ** kwargs ) else : # Clumsy implementation due to Windows file locking... filename = None try : with tempfile . NamedTemporaryFile ( delete = False ) as handle : filename = handle . name self . onto . save ( filename , format = format , ** kwargs ) with open ( filename , \"rt\" , encoding = \"utf8\" ) as handle : return handle . read () finally : if filename : os . remove ( filename ) return None def query ( self , query_object , native = True , ** kwargs ) -> \"Union[List, Result]\" : \"\"\"SPARQL query. Parameters: query_object: String with the SPARQL query. native: Whether or not to use EMMOntoPy/Owlready2 or RDFLib. kwargs: Keyword arguments passed to rdflib.Graph.query(). Returns: SPARQL query results. \"\"\" if TYPE_CHECKING : res : \"Union[List, Result]\" if native : res = self . onto . world . sparql ( query_object ) else : graph = self . onto . world . as_rdflib_graph () res = graph . query ( query_object , ** kwargs ) # TODO: Convert result to expected type return res def update ( self , update_object , native = True , ** kwargs ) -> None : \"\"\"Update triplestore with SPARQL. Parameters: update_object: String with the SPARQL query. native: Whether or not to use EMMOntoPy/Owlready2 or RDFLib. kwargs: Keyword arguments passed to rdflib.Graph.update(). Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" if native : self . onto . world . sparql ( update_object ) else : graph = self . onto . world . as_rdflib_graph () graph . update ( update_object , ** kwargs ) add_triples ( self , triples ) \u00b6 Add a sequence of triples. Source code in tripper/backends/ontopy.py def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" if TYPE_CHECKING : # pragma: no cover datatype : \"Union[int, str]\" for s , p , o in triples : if isinstance ( o , Literal ): if o . lang : datatype = f \"@ { o . lang } \" elif o . datatype : datatype = f \"^^ { o . datatype } \" else : datatype = 0 self . onto . _add_data_triple_spod ( self . onto . _abbreviate ( s ), self . onto . _abbreviate ( p ), self . onto . _abbreviate ( o ), datatype , ) else : self . onto . _add_obj_triple_spo ( self . onto . _abbreviate ( s ), self . onto . _abbreviate ( p ), self . onto . _abbreviate ( o ), ) parse ( self , source = None , location = None , data = None , format = None , encoding = None , ** kwargs ) \u00b6 Parse source and add the resulting triples to triplestore. The source is specified using one of source , location or data . Parameters: Name Type Description Default source File-like object or file name. None location String with relative or absolute URL to source. None data String containing the data to be parsed. None format Needed if format can not be inferred from source. None encoding Encoding argument to io.open(). None kwargs Additional keyword arguments passed to Ontology.load(). {} Source code in tripper/backends/ontopy.py def parse ( self , source = None , location = None , data = None , format = None , # pylint: disable=redefined-builtin encoding = None , ** kwargs , ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Parameters: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. encoding: Encoding argument to io.open(). kwargs: Additional keyword arguments passed to Ontology.load(). \"\"\" if source : self . onto . load ( filename = source , format = format , ** kwargs ) elif location : self . onto . load ( filename = location , format = format , ** kwargs ) elif data : # s = io.StringIO(data) # self.onto.load(filename=s, format=format, **kwargs) # Could have been done much nicer if it hasn't been for Windows filename = None try : tmpfile_options = { \"delete\" : False } if isinstance ( data , str ): tmpfile_options . update ( mode = \"w+t\" , encoding = encoding ) with tempfile . NamedTemporaryFile ( ** tmpfile_options ) as handle : handle . write ( data ) filename = handle . name self . onto . load ( filename = filename , format = format , ** kwargs ) finally : if filename : os . remove ( filename ) else : raise ValueError ( \"either `source`, `location` or `data` must be given\" ) query ( self , query_object , native = True , ** kwargs ) \u00b6 SPARQL query. Parameters: Name Type Description Default query_object String with the SPARQL query. required native Whether or not to use EMMOntoPy/Owlready2 or RDFLib. True kwargs Keyword arguments passed to rdflib.Graph.query(). {} Returns: Type Description Union[List, Result] SPARQL query results. Source code in tripper/backends/ontopy.py def query ( self , query_object , native = True , ** kwargs ) -> \"Union[List, Result]\" : \"\"\"SPARQL query. Parameters: query_object: String with the SPARQL query. native: Whether or not to use EMMOntoPy/Owlready2 or RDFLib. kwargs: Keyword arguments passed to rdflib.Graph.query(). Returns: SPARQL query results. \"\"\" if TYPE_CHECKING : res : \"Union[List, Result]\" if native : res = self . onto . world . sparql ( query_object ) else : graph = self . onto . world . as_rdflib_graph () res = graph . query ( query_object , ** kwargs ) # TODO: Convert result to expected type return res remove ( self , triple ) \u00b6 Remove all matching triples from the backend. Source code in tripper/backends/ontopy.py def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" s , p , o = triple to_remove = list ( self . onto . _get_triples_spod_spod ( self . onto . _abbreviate ( s ) if ( s ) is not None else None , self . onto . _abbreviate ( p ) if ( s ) is not None else None , self . onto . _abbreviate ( o ) if ( s ) is not None else None , ) ) for s , p , o , datatype in to_remove : if datatype : self . onto . _del_data_triple_spod ( s , p , o , datatype ) else : self . onto . _del_obj_triple_spo ( s , p , o ) serialize ( self , destination = None , format = 'turtle' , ** kwargs ) \u00b6 Serialise to destination. Parameters: Name Type Description Default destination File name or object to write to. If None, the serialisation is returned. None format Format to serialise as. Supported formats, depends on the backend. 'turtle' kwargs Passed to the Ontology.save() method. {} Returns: Type Description Union[None, str] Serialised string if destination is None. Source code in tripper/backends/ontopy.py def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise to destination. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the Ontology.save() method. Returns: Serialised string if `destination` is None. \"\"\" if destination : self . onto . save ( destination , format = format , ** kwargs ) else : # Clumsy implementation due to Windows file locking... filename = None try : with tempfile . NamedTemporaryFile ( delete = False ) as handle : filename = handle . name self . onto . save ( filename , format = format , ** kwargs ) with open ( filename , \"rt\" , encoding = \"utf8\" ) as handle : return handle . read () finally : if filename : os . remove ( filename ) return None triples ( self , triple ) \u00b6 Returns a generator over matching triples. Source code in tripper/backends/ontopy.py def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples.\"\"\" def to_literal ( o , datatype ) -> Literal : \"\"\"Returns a literal from (o, datatype).\"\"\" if isinstance ( datatype , str ) and datatype . startswith ( \"@\" ): return Literal ( o , lang = datatype [ 1 :], datatype = None ) return Literal ( o , lang = None , datatype = datatype ) s , p , o = triple abb = ( None if ( s ) is None else self . onto . _abbreviate ( s ), None if ( p ) is None else self . onto . _abbreviate ( p ), None if ( o ) is None else self . onto . _abbreviate ( o ), ) for s , p , o in self . onto . _get_obj_triples_spo_spo ( * abb ): yield ( _unabbreviate ( self . onto , s ), _unabbreviate ( self . onto , p ), _unabbreviate ( self . onto , o ), ) for s , p , o , datatype in self . onto . _get_data_triples_spod_spod ( * abb , d = \"\" ): yield ( _unabbreviate ( self . onto , s ), _unabbreviate ( self . onto , p ), to_literal ( o , datatype ), ) update ( self , update_object , native = True , ** kwargs ) \u00b6 Update triplestore with SPARQL. Parameters: Name Type Description Default update_object String with the SPARQL query. required native Whether or not to use EMMOntoPy/Owlready2 or RDFLib. True kwargs Keyword arguments passed to rdflib.Graph.update(). {} Note This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. Source code in tripper/backends/ontopy.py def update ( self , update_object , native = True , ** kwargs ) -> None : \"\"\"Update triplestore with SPARQL. Parameters: update_object: String with the SPARQL query. native: Whether or not to use EMMOntoPy/Owlready2 or RDFLib. kwargs: Keyword arguments passed to rdflib.Graph.update(). Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" if native : self . onto . world . sparql ( update_object ) else : graph = self . onto . world . as_rdflib_graph () graph . update ( update_object , ** kwargs )","title":"ontopy"},{"location":"api_reference/backends/ontopy/#ontopy","text":"Backend for EMMOntoPy. For developers: The usage of s , p , and o represent the different parts of an RDF Triple: subject, predicate, and object.","title":"ontopy"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy","text":"Triplestore strategy for EMMOntoPy. Parameters: Name Type Description Default base_iri Optional[str] The base iri of the ontology. Default to \"http://example.com/onto#\" if onto is not given. None onto Optional[Ontology] Ontology to initiate the triplestore from. Defaults to an new ontology with the given base_iri . None load bool Whether to load the ontology. False kwargs Keyword arguments passed to the ontology load() method. {} Either the base_iri or onto argument must be provided. Source code in tripper/backends/ontopy.py class OntopyStrategy : \"\"\"Triplestore strategy for EMMOntoPy. Arguments: base_iri: The base iri of the ontology. Default to \"http://example.com/onto#\" if `onto` is not given. onto: Ontology to initiate the triplestore from. Defaults to an new ontology with the given `base_iri`. load: Whether to load the ontology. kwargs: Keyword arguments passed to the ontology load() method. Either the `base_iri` or `onto` argument must be provided. \"\"\" def __init__ ( self , base_iri : \"Optional[str]\" = None , onto : \"Optional[Ontology]\" = None , load : bool = False , ** kwargs , ): if onto is None : if base_iri is None : base_iri = \"http://example.com/onto#\" self . onto = get_ontology ( base_iri ) elif isinstance ( onto , Ontology ): self . onto = onto else : raise TypeError ( \"`onto` must be either an ontology or None\" ) if load : self . onto . load ( ** kwargs ) def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples.\"\"\" def to_literal ( o , datatype ) -> Literal : \"\"\"Returns a literal from (o, datatype).\"\"\" if isinstance ( datatype , str ) and datatype . startswith ( \"@\" ): return Literal ( o , lang = datatype [ 1 :], datatype = None ) return Literal ( o , lang = None , datatype = datatype ) s , p , o = triple abb = ( None if ( s ) is None else self . onto . _abbreviate ( s ), None if ( p ) is None else self . onto . _abbreviate ( p ), None if ( o ) is None else self . onto . _abbreviate ( o ), ) for s , p , o in self . onto . _get_obj_triples_spo_spo ( * abb ): yield ( _unabbreviate ( self . onto , s ), _unabbreviate ( self . onto , p ), _unabbreviate ( self . onto , o ), ) for s , p , o , datatype in self . onto . _get_data_triples_spod_spod ( * abb , d = \"\" ): yield ( _unabbreviate ( self . onto , s ), _unabbreviate ( self . onto , p ), to_literal ( o , datatype ), ) def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" if TYPE_CHECKING : # pragma: no cover datatype : \"Union[int, str]\" for s , p , o in triples : if isinstance ( o , Literal ): if o . lang : datatype = f \"@ { o . lang } \" elif o . datatype : datatype = f \"^^ { o . datatype } \" else : datatype = 0 self . onto . _add_data_triple_spod ( self . onto . _abbreviate ( s ), self . onto . _abbreviate ( p ), self . onto . _abbreviate ( o ), datatype , ) else : self . onto . _add_obj_triple_spo ( self . onto . _abbreviate ( s ), self . onto . _abbreviate ( p ), self . onto . _abbreviate ( o ), ) def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" s , p , o = triple to_remove = list ( self . onto . _get_triples_spod_spod ( self . onto . _abbreviate ( s ) if ( s ) is not None else None , self . onto . _abbreviate ( p ) if ( s ) is not None else None , self . onto . _abbreviate ( o ) if ( s ) is not None else None , ) ) for s , p , o , datatype in to_remove : if datatype : self . onto . _del_data_triple_spod ( s , p , o , datatype ) else : self . onto . _del_obj_triple_spo ( s , p , o ) # Optional methods def parse ( self , source = None , location = None , data = None , format = None , # pylint: disable=redefined-builtin encoding = None , ** kwargs , ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Parameters: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. encoding: Encoding argument to io.open(). kwargs: Additional keyword arguments passed to Ontology.load(). \"\"\" if source : self . onto . load ( filename = source , format = format , ** kwargs ) elif location : self . onto . load ( filename = location , format = format , ** kwargs ) elif data : # s = io.StringIO(data) # self.onto.load(filename=s, format=format, **kwargs) # Could have been done much nicer if it hasn't been for Windows filename = None try : tmpfile_options = { \"delete\" : False } if isinstance ( data , str ): tmpfile_options . update ( mode = \"w+t\" , encoding = encoding ) with tempfile . NamedTemporaryFile ( ** tmpfile_options ) as handle : handle . write ( data ) filename = handle . name self . onto . load ( filename = filename , format = format , ** kwargs ) finally : if filename : os . remove ( filename ) else : raise ValueError ( \"either `source`, `location` or `data` must be given\" ) def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise to destination. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the Ontology.save() method. Returns: Serialised string if `destination` is None. \"\"\" if destination : self . onto . save ( destination , format = format , ** kwargs ) else : # Clumsy implementation due to Windows file locking... filename = None try : with tempfile . NamedTemporaryFile ( delete = False ) as handle : filename = handle . name self . onto . save ( filename , format = format , ** kwargs ) with open ( filename , \"rt\" , encoding = \"utf8\" ) as handle : return handle . read () finally : if filename : os . remove ( filename ) return None def query ( self , query_object , native = True , ** kwargs ) -> \"Union[List, Result]\" : \"\"\"SPARQL query. Parameters: query_object: String with the SPARQL query. native: Whether or not to use EMMOntoPy/Owlready2 or RDFLib. kwargs: Keyword arguments passed to rdflib.Graph.query(). Returns: SPARQL query results. \"\"\" if TYPE_CHECKING : res : \"Union[List, Result]\" if native : res = self . onto . world . sparql ( query_object ) else : graph = self . onto . world . as_rdflib_graph () res = graph . query ( query_object , ** kwargs ) # TODO: Convert result to expected type return res def update ( self , update_object , native = True , ** kwargs ) -> None : \"\"\"Update triplestore with SPARQL. Parameters: update_object: String with the SPARQL query. native: Whether or not to use EMMOntoPy/Owlready2 or RDFLib. kwargs: Keyword arguments passed to rdflib.Graph.update(). Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" if native : self . onto . world . sparql ( update_object ) else : graph = self . onto . world . as_rdflib_graph () graph . update ( update_object , ** kwargs )","title":"OntopyStrategy"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.add_triples","text":"Add a sequence of triples. Source code in tripper/backends/ontopy.py def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" if TYPE_CHECKING : # pragma: no cover datatype : \"Union[int, str]\" for s , p , o in triples : if isinstance ( o , Literal ): if o . lang : datatype = f \"@ { o . lang } \" elif o . datatype : datatype = f \"^^ { o . datatype } \" else : datatype = 0 self . onto . _add_data_triple_spod ( self . onto . _abbreviate ( s ), self . onto . _abbreviate ( p ), self . onto . _abbreviate ( o ), datatype , ) else : self . onto . _add_obj_triple_spo ( self . onto . _abbreviate ( s ), self . onto . _abbreviate ( p ), self . onto . _abbreviate ( o ), )","title":"add_triples()"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.parse","text":"Parse source and add the resulting triples to triplestore. The source is specified using one of source , location or data . Parameters: Name Type Description Default source File-like object or file name. None location String with relative or absolute URL to source. None data String containing the data to be parsed. None format Needed if format can not be inferred from source. None encoding Encoding argument to io.open(). None kwargs Additional keyword arguments passed to Ontology.load(). {} Source code in tripper/backends/ontopy.py def parse ( self , source = None , location = None , data = None , format = None , # pylint: disable=redefined-builtin encoding = None , ** kwargs , ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Parameters: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. encoding: Encoding argument to io.open(). kwargs: Additional keyword arguments passed to Ontology.load(). \"\"\" if source : self . onto . load ( filename = source , format = format , ** kwargs ) elif location : self . onto . load ( filename = location , format = format , ** kwargs ) elif data : # s = io.StringIO(data) # self.onto.load(filename=s, format=format, **kwargs) # Could have been done much nicer if it hasn't been for Windows filename = None try : tmpfile_options = { \"delete\" : False } if isinstance ( data , str ): tmpfile_options . update ( mode = \"w+t\" , encoding = encoding ) with tempfile . NamedTemporaryFile ( ** tmpfile_options ) as handle : handle . write ( data ) filename = handle . name self . onto . load ( filename = filename , format = format , ** kwargs ) finally : if filename : os . remove ( filename ) else : raise ValueError ( \"either `source`, `location` or `data` must be given\" )","title":"parse()"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.query","text":"SPARQL query. Parameters: Name Type Description Default query_object String with the SPARQL query. required native Whether or not to use EMMOntoPy/Owlready2 or RDFLib. True kwargs Keyword arguments passed to rdflib.Graph.query(). {} Returns: Type Description Union[List, Result] SPARQL query results. Source code in tripper/backends/ontopy.py def query ( self , query_object , native = True , ** kwargs ) -> \"Union[List, Result]\" : \"\"\"SPARQL query. Parameters: query_object: String with the SPARQL query. native: Whether or not to use EMMOntoPy/Owlready2 or RDFLib. kwargs: Keyword arguments passed to rdflib.Graph.query(). Returns: SPARQL query results. \"\"\" if TYPE_CHECKING : res : \"Union[List, Result]\" if native : res = self . onto . world . sparql ( query_object ) else : graph = self . onto . world . as_rdflib_graph () res = graph . query ( query_object , ** kwargs ) # TODO: Convert result to expected type return res","title":"query()"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.remove","text":"Remove all matching triples from the backend. Source code in tripper/backends/ontopy.py def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" s , p , o = triple to_remove = list ( self . onto . _get_triples_spod_spod ( self . onto . _abbreviate ( s ) if ( s ) is not None else None , self . onto . _abbreviate ( p ) if ( s ) is not None else None , self . onto . _abbreviate ( o ) if ( s ) is not None else None , ) ) for s , p , o , datatype in to_remove : if datatype : self . onto . _del_data_triple_spod ( s , p , o , datatype ) else : self . onto . _del_obj_triple_spo ( s , p , o )","title":"remove()"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.serialize","text":"Serialise to destination. Parameters: Name Type Description Default destination File name or object to write to. If None, the serialisation is returned. None format Format to serialise as. Supported formats, depends on the backend. 'turtle' kwargs Passed to the Ontology.save() method. {} Returns: Type Description Union[None, str] Serialised string if destination is None. Source code in tripper/backends/ontopy.py def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise to destination. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the Ontology.save() method. Returns: Serialised string if `destination` is None. \"\"\" if destination : self . onto . save ( destination , format = format , ** kwargs ) else : # Clumsy implementation due to Windows file locking... filename = None try : with tempfile . NamedTemporaryFile ( delete = False ) as handle : filename = handle . name self . onto . save ( filename , format = format , ** kwargs ) with open ( filename , \"rt\" , encoding = \"utf8\" ) as handle : return handle . read () finally : if filename : os . remove ( filename ) return None","title":"serialize()"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.triples","text":"Returns a generator over matching triples. Source code in tripper/backends/ontopy.py def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples.\"\"\" def to_literal ( o , datatype ) -> Literal : \"\"\"Returns a literal from (o, datatype).\"\"\" if isinstance ( datatype , str ) and datatype . startswith ( \"@\" ): return Literal ( o , lang = datatype [ 1 :], datatype = None ) return Literal ( o , lang = None , datatype = datatype ) s , p , o = triple abb = ( None if ( s ) is None else self . onto . _abbreviate ( s ), None if ( p ) is None else self . onto . _abbreviate ( p ), None if ( o ) is None else self . onto . _abbreviate ( o ), ) for s , p , o in self . onto . _get_obj_triples_spo_spo ( * abb ): yield ( _unabbreviate ( self . onto , s ), _unabbreviate ( self . onto , p ), _unabbreviate ( self . onto , o ), ) for s , p , o , datatype in self . onto . _get_data_triples_spod_spod ( * abb , d = \"\" ): yield ( _unabbreviate ( self . onto , s ), _unabbreviate ( self . onto , p ), to_literal ( o , datatype ), )","title":"triples()"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.update","text":"Update triplestore with SPARQL. Parameters: Name Type Description Default update_object String with the SPARQL query. required native Whether or not to use EMMOntoPy/Owlready2 or RDFLib. True kwargs Keyword arguments passed to rdflib.Graph.update(). {} Note This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. Source code in tripper/backends/ontopy.py def update ( self , update_object , native = True , ** kwargs ) -> None : \"\"\"Update triplestore with SPARQL. Parameters: update_object: String with the SPARQL query. native: Whether or not to use EMMOntoPy/Owlready2 or RDFLib. kwargs: Keyword arguments passed to rdflib.Graph.update(). Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" if native : self . onto . world . sparql ( update_object ) else : graph = self . onto . world . as_rdflib_graph () graph . update ( update_object , ** kwargs )","title":"update()"},{"location":"api_reference/backends/rdflib/","text":"rdflib \u00b6 Backend for RDFLib. For developers: The usage of s , p , and o represent the different parts of an RDF Triple: subject, predicate, and object. RdflibStrategy \u00b6 Triplestore strategy for rdflib. Parameters: Name Type Description Default base_iri Optional[str] If given, initialise the triplestore from this storage. When close() is called, the storage will be overwritten with the current content of the triplestore. None triplestore_url Optional[str] Alternative URL to the underlying ontology if base_iri is not resolvable. Defaults to base_iri . None format Optional[str] Format of storage specified with base_iri . None Source code in tripper/backends/rdflib.py class RdflibStrategy : \"\"\"Triplestore strategy for rdflib. Arguments: base_iri: If given, initialise the triplestore from this storage. When `close()` is called, the storage will be overwritten with the current content of the triplestore. triplestore_url: Alternative URL to the underlying ontology if `base_iri` is not resolvable. Defaults to `base_iri`. format: Format of storage specified with `base_iri`. \"\"\" def __init__ ( self , base_iri : \"Optional[str]\" = None , triplestore_url : \"Optional[str]\" = None , format : \"Optional[str]\" = None , # pylint: disable=redefined-builtin ) -> None : self . graph = Graph () self . base_iri = base_iri self . triplestore_url = triplestore_url if triplestore_url else base_iri if self . triplestore_url is not None : if format is None : format = guess_format ( self . triplestore_url ) self . parse ( location = self . triplestore_url , format = format ) self . base_format = format def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples.\"\"\" for s , p , o in self . graph . triples ( # pylint: disable=not-an-iterable astriple ( triple ) ): yield ( str ( s ), str ( p ), Literal ( o . value , lang = o . language , datatype = o . datatype ) if isinstance ( o , rdflibLiteral ) else str ( o ), ) def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" for triple in triples : self . graph . add ( astriple ( triple )) def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" self . graph . remove ( astriple ( triple )) # Optional methods def close ( self ): \"\"\"Close the internal RDFLib graph.\"\"\" if self . triplestore_url : self . serialize ( destination = self . triplestore_url , format = self . base_format ) self . graph . close () def parse ( self , source = None , location = None , data = None , format = None , # pylint: disable=redefined-builtin ** kwargs , ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Parameters: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. kwargs: Additional less used keyword arguments. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.parse \"\"\" self . graph . parse ( source = source , location = location , data = data , format = format , ** kwargs ) def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise to destination. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the rdflib.Graph.serialize() method. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.serialize Returns: Serialised string if `destination` is None. \"\"\" result = self . graph . serialize ( destination = destination , format = format , ** kwargs ) if destination is None : # Depending on the version of rdflib the return value of # graph.serialize() man either be a string or a bytes object... return result if isinstance ( result , str ) else result . decode () return None def query ( self , query_object , ** kwargs ) -> \"List[Tuple[str, ...]]\" : \"\"\"SPARQL query. Parameters: query_object: String with the SPARQL query. kwargs: Keyword arguments passed to rdflib.Graph.query(). Returns: List of tuples of IRIs for each matching row. \"\"\" rows = self . graph . query ( query_object = query_object , ** kwargs ) return [ tuple ( str ( v ) for v in row ) for row in rows ] def update ( self , update_object , ** kwargs ) -> None : \"\"\"Update triplestore with SPARQL. Parameters: update_object: String with the SPARQL query. kwargs: Keyword arguments passed to rdflib.Graph.update(). Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" return self . graph . update ( update_object = update_object , ** kwargs ) def bind ( self , prefix : str , namespace : str ): \"\"\"Bind prefix to namespace. Should only be defined if the backend supports namespaces. Called by triplestore.bind(). \"\"\" if namespace : self . graph . bind ( prefix , namespace , replace = True ) else : warnings . warn ( \"rdflib does not support removing namespace prefixes\" ) def namespaces ( self ) -> dict : \"\"\"Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. \"\"\" return { prefix : str ( namespace ) for prefix , namespace in self . graph . namespaces ()} add_triples ( self , triples ) \u00b6 Add a sequence of triples. Source code in tripper/backends/rdflib.py def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" for triple in triples : self . graph . add ( astriple ( triple )) bind ( self , prefix , namespace ) \u00b6 Bind prefix to namespace. Should only be defined if the backend supports namespaces. Called by triplestore.bind(). Source code in tripper/backends/rdflib.py def bind ( self , prefix : str , namespace : str ): \"\"\"Bind prefix to namespace. Should only be defined if the backend supports namespaces. Called by triplestore.bind(). \"\"\" if namespace : self . graph . bind ( prefix , namespace , replace = True ) else : warnings . warn ( \"rdflib does not support removing namespace prefixes\" ) close ( self ) \u00b6 Close the internal RDFLib graph. Source code in tripper/backends/rdflib.py def close ( self ): \"\"\"Close the internal RDFLib graph.\"\"\" if self . triplestore_url : self . serialize ( destination = self . triplestore_url , format = self . base_format ) self . graph . close () namespaces ( self ) \u00b6 Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. Source code in tripper/backends/rdflib.py def namespaces ( self ) -> dict : \"\"\"Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. \"\"\" return { prefix : str ( namespace ) for prefix , namespace in self . graph . namespaces ()} parse ( self , source = None , location = None , data = None , format = None , ** kwargs ) \u00b6 Parse source and add the resulting triples to triplestore. The source is specified using one of source , location or data . Parameters: Name Type Description Default source File-like object or file name. None location String with relative or absolute URL to source. None data String containing the data to be parsed. None format Needed if format can not be inferred from source. None kwargs Additional less used keyword arguments. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.parse {} Source code in tripper/backends/rdflib.py def parse ( self , source = None , location = None , data = None , format = None , # pylint: disable=redefined-builtin ** kwargs , ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Parameters: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. kwargs: Additional less used keyword arguments. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.parse \"\"\" self . graph . parse ( source = source , location = location , data = data , format = format , ** kwargs ) query ( self , query_object , ** kwargs ) \u00b6 SPARQL query. Parameters: Name Type Description Default query_object String with the SPARQL query. required kwargs Keyword arguments passed to rdflib.Graph.query(). {} Returns: Type Description List[Tuple[str, ...]] List of tuples of IRIs for each matching row. Source code in tripper/backends/rdflib.py def query ( self , query_object , ** kwargs ) -> \"List[Tuple[str, ...]]\" : \"\"\"SPARQL query. Parameters: query_object: String with the SPARQL query. kwargs: Keyword arguments passed to rdflib.Graph.query(). Returns: List of tuples of IRIs for each matching row. \"\"\" rows = self . graph . query ( query_object = query_object , ** kwargs ) return [ tuple ( str ( v ) for v in row ) for row in rows ] remove ( self , triple ) \u00b6 Remove all matching triples from the backend. Source code in tripper/backends/rdflib.py def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" self . graph . remove ( astriple ( triple )) serialize ( self , destination = None , format = 'turtle' , ** kwargs ) \u00b6 Serialise to destination. Parameters: Name Type Description Default destination File name or object to write to. If None, the serialisation is returned. None format Format to serialise as. Supported formats, depends on the backend. 'turtle' kwargs Passed to the rdflib.Graph.serialize() method. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.serialize {} Returns: Type Description Union[None, str] Serialised string if destination is None. Source code in tripper/backends/rdflib.py def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise to destination. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the rdflib.Graph.serialize() method. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.serialize Returns: Serialised string if `destination` is None. \"\"\" result = self . graph . serialize ( destination = destination , format = format , ** kwargs ) if destination is None : # Depending on the version of rdflib the return value of # graph.serialize() man either be a string or a bytes object... return result if isinstance ( result , str ) else result . decode () return None triples ( self , triple ) \u00b6 Returns a generator over matching triples. Source code in tripper/backends/rdflib.py def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples.\"\"\" for s , p , o in self . graph . triples ( # pylint: disable=not-an-iterable astriple ( triple ) ): yield ( str ( s ), str ( p ), Literal ( o . value , lang = o . language , datatype = o . datatype ) if isinstance ( o , rdflibLiteral ) else str ( o ), ) update ( self , update_object , ** kwargs ) \u00b6 Update triplestore with SPARQL. Parameters: Name Type Description Default update_object String with the SPARQL query. required kwargs Keyword arguments passed to rdflib.Graph.update(). {} Note This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. Source code in tripper/backends/rdflib.py def update ( self , update_object , ** kwargs ) -> None : \"\"\"Update triplestore with SPARQL. Parameters: update_object: String with the SPARQL query. kwargs: Keyword arguments passed to rdflib.Graph.update(). Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" return self . graph . update ( update_object = update_object , ** kwargs ) astriple ( triple ) \u00b6 Help function converting a triple to rdflib triple. Source code in tripper/backends/rdflib.py def astriple ( triple : \"Triple\" ): \"\"\"Help function converting a triple to rdflib triple.\"\"\" s , p , o = triple return asuri ( s ), asuri ( p ), asuri ( o ) asuri ( value ) \u00b6 Help function converting a spo-value to proper rdflib type. Source code in tripper/backends/rdflib.py def asuri ( value : \"Union[None, Literal, str]\" ): \"\"\"Help function converting a spo-value to proper rdflib type.\"\"\" if value is None : return None if isinstance ( value , Literal ): return rdflibLiteral ( value . value , lang = value . lang , datatype = value . datatype ) if value . startswith ( \"_:\" ): return BNode ( value ) return URIRef ( value )","title":"rdflib"},{"location":"api_reference/backends/rdflib/#rdflib","text":"Backend for RDFLib. For developers: The usage of s , p , and o represent the different parts of an RDF Triple: subject, predicate, and object.","title":"rdflib"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy","text":"Triplestore strategy for rdflib. Parameters: Name Type Description Default base_iri Optional[str] If given, initialise the triplestore from this storage. When close() is called, the storage will be overwritten with the current content of the triplestore. None triplestore_url Optional[str] Alternative URL to the underlying ontology if base_iri is not resolvable. Defaults to base_iri . None format Optional[str] Format of storage specified with base_iri . None Source code in tripper/backends/rdflib.py class RdflibStrategy : \"\"\"Triplestore strategy for rdflib. Arguments: base_iri: If given, initialise the triplestore from this storage. When `close()` is called, the storage will be overwritten with the current content of the triplestore. triplestore_url: Alternative URL to the underlying ontology if `base_iri` is not resolvable. Defaults to `base_iri`. format: Format of storage specified with `base_iri`. \"\"\" def __init__ ( self , base_iri : \"Optional[str]\" = None , triplestore_url : \"Optional[str]\" = None , format : \"Optional[str]\" = None , # pylint: disable=redefined-builtin ) -> None : self . graph = Graph () self . base_iri = base_iri self . triplestore_url = triplestore_url if triplestore_url else base_iri if self . triplestore_url is not None : if format is None : format = guess_format ( self . triplestore_url ) self . parse ( location = self . triplestore_url , format = format ) self . base_format = format def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples.\"\"\" for s , p , o in self . graph . triples ( # pylint: disable=not-an-iterable astriple ( triple ) ): yield ( str ( s ), str ( p ), Literal ( o . value , lang = o . language , datatype = o . datatype ) if isinstance ( o , rdflibLiteral ) else str ( o ), ) def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" for triple in triples : self . graph . add ( astriple ( triple )) def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" self . graph . remove ( astriple ( triple )) # Optional methods def close ( self ): \"\"\"Close the internal RDFLib graph.\"\"\" if self . triplestore_url : self . serialize ( destination = self . triplestore_url , format = self . base_format ) self . graph . close () def parse ( self , source = None , location = None , data = None , format = None , # pylint: disable=redefined-builtin ** kwargs , ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Parameters: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. kwargs: Additional less used keyword arguments. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.parse \"\"\" self . graph . parse ( source = source , location = location , data = data , format = format , ** kwargs ) def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise to destination. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the rdflib.Graph.serialize() method. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.serialize Returns: Serialised string if `destination` is None. \"\"\" result = self . graph . serialize ( destination = destination , format = format , ** kwargs ) if destination is None : # Depending on the version of rdflib the return value of # graph.serialize() man either be a string or a bytes object... return result if isinstance ( result , str ) else result . decode () return None def query ( self , query_object , ** kwargs ) -> \"List[Tuple[str, ...]]\" : \"\"\"SPARQL query. Parameters: query_object: String with the SPARQL query. kwargs: Keyword arguments passed to rdflib.Graph.query(). Returns: List of tuples of IRIs for each matching row. \"\"\" rows = self . graph . query ( query_object = query_object , ** kwargs ) return [ tuple ( str ( v ) for v in row ) for row in rows ] def update ( self , update_object , ** kwargs ) -> None : \"\"\"Update triplestore with SPARQL. Parameters: update_object: String with the SPARQL query. kwargs: Keyword arguments passed to rdflib.Graph.update(). Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" return self . graph . update ( update_object = update_object , ** kwargs ) def bind ( self , prefix : str , namespace : str ): \"\"\"Bind prefix to namespace. Should only be defined if the backend supports namespaces. Called by triplestore.bind(). \"\"\" if namespace : self . graph . bind ( prefix , namespace , replace = True ) else : warnings . warn ( \"rdflib does not support removing namespace prefixes\" ) def namespaces ( self ) -> dict : \"\"\"Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. \"\"\" return { prefix : str ( namespace ) for prefix , namespace in self . graph . namespaces ()}","title":"RdflibStrategy"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.add_triples","text":"Add a sequence of triples. Source code in tripper/backends/rdflib.py def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" for triple in triples : self . graph . add ( astriple ( triple ))","title":"add_triples()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.bind","text":"Bind prefix to namespace. Should only be defined if the backend supports namespaces. Called by triplestore.bind(). Source code in tripper/backends/rdflib.py def bind ( self , prefix : str , namespace : str ): \"\"\"Bind prefix to namespace. Should only be defined if the backend supports namespaces. Called by triplestore.bind(). \"\"\" if namespace : self . graph . bind ( prefix , namespace , replace = True ) else : warnings . warn ( \"rdflib does not support removing namespace prefixes\" )","title":"bind()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.close","text":"Close the internal RDFLib graph. Source code in tripper/backends/rdflib.py def close ( self ): \"\"\"Close the internal RDFLib graph.\"\"\" if self . triplestore_url : self . serialize ( destination = self . triplestore_url , format = self . base_format ) self . graph . close ()","title":"close()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.namespaces","text":"Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. Source code in tripper/backends/rdflib.py def namespaces ( self ) -> dict : \"\"\"Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. \"\"\" return { prefix : str ( namespace ) for prefix , namespace in self . graph . namespaces ()}","title":"namespaces()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.parse","text":"Parse source and add the resulting triples to triplestore. The source is specified using one of source , location or data . Parameters: Name Type Description Default source File-like object or file name. None location String with relative or absolute URL to source. None data String containing the data to be parsed. None format Needed if format can not be inferred from source. None kwargs Additional less used keyword arguments. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.parse {} Source code in tripper/backends/rdflib.py def parse ( self , source = None , location = None , data = None , format = None , # pylint: disable=redefined-builtin ** kwargs , ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Parameters: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. kwargs: Additional less used keyword arguments. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.parse \"\"\" self . graph . parse ( source = source , location = location , data = data , format = format , ** kwargs )","title":"parse()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.query","text":"SPARQL query. Parameters: Name Type Description Default query_object String with the SPARQL query. required kwargs Keyword arguments passed to rdflib.Graph.query(). {} Returns: Type Description List[Tuple[str, ...]] List of tuples of IRIs for each matching row. Source code in tripper/backends/rdflib.py def query ( self , query_object , ** kwargs ) -> \"List[Tuple[str, ...]]\" : \"\"\"SPARQL query. Parameters: query_object: String with the SPARQL query. kwargs: Keyword arguments passed to rdflib.Graph.query(). Returns: List of tuples of IRIs for each matching row. \"\"\" rows = self . graph . query ( query_object = query_object , ** kwargs ) return [ tuple ( str ( v ) for v in row ) for row in rows ]","title":"query()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.remove","text":"Remove all matching triples from the backend. Source code in tripper/backends/rdflib.py def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" self . graph . remove ( astriple ( triple ))","title":"remove()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.serialize","text":"Serialise to destination. Parameters: Name Type Description Default destination File name or object to write to. If None, the serialisation is returned. None format Format to serialise as. Supported formats, depends on the backend. 'turtle' kwargs Passed to the rdflib.Graph.serialize() method. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.serialize {} Returns: Type Description Union[None, str] Serialised string if destination is None. Source code in tripper/backends/rdflib.py def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise to destination. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the rdflib.Graph.serialize() method. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.serialize Returns: Serialised string if `destination` is None. \"\"\" result = self . graph . serialize ( destination = destination , format = format , ** kwargs ) if destination is None : # Depending on the version of rdflib the return value of # graph.serialize() man either be a string or a bytes object... return result if isinstance ( result , str ) else result . decode () return None","title":"serialize()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.triples","text":"Returns a generator over matching triples. Source code in tripper/backends/rdflib.py def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples.\"\"\" for s , p , o in self . graph . triples ( # pylint: disable=not-an-iterable astriple ( triple ) ): yield ( str ( s ), str ( p ), Literal ( o . value , lang = o . language , datatype = o . datatype ) if isinstance ( o , rdflibLiteral ) else str ( o ), )","title":"triples()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.update","text":"Update triplestore with SPARQL. Parameters: Name Type Description Default update_object String with the SPARQL query. required kwargs Keyword arguments passed to rdflib.Graph.update(). {} Note This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. Source code in tripper/backends/rdflib.py def update ( self , update_object , ** kwargs ) -> None : \"\"\"Update triplestore with SPARQL. Parameters: update_object: String with the SPARQL query. kwargs: Keyword arguments passed to rdflib.Graph.update(). Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" return self . graph . update ( update_object = update_object , ** kwargs )","title":"update()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.astriple","text":"Help function converting a triple to rdflib triple. Source code in tripper/backends/rdflib.py def astriple ( triple : \"Triple\" ): \"\"\"Help function converting a triple to rdflib triple.\"\"\" s , p , o = triple return asuri ( s ), asuri ( p ), asuri ( o )","title":"astriple()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.asuri","text":"Help function converting a spo-value to proper rdflib type. Source code in tripper/backends/rdflib.py def asuri ( value : \"Union[None, Literal, str]\" ): \"\"\"Help function converting a spo-value to proper rdflib type.\"\"\" if value is None : return None if isinstance ( value , Literal ): return rdflibLiteral ( value . value , lang = value . lang , datatype = value . datatype ) if value . startswith ( \"_:\" ): return BNode ( value ) return URIRef ( value )","title":"asuri()"}]}