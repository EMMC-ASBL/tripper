{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tripper","text":"<p>Triplestore wrapper for Python providing a simple and consistent interface to a range of triplestore backends.</p> <p> </p>"},{"location":"#getting-started","title":"Getting started","text":"<ul> <li>Tutorial</li> <li>Discovery of custom backends</li> <li>Reference manual</li> <li>Known issues</li> </ul>"},{"location":"#basic-concepts","title":"Basic concepts","text":"<p>Tripper provides a simple and consistent interface to a range of triplestore backends. It strives for simplicity and is modelled after rdflib (with a few simplifications).</p> <p>In Tripper:</p> <ul> <li> <p>All IRIs are represented by Python strings.   Example: <code>\"https://w3id.org/emmo#Metre\"</code></p> </li> <li> <p>Blank nodes are strings starting with \"_:\".   Example: <code>\"_:bnode1\"</code></p> </li> <li> <p>Literals are constructed with <code>tripper.Literal</code>.   Example: <code>tripper.Literal(3.14, datatype=XSD.float)</code></p> </li> </ul> <p>To make it easy to work with IRIs, provide Tripper a set of pre-defined namespaces, like <code>XSD.float</code>. New namespaces can be defined with the <code>tripper.Namespace</code> class.</p> <p>A triplestore wrapper is created with the <code>tripper.Triplestore</code> class.</p>"},{"location":"#advanced-features","title":"Advanced features","text":"<p>The submodules <code>mappings</code> and <code>convert</code> provide additional functionality beyond interfacing triplestore backends: - tripper.mappings: traverse mappings stored in the triplestore and find possible mapping routes. - tripper.convert: convert between RDF and other data representations.</p>"},{"location":"#available-backends","title":"Available backends","text":"<p>The following backends are currently available, either in Tripper or other packages.</p> Backend name Provided by Requirements Comment rdflib tripper rdflib In-memory rdflib triplestore supporting all features. ontopy tripper EMMOntoPy Backend for EMMOntoPy. In-memory. sparqlwrapper tripper sparqlwrapper Generic backend for all triplestores supported by sparqlwrapper. collection tripper DLite-Python Backend to a DLite collection. fuseki PyBackTrip sparqlwrapper Backend to fuseki. stardog PyBackTrip sparqlwrapper,pystardog Backend to StarDog. graphdb PyBackTrip sparqlwrapper Backend to GraphDB."},{"location":"#installation","title":"Installation","text":"<p>Tripper has by itself no dependencies outside the standard library, but the triplestore backends may have specific dependencies.</p> <p>The package can be installed from PyPI using <code>pip</code>:</p> <pre><code>pip install tripper\n</code></pre> <p>In addition you would need to install the requirements for one or more of the backends listed in the table above. For mappings you would also need to install Pint. For example:</p> <pre><code>pip install rdflib pint\n</code></pre>"},{"location":"#license-and-copyright","title":"License and copyright","text":"<p>All files in this repository are licensed under the MIT license. If not stated otherwise in the top of the files, they have copyright \u00a9 2022 SINTEF.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>We gratefully acknowledge the following projects for supporting the development of Tripper:</p> <ul> <li>OntoTrans (2020-2024) that receives funding from the European Union's Horizon 2020 Research and Innovation Programme, under Grant Agreement n. 862136.</li> <li>OpenModel (2021-2025) that receives funding from the European Union's Horizon 2020 Research and Innovation Programme, under Grant Agreement n. 953167.</li> <li>SFI PhysMet (2020-2028) funded by Forskningsr\u00e5det and Norwegian industry partners.</li> <li>DOME 4.0 (2021-2025) that receives funding from the European Union's Horizon 2020 Research and Innovation Programme, under Grant Agreement n. 953163.</li> <li>VIPCOAT (2021-2025) that receives funding from the European Union's Horizon 2020 Research and Innovation Programme, under Grant Agreement n. 952903.</li> <li>MEDIATE (2022-2025) that receives funding from the RCN, Norway; FNR, Luxenburg; SMWK Germany via the M-era.net programme, project 9557,</li> <li>MatCHMaker (2022-2026) that receives funding from the European Union's Horizon 2020 Research and Innovation Programme, under Grant Agreement n. 101091687.</li> </ul>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#unreleased-changes-2024-08-16","title":"Unreleased changes (2024-08-16)","text":"<p>Full Changelog</p> <p>Merged pull requests:</p> <ul> <li>Avoid that tripper.Namespace crashes if the cache directory cannot be accessed #235 (jesper-friis)</li> <li>[pre-commit.ci] pre-commit autoupdate #232 (pre-commit-ci[bot])</li> <li>[pre-commit.ci] pre-commit autoupdate #231 (pre-commit-ci[bot])</li> <li>Cleaned up backend tests #230 (jesper-friis)</li> <li>Added a fix for parsing rdflib literals. #229 (jesper-friis)</li> </ul>"},{"location":"CHANGELOG/#v030-2024-06-24","title":"v0.3.0 (2024-06-24)","text":"<p>Full Changelog</p> <p>Merged pull requests:</p> <ul> <li>Tutorial update #227 (jesper-friis)</li> <li>Get rid of the last warning in the tests #226 (jesper-friis)</li> <li>Get restrictions as dicts #225 (jesper-friis)</li> <li>[pre-commit.ci] pre-commit autoupdate #224 (pre-commit-ci[bot])</li> <li>Added an additional test for convert #223 (jesper-friis)</li> <li>Minor fix in tutorial #221 (jesper-friis)</li> <li>Updated the tutorial #220 (jesper-friis)</li> <li>Improved the handling of different return types from the query() method #219 (jesper-friis)</li> <li>Correct parsing literals from the rdflib backend. #217 (jesper-friis)</li> <li>Do not save cache while interpreter shotdown. #216 (jesper-friis)</li> <li>Allow string literal to compare equal to strings. #215 (jesper-friis)</li> <li>Also test for Python 3.12 #213 (jesper-friis)</li> </ul>"},{"location":"CHANGELOG/#v0216-2024-05-16","title":"v0.2.16 (2024-05-16)","text":"<p>Full Changelog</p> <p>Fixed bugs:</p> <ul> <li>cannot release #211</li> </ul> <p>Closed issues:</p> <ul> <li>Add caching and extension to tripper.Namespace #194</li> <li>Add support for adding and searching for restrictions #189</li> </ul> <p>Merged pull requests:</p> <ul> <li>In tripper.convert, commented out recognised keys for oteapi strategies #212 (jesper-friis)</li> <li>Use latest SINTEF/ci-cd version #210 (CasperWA)</li> <li>Allow prefix with digits #209 (jesper-friis)</li> <li>Added test for SPARQL CONSTRUCT query via tripper #207 (jesper-friis)</li> <li>Added more recognised keys to tripper.convert #206 (jesper-friis)</li> <li>[pre-commit.ci] pre-commit autoupdate #204 (pre-commit-ci[bot])</li> <li>Changed EMMO representation of function arguments from datasets to datum #203 (jesper-friis)</li> <li>Added comment suggested by Francesca #201 (jesper-friis)</li> <li>Enhanced the use of namespaces #195 (jesper-friis)</li> <li>Support for restrictions #190 (jesper-friis)</li> <li>Correctly convert rdflib bnodes back to tripper #187 (jesper-friis)</li> </ul>"},{"location":"CHANGELOG/#v0215-2024-03-12","title":"v0.2.15 (2024-03-12)","text":"<p>Full Changelog</p> <p>Closed issues:</p> <ul> <li>Documentation CD (still) fails due to old python version #193</li> <li>Publish workflow fails because it uses python 3.7 #191</li> <li>Allow untyped literals #182</li> <li>Search with ts.triples() doesn't recognise literals #179</li> <li>PyBackTrip - external tripper backends available #177</li> <li>Surprising literal comparisons #161</li> <li>Retain literal types in collection backend #160</li> <li>Document implemented backends  #157</li> </ul> <p>Merged pull requests:</p> <ul> <li>Loosen req on pint to include 0.23 (newest) #198 (francescalb)</li> <li>Use Python 3.9 in all CI/CD workflows #196 (CasperWA)</li> <li>Bump basic CI tests and CD to python 3.9 #192 (ajeklund)</li> <li>Cleaned up PR template #188 (jesper-friis)</li> <li>Bump mkdocs-material version for security #186 (ajeklund)</li> <li>Allow untyped literals #184 (jesper-friis)</li> <li>Added test for finding literal triples #183 (jesper-friis)</li> <li>Added reference to PyBackTrip #180 (jesper-friis)</li> <li>Added support for xsd:nonNegativeInteger literals #178 (jesper-friis)</li> <li>Added acknowledgements to readme file. #173 (jesper-friis)</li> <li>Retain literal types in collection backend #165 (jesper-friis)</li> <li>Improved comparing literals #164 (jesper-friis)</li> </ul>"},{"location":"CHANGELOG/#v0214-2024-01-25","title":"v0.2.14 (2024-01-25)","text":"<p>Full Changelog</p> <p>Closed issues:</p> <ul> <li>Literals are lost when listing triples with rdflib #162</li> <li>dependencies are too strict, at least for pint #149</li> <li>Function repo plugin system #128</li> </ul> <p>Merged pull requests:</p> <ul> <li>Retain datatype when listing literals from rdflib #163 (jesper-friis)</li> <li>Make it possible to expose an existing rdflib graph via tripper #156 (jesper-friis)</li> <li>Mapping function plugin system #152 (jesper-friis)</li> <li>Get rid of confusing UnusedArgumentWarning from working code #151 (jesper-friis)</li> </ul>"},{"location":"CHANGELOG/#v0213-2023-11-14","title":"v0.2.13 (2023-11-14)","text":"<p>Full Changelog</p> <p>Merged pull requests:</p> <ul> <li>Added UnknownUnitError #153 (jesper-friis)</li> </ul>"},{"location":"CHANGELOG/#v0212-2023-11-07","title":"v0.2.12 (2023-11-07)","text":"<p>Full Changelog</p> <p>Merged pull requests:</p> <ul> <li>Expand pint requirements to include more versions #150 (francescalb)</li> </ul>"},{"location":"CHANGELOG/#v0211-2023-10-30","title":"v0.2.11 (2023-10-30)","text":"<p>Full Changelog</p> <p>Merged pull requests:</p> <ul> <li>Added new section to README file #148 (jesper-friis)</li> </ul>"},{"location":"CHANGELOG/#v0210-2023-10-19","title":"v0.2.10 (2023-10-19)","text":"<p>Full Changelog</p> <p>Merged pull requests:</p> <ul> <li>Francescalb/testing dependencies #142 (francescalb)</li> <li>Clearified that tripper does not depend on DLite and Pydantic #136 (jesper-friis)</li> <li>Cleaned up mappings module #132 (jesper-friis)</li> </ul>"},{"location":"CHANGELOG/#v029-2023-09-29","title":"v0.2.9 (2023-09-29)","text":"<p>Full Changelog</p>"},{"location":"CHANGELOG/#v028-2023-09-12","title":"v0.2.8 (2023-09-12)","text":"<p>Full Changelog</p> <p>Merged pull requests:</p> <ul> <li>Added support for lists in tripper.convert #129 (jesper-friis)</li> </ul>"},{"location":"CHANGELOG/#v027-2023-08-29","title":"v0.2.7 (2023-08-29)","text":"<p>Full Changelog</p> <p>Fixed bugs:</p> <ul> <li>Fix issues related to renaming of the default branch #116</li> </ul> <p>Merged pull requests:</p> <ul> <li>Added a module for converting to/from dicts #126 (jesper-friis)</li> <li>Update dependabot after changing master branch to 'master' #121 (jesper-friis)</li> <li>Also run CI tests on examples in documentation #118 (jesper-friis)</li> </ul>"},{"location":"CHANGELOG/#v026-2023-06-23","title":"v0.2.6 (2023-06-23)","text":"<p>Full Changelog</p> <p>Closed issues:</p> <ul> <li>Add CI/CD tests for Python 3.11 #102</li> </ul> <p>Merged pull requests:</p> <ul> <li>One letter words where not allowed in mappings, now they are #117 (francescalb)</li> <li>pylint settings #115 (jesper-friis)</li> <li>Fix issue with entry points for Python 3.6 and 3.7 #113 (jesper-friis)</li> <li>Added DOI badge #109 (jesper-friis)</li> <li>Fixed parsing rdf:HTML literals with the rdflib backend #106 (jesper-friis)</li> <li>Support Python 3.11 #103 (jesper-friis)</li> <li>92 new triplestore subclass #99 (alfredoisg)</li> </ul>"},{"location":"CHANGELOG/#v025-2023-05-24","title":"v0.2.5 (2023-05-24)","text":"<p>Full Changelog</p>"},{"location":"CHANGELOG/#v024-2023-04-30","title":"v0.2.4 (2023-04-30)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Add entrypoint system to link external backend implementation #63</li> </ul> <p>Closed issues:</p> <ul> <li>Transformations based on data sources #90</li> <li>Add workflow example  #79</li> </ul> <p>Merged pull requests:</p> <ul> <li>Added argument <code>lang</code> to triplestore.value() #104 (jesper-friis)</li> <li>Run doctest from CI tests #101 (jesper-friis)</li> <li>Added add_data(), get_value() and add_interpolation_source() methods to Triplestore #91 (jesper-friis)</li> <li>Added tests for Python 3.11 and 3.6 #84 (jesper-friis)</li> <li>Remove some deprecation warnings #83 (jesper-friis)</li> <li>Workflow example #81 (jesper-friis)</li> <li>Support external backends #80 (jesper-friis)</li> </ul>"},{"location":"CHANGELOG/#v023-2023-02-05","title":"v0.2.3 (2023-02-05)","text":"<p>Full Changelog</p> <p>Closed issues:</p> <ul> <li>Add a to_yaml() method to MappingStep #66</li> </ul> <p>Merged pull requests:</p> <ul> <li>Add official support for Python 3.11 #82 (jesper-friis)</li> <li>added PR template #77 (alfredoisg)</li> </ul>"},{"location":"CHANGELOG/#v022-2023-01-30","title":"v0.2.2 (2023-01-30)","text":"<p>Full Changelog</p> <p>Fixed bugs:</p> <ul> <li>pre-commit failing hook installation #75</li> <li>ontopy backend failing tests #7</li> </ul> <p>Closed issues:</p> <ul> <li>Describe functions with EMMO instead of FnO #65</li> </ul> <p>Merged pull requests:</p> <ul> <li>Using isort 5.12.0 for pre-commit #76 (CasperWA)</li> <li>Visualise #74 (jesper-friis)</li> <li>Generate mapping routes from subclasses of Value and MappingStep #73 (jesper-friis)</li> <li>Fix deprecated calls syntax to Triplestore.triples() #71 (jesper-friis)</li> <li>Made the value optional + added some cleanup #70 (jesper-friis)</li> <li>Add map() method to Triplestore #69 (jesper-friis)</li> <li>Proper cost function #68 (jesper-friis)</li> <li>Updated Triplestore.add_function() to also support EMMO. #67 (jesper-friis)</li> <li>Added mappings #62 (jesper-friis)</li> </ul>"},{"location":"CHANGELOG/#v021-2022-12-18","title":"v0.2.1 (2022-12-18)","text":"<p>Full Changelog</p> <p>Closed issues:</p> <ul> <li>Simplify use of the Triplestore triples() and remove() methods #50</li> </ul> <p>Merged pull requests:</p> <ul> <li>Commented out __hash__() and __eq__() methods from Literal. #55 (jesper-friis)</li> <li>Simplify use of the Triplestore triples() and remove() methods #51 (jesper-friis)</li> <li>Separated <code>base_iri</code> argument from <code>triplestore_url</code> in rdflib backend #49 (jesper-friis)</li> </ul>"},{"location":"CHANGELOG/#v020-2022-12-13","title":"v0.2.0 (2022-12-13)","text":"<p>Full Changelog</p> <p>Fixed bugs:</p> <ul> <li>Deploy docs failing due to wrong dependency installation #53</li> </ul> <p>Closed issues:</p> <ul> <li>Remove backend packages from requirements #48</li> <li>Fix utils.parse_object()  #45</li> </ul> <p>Merged pull requests:</p> <ul> <li>Update <code>docs</code> extra #54 (CasperWA)</li> <li>Remove backend packages from requirements #52 (jesper-friis)</li> <li>Fix utils.parse_object() #46 (jesper-friis)</li> </ul>"},{"location":"CHANGELOG/#v012-2022-12-11","title":"v0.1.2 (2022-12-11)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>The return value of <code>query()</code> depends on the query #42</li> <li>Add DLite collection backend #41</li> <li>Implement create_database() and remove_database() methods #34</li> <li>SPARQLWrapper backend #10</li> <li>Refactor triplestore.py (triplestore module API) #3</li> </ul> <p>Closed issues:</p> <ul> <li>Revert to using the proper general version for SINTEF/ci-cd #35</li> <li>Write in type annotations #33</li> <li>Improve README file #18</li> <li>Add support for simple persistent storage in the rdflib backend #14</li> </ul> <p>Merged pull requests:</p> <ul> <li>Added collection backend #44 (jesper-friis)</li> <li>Fix return types #43 (CasperWA)</li> <li>Updated import statements in the tutorial #40 (jesper-friis)</li> <li>Added create_database() and remove_database() methods. #39 (jesper-friis)</li> <li>Use the proper version of SINTEF/ci-cd #36 (CasperWA)</li> <li>bumped ci-cd version to remove --strict mkdocs command #32 (daniel-sintef)</li> <li>3 refactor triplestorepy triplestore module api #31 (daniel-sintef)</li> <li>3 refactor triplestore #27 (jesper-friis)</li> <li>Corrected copyright #21 (jesper-friis)</li> <li>Add a useful description to README file. #19 (jesper-friis)</li> <li>Added support for simple persistent storage in the rdflib backend #15 (jesper-friis)</li> <li>sparqlwrapper backend #11 (jesper-friis)</li> <li>Documented return value of the Triplestore.query() and added a test for it #9 (jesper-friis)</li> </ul>"},{"location":"CHANGELOG/#v011-2022-10-13","title":"v0.1.1 (2022-10-13)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Change package name to <code>tripper</code> on PyPI #13</li> <li>Clean up newly initialized Python API #1</li> </ul> <p>Fixed bugs:</p> <ul> <li>Enable proper release workflow #8</li> <li>Fix workflows so they succeed #2</li> </ul> <p>Merged pull requests:</p> <ul> <li>Use the package name <code>tripper</code> (not <code>tripperpy</code>) #16 (CasperWA)</li> <li>Clean up repository &amp; fix workflows #5 (CasperWA)</li> <li>Added version number in __init__ to enable local pip install #4 (quaat)</li> </ul> <p>* This Changelog was automatically generated by github_changelog_generator</p>"},{"location":"LICENSE/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2022 SINTEF</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"backend_discovery/","title":"Discovery of custom backends","text":"<p>A tripper backend is a normal importable Python module that defines the class <code>{Name}Strategy</code>, where <code>{Name}</code> is the name of the backend with the first letter capitalized (as it would be with the <code>str.title()</code> method). The methods they are supposed to define are documented in tripper/interface.py.</p> <p>Tripper support several use cases for discovery of custom backends.</p>"},{"location":"backend_discovery/#installed-backend-package","title":"Installed backend package","text":"<p>It is possible to create a pip installable Python package that provides new tripper backends that will be automatically discovered.</p> <p>The backend package should add the following to its <code>pyproject.toml</code> file:</p> <pre><code>[project.entry-points.\"tripper.backends\"]\nmybackend1 = \"subpackage.mybackend1\"\nmybackend2 = \"subpackage.mybackend2\"\n</code></pre> <p>When your package is installed, this would make <code>mybackend1</code> and <code>mybackend2</code> automatically discovarable by tripper, such that you can write</p> <pre><code>&gt;&gt;&gt; from tripper import Triplestore\n&gt;&gt;&gt; ts = Triplestore(backend=\"mybackend1\")\n</code></pre>"},{"location":"backend_discovery/#backend-module","title":"Backend module","text":"<p>If you have a tripper backend that is specific to your application, or that you for some other reason don't want or feel the need to publish as a separate Python package, you can keep the backend as a module within your application.</p> <p>In this case you have two options, either specify explicitly backend module when you instantiate your triplestore or append your package to the <code>tripper.backend_packages</code> module variable:</p>"},{"location":"backend_discovery/#instantiate-triplestore-with-explicit-module-path","title":"Instantiate triplestore with explicit module path","text":"<p>An explicit module path can either be absolute or relative as shown in the example below:</p> <pre><code># Absolute\n&gt;&gt;&gt; ts = Triplestore(backend=\"mypackage.backends.mybackend\")\n\n# Relative to the `package` argument\n&gt;&gt;&gt; ts = Triplestore(backend=\"backends.mybackend\", package=\"mypackage\")\n</code></pre> <p>A backend is considered to be specified explicitly if the <code>backend</code> argument contain a dot (.) or if the <code>package</code> argument is provided.</p>"},{"location":"backend_discovery/#append-to-tripperbackend_packages","title":"Append to <code>tripper.backend_packages</code>","text":"<p>Finally you can insert/append the sub-package with your backend to the <code>tripper.backend_packages</code> list module variable:</p> <pre><code>import tripper\ntripper.backend_packages.append(\"mypackage.backends\")\nts = Triplestore(backend=\"mybackend\")\n</code></pre>"},{"location":"backend_discovery/#search-order-for-backends","title":"Search order for backends","text":"<p>Tripper backends are looked up in the following order: 1. explicit specified backend modules 2. backend packages 3. checking <code>tripper.backend_packages</code></p> <p>By default the built-in backends are looked up as the first element in <code>tripper.backend_packages</code> (but it is possible for the insert a custom backend sub-package before it). This means that backend packages are looked up before the built-in backends. Hence it is possible for a backend package to overwrite or extend a built-in backend.</p>"},{"location":"known-issues/","title":"Known issues","text":"<ul> <li>If you use the rdflib backend and don't have write permissions to   the cache directory (which e.g. can happen if you run Python in   docker as a non-root user), you may get a <code>urllib.error.HTTPError</code>   error when accessing an online rdf resource.</li> </ul> <p>Setting the environment variable <code>XDG_CACHE_HOME</code> to a directory   that you have write access to will solve the problem.</p>"},{"location":"planned-backends/","title":"Planned backends","text":"<p>In addition to the currently existing backends, the following additional backends may be supported in upcoming versions:</p> <ul> <li>Redland librdf</li> <li>Apache Jena Fuseki</li> <li>Allegrograph</li> <li>Wikidata</li> </ul>"},{"location":"tutorial/","title":"Basic tutorial","text":""},{"location":"tutorial/#introduction","title":"Introduction","text":"<p>Tripper is a Python library providing a common interface to a range of pre-defined triplestores. This is done via a plugin system for different triplestore <code>backends</code>. See the README file for a list of currently supported backends.</p> <p>The API provided by Tripper is modelled after rdflib, so if you know that library, you will find Tripper rather familiar. But there are some differences to be aware of. Most important are:</p> <ul> <li>All IRIs are represented by Python strings.   Example: <code>\"https://w3id.org/emmo#Metre\"</code></li> <li>Blank nodes are strings starting with \"_:\".   Example: <code>\"_:bnode1\"</code></li> <li>Literals are constructed with <code>tripper.Literal</code>.   Example: <code>tripper.Literal(3.14, datatype=XSD.float)</code></li> <li>Namespace object works similar to namespace objects in rdflib, but its   attribution access expands to plain Python strings.   Example: <code>XSD.float</code></li> </ul> <p>Tripper namespaces has also additional features that make them very   convinient when working with ontologies, like EMMO that uses   numerical IRIs.</p>"},{"location":"tutorial/#getting-started","title":"Getting started","text":"<p>To interface a triplestore, you create an instance of Triplestore providing the name of the triplestore as the <code>backend</code> argument.</p> <p>For example, to create an interface to an in-memory rdflib triplestore, you can use the <code>rdflib</code> backend:</p> <pre><code>&gt;&gt;&gt; from tripper import Triplestore\n&gt;&gt;&gt; ts = Triplestore(backend=\"rdflib\")\n</code></pre>"},{"location":"tutorial/#namespace-objects","title":"Namespace objects","text":"<p>Namespace objects are a very convenient feature that simplifies writing IRIs. Tripper provides a set of standard pre-defined namespaces that can simply be imported. For example:</p> <pre><code>&gt;&gt;&gt; from tripper import OWL, RDFS\n&gt;&gt;&gt; RDFS.subClassOf\n'http://www.w3.org/2000/01/rdf-schema#subClassOf'\n</code></pre> <p>New namespaces can be created using the Namespace class, but are usually added with the [<code>bind()</code>] method:</p> <pre><code>&gt;&gt;&gt; ONTO = ts.bind(\"onto\", \"http://example.com/onto#\")\n&gt;&gt;&gt; ONTO.MyConcept\n'http://example.com/onto#MyConcept'\n</code></pre>"},{"location":"tutorial/#adding-triples-to-the-triplestore","title":"Adding triples to the triplestore","text":"<p>Triples can now be added to the triplestore, using the [<code>add()</code>] and [<code>add_triples()</code>] methods:</p> <pre><code>&gt;&gt;&gt; from tripper.utils import en\n&gt;&gt;&gt; ts.add_triples([\n...     (ONTO.MyConcept, RDFS.subClassOf, OWL.Thing),\n...     (ONTO.MyConcept, RDFS.label, en(\"My briliant ontological concept.\")),\n... ])\n</code></pre> <p>The function [<code>en()</code>] is just a convenient function for adding English literals. It is equivalent to <code>tripper.Literal(msg, lang=\"en\")</code>.</p> <p>Triples can also be added from a source using the [<code>parse()</code>] method. For example will</p> <pre><code>ts.parse(\"onto.ttl\", format=\"turtle\")\n</code></pre> <p>load all triples in turtle file <code>onto.ttl</code> into the triplestore.</p> <p>Similarly, the triplestore can be serialised to a string or a file using the [<code>serialize()</code>] method:</p> <pre><code>ts.serialize(\"onto2.ttl\")  # serialise to file `onto2.ttl`\ns = ts.serialize(format=\"ntriples\")  # serialise to string s in ntriples format\n</code></pre>"},{"location":"tutorial/#retrieving-triples-from-and-querying-a-triplestore","title":"Retrieving triples from and querying a triplestore","text":"<p>A set of convenient functions exist for simple queries, including [<code>triples()</code>], [<code>subjects()</code>], [<code>predicates()</code>], [<code>objects()</code>], [<code>subject_predicates()</code>], [<code>subject_objects()</code>], [<code>predicate_objects()</code>] and [<code>value()</code>]. Except for [<code>value()</code>], they return iterators. For example:</p> <pre><code>&gt;&gt;&gt; ts.objects(subject=ONTO.MyConcept, predicate=RDFS.subClassOf)  # doctest: +ELLIPSIS\n&lt;generator object Triplestore.objects at 0x...&gt;\n\n&gt;&gt;&gt; list(ts.objects(subject=ONTO.MyConcept, predicate=RDFS.subClassOf))\n['http://www.w3.org/2002/07/owl#Thing']\n</code></pre> <p>The [<code>query()</code>] and [<code>update()</code>] methods can be used to query and update the triplestore using SPARQL. See the next section.</p>"},{"location":"tutorial/#slightly-more-advanced-features","title":"Slightly more advanced features","text":""},{"location":"tutorial/#more-advanced-use-of-namespaces","title":"More advanced use of namespaces","text":"<p>Namespace also supports access by label and IRI checking. Both of these features requires loading an ontology. The following example shows how to create an EMMO namespace with IRI checking. The keyword argument <code>label_annotations=True</code> enables access by <code>skos:prefLabel</code>, <code>rdfs:label</code> or <code>skos:altLabel</code>. What labels to use can also be specified explicitly. The <code>check=True</code> enables checking for existing IRIs.</p> <pre><code>&gt;&gt;&gt; EMMO = ts.bind(\n...     prefix=\"emmo\",\n...     namespace=\"https://w3id.org/emmo#\",\n...     label_annotations=True,\n...     check=True,\n... )\n\n# Access by label\n&gt;&gt;&gt; EMMO.Atom\n'https://w3id.org/emmo#EMMO_eb77076b_a104_42ac_a065_798b2d2809ad'\n\n# This fails because we set `check=True`\n&gt;&gt;&gt; EMMO.invalid_name  # doctest: +ELLIPSIS\nTraceback (most recent call last):\n    ...\ntripper.errors.NoSuchIRIError: https://w3id.org/emmo#invalid_name\nMaybe you have to remove the cache file: ...\n</code></pre> <p>The above example works, since the <code>namespace=\"https://w3id.org/emmo#\"</code> is resolvable. When the IRI in the <code>namespace</code> argument is not resolvable, it is possible to supply a resolvable IRI or a reference to a populated Triplestore instance via the <code>triplestore</code> keyword argument.</p> <p>Access by label makes it much easier to work with ontologies, like EMMO, that uses non-human readable IDs for the IRIs. More about this below.</p> <p>The utility function [<code>extend_namespace()</code>] can be used to add additional known labels to a namespace. For example:</p> <pre><code>&gt;&gt;&gt; from tripper import Namespace\n&gt;&gt;&gt; from tripper.utils import extend_namespace\n&gt;&gt;&gt; FOOD = Namespace(\n...     \"http://onto-ns.com/ontologies/examples/food#\",\n...     label_annotations=True,\n...     check=True,\n...     reload=True,\n...     triplestore=\"https://raw.githubusercontent.com/EMMC-ASBL/tripper/master/tests/ontologies/food.ttl\",\n...     format=\"turtle\",\n... )\n\n# Hamburger is not a known label\n&gt;&gt;&gt; FOOD.Hamburger  # doctest: +ELLIPSIS\nTraceback (most recent call last):\n    ...\ntripper.errors.NoSuchIRIError: http://onto-ns.com/ontologies/examples/food#Hamburger\n...\n\n# Add Hamburger to known labels\n&gt;&gt;&gt; extend_namespace(FOOD, {\"Hamburger\": FOOD + \"Hamburger\"})\n&gt;&gt;&gt; FOOD.Hamburger == FOOD + \"Hamburger\"\nTrue\n\n# Fish is not a known label\n&gt;&gt;&gt; FOOD.Fish  # doctest: +ELLIPSIS\nTraceback (most recent call last):\n    ...\ntripper.errors.NoSuchIRIError: http://onto-ns.com/ontologies/examples/food#Fish\n...\n\n# Extend FOOD from an online turtle file\n&gt;&gt;&gt; extend_namespace(\n...    FOOD,\n...    \"https://raw.githubusercontent.com/EMMC-ASBL/tripper/master/tests/ontologies/food-more.ttl\",\n...    format=\"turtle\",\n... )\n\n# Now Fish is in the namespace\n&gt;&gt;&gt; FOOD.Fish\n'http://onto-ns.com/ontologies/examples/food#FOOD_90f5dd54_9e5c_46c9_824f_e10625a90c26'\n</code></pre>"},{"location":"tutorial/#writing-sparql-queries-using-tripper","title":"Writing SPARQL queries using Tripper","text":"<p>A challenge with ontologies using numerical IRIs is that SPARQL queries become difficult to read and understand. This challenge is greatly mitigated by using the <code>label_annotations</code> feature of Tripper namespaces. The example below shows how to write and execute a SPARQL query with Tripper that finds the IRI and unit symbol of all length units. Note: 1. EMMO classes and properties are written as <code>{EMMO.LengthUnit}</code>, which would expand to <code>https://w3id.org/emmo#EMMO_b3600e73_3e05_479d_9714_c041c3acf5cc</code>. 2. The curly brackets after the <code>WHERE</code> clause have to be written <code>{{</code>, <code>}}</code> because the query is an f-string.</p> <pre><code># Load pre-inferred EMMO\n&gt;&gt;&gt; ts = Triplestore(\"rdflib\", base_iri=\"https://w3id.org/emmo#\")\n&gt;&gt;&gt; ts.parse(\"https://w3id.org/emmo#inferred\")\n\n# Bind \"emmo\" prefix to base_iri\n&gt;&gt;&gt; EMMO = ts.bind(\"emmo\", label_annotations=True, check=True)\n\n# Get IRI and symbol of all length units\n&gt;&gt;&gt; query = f\"\"\"\n... PREFIX owl:  &lt;http://www.w3.org/2002/07/owl#&gt;\n... PREFIX rdf:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;\n... PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;\n...\n... SELECT ?unit ?symbol\n... WHERE {{\n...   ?unit rdfs:subClassOf &lt;{EMMO.LengthUnit}&gt; .\n...   ?unit rdfs:subClassOf ?r .\n...   ?r rdf:type owl:Restriction .\n...   ?r owl:onProperty &lt;{EMMO.hasSymbolValue}&gt; .\n...   ?r owl:hasValue ?symbol .\n... }}\n... \"\"\"\n&gt;&gt;&gt; r = ts.query(query)\n&gt;&gt;&gt; (EMMO.Metre, \"m\") in r\nTrue\n</code></pre>"},{"location":"tutorial/#class-restrictions","title":"Class restrictions","text":"<p>When working with OWL ontologies, it is often required to inspect or add class restrictions. The Triplestore class has two convenient methods for this, that do not require knowledge about how restrictions are represented in RDF. Only support basic restrictions, without any nested logical constructs, are supoprted. For more advanced restrictions, we recommend to use EMMOntoPy or Owlready2.</p> <p>A restriction restricts a class to only those individuals that satisfy the restriction. It is described by the following set of parameters.</p> <ul> <li>cls: IRI of class to which the restriction applies.</li> <li>property: IRI of restriction property.</li> <li> <p>type: The type of the restriction.  Should be one of:</p> <ul> <li>some: existential restriction (target is a class IRI)</li> <li>only: universal restriction (target is a class IRI)</li> <li>exactly: cardinality restriction (target is a class IRI)</li> <li>min: minimum cardinality restriction (target is a class IRI)</li> <li>max: maximum cardinality restriction (target is a class IRI)</li> <li>value: Value restriction (target is an IRI of an individual or a literal)</li> </ul> </li> <li> <p>cardinality: the cardinality value for cardinality restrictions.</p> </li> <li>value: The IRI or literal value of the restriction target.</li> </ul> <p>As an example, the class <code>onto:Bacteria</code> can be logically restricted to be unicellular. In Manchester syntax, this can be stated as <code>onto:Bacteria emmo:hasPart exactly 1 onto:Cell</code>. With Tripper this can be stated as:</p> <p><pre><code>&gt;&gt;&gt; iri = ts.add_restriction(\n...     cls=ONTO.Bacteria,\n...     property=EMMO.hasPart,\n...     type=\"exactly\",\n...     cardinality=1,\n...     value=ONTO.Cell,\n... )\n</code></pre> The returned <code>iri</code> is the blank node IRI of the new restriction.</p> <p>To find the above restriction, the [<code>restrictions()</code>] method can be used. It returns an iterator over all restrictions that matches the provided criteria. For example:</p> <pre><code>&gt;&gt;&gt; g = ts.restrictions(cls=ONTO.Bacteria, property=EMMO.hasPart, asdict=True)\n&gt;&gt;&gt; list(g)  # doctest: +ELLIPSIS\n[{'iri': '_:...', 'cls': 'http://example.com/onto#Bacteria', 'property': 'https://w3id.org/emmo#EMMO_17e27c22_37e1_468c_9dd7_95e137f73e7f', 'type': 'exactly', 'cardinality': 1, 'value': 'http://example.com/onto#Cell'}]\n</code></pre> <p>With the <code>asdict</code> argument set to false, an iterator over the IRIs of all matching restrictions is returned:</p> <pre><code>&gt;&gt;&gt; g = ts.restrictions(cls=ONTO.Bacteria, property=EMMO.hasPart, asdict=False)\n&gt;&gt;&gt; next(g) == iri\nTrue\n</code></pre>"},{"location":"tutorial/#utilities","title":"Utilities","text":"<p>Todo: Describe the <code>tripper.utils</code> module</p>"},{"location":"tutorial/#specialised-features","title":"Specialised features","text":""},{"location":"tutorial/#working-with-mappings","title":"Working with mappings","text":"<p>With a data model, we here mean an abstract model that describes the structure of a dataset. To provide a shared semantic meaning of a data model and its properties (structural elements), one can create mappings between these elements and ontological concepts (typically a class in an OWL ontology).</p> <p>Mappings can also be used to semantically document the arguments and return values of a function.</p> <p>The Triplestore class has two specialised methods for adding mappings, [<code>map()</code>] and [<code>add_function()</code>]. The purpose of the [<code>map()</code>] method, is to map a data models and its properties to ontological concepts, while [<code>add_function()</code>] maps the arguments and return value of a function to ontological concepts.</p> <p>Note, the name of the [<code>map()</code>] and [<code>add_function()</code>] methods are not very intuitive and may be changed in the future.</p>"},{"location":"tutorial/#adding-mappings","title":"Adding mappings","text":"<p>Lets assume that you have a data model identified by the IRI <code>http://onto-ns.com/meta/ex/0.1/MyDataModel</code>, which has a property (structural element) called velocity. A namespace object for this data model can be created with</p> <pre><code>from tripper import Namespace\nDM = Namespace(\"http://onto-ns.com/meta/ex/0.1/MyDataModel#\")\n</code></pre> <p>and use to map the data model property <code>velocity</code> to the concept <code>ONTO.Velocity</code> in the ontology</p> <pre><code>ts.map(DM.velocity, ONTO.Velocity)\n</code></pre> <p>One can also work directly with DLite and SOFT7 data models. Here we repeat the above with DLite:</p> <pre><code>import dlite\nmymodel = dlite.get_instance(\"http://onto-ns.com/meta/ex/0.1/MyDataModel\")\nts.map(mymodel.velocity, ONTO.Velocity)\n</code></pre> <p>The <code>add_function()</code> method documents a Python function semantically and adds mappings for its arguments and return value(s). Currently, it supports both EMMO and the Function Ontology (FnO) for the semantic documentation.</p> <p>For example, to semantically document the general function <code>mean()</code> applied to the special context of arm lengths, one can do</p> <pre><code>def mean(x, y):\n    \"\"\"Returns the mean value of `x` and `y`.\"\"\"\n    return (x + y)/2\n\nts.add_function(\n    mean,\n    expects=(ONTO.RightArmLength, ONTO.LeftArmLength),\n    returns=ONTO.AverageArmLength,\n)\n</code></pre>"},{"location":"tutorial/#using-mappings","title":"Using mappings","text":"<p>Todo: Describe the <code>tripper.mappings</code> subpackage...</p>"},{"location":"api_reference/errors/","title":"errors","text":"<p>Exceptions and warnings for the triplestore package.</p>"},{"location":"api_reference/errors/#tripper.errors.ArgumentTypeError","title":"<code> ArgumentTypeError            (TriplestoreError, TypeError)         </code>","text":"<p>Invalid argument type.</p> Source code in <code>tripper/errors.py</code> <pre><code>class ArgumentTypeError(TriplestoreError, TypeError):\n    \"\"\"Invalid argument type.\"\"\"\n</code></pre>"},{"location":"api_reference/errors/#tripper.errors.ArgumentValueError","title":"<code> ArgumentValueError            (TriplestoreError, ValueError)         </code>","text":"<p>Invalid argument value (of correct type).</p> Source code in <code>tripper/errors.py</code> <pre><code>class ArgumentValueError(TriplestoreError, ValueError):\n    \"\"\"Invalid argument value (of correct type).\"\"\"\n</code></pre>"},{"location":"api_reference/errors/#tripper.errors.CannotGetFunctionError","title":"<code> CannotGetFunctionError            (TriplestoreError)         </code>","text":"<p>Not able to get function documented in the triplestore.</p> Source code in <code>tripper/errors.py</code> <pre><code>class CannotGetFunctionError(TriplestoreError):\n    \"\"\"Not able to get function documented in the triplestore.\"\"\"\n</code></pre>"},{"location":"api_reference/errors/#tripper.errors.NamespaceError","title":"<code> NamespaceError            (TriplestoreError)         </code>","text":"<p>Namespace error.</p> Source code in <code>tripper/errors.py</code> <pre><code>class NamespaceError(TriplestoreError):\n    \"\"\"Namespace error.\"\"\"\n</code></pre>"},{"location":"api_reference/errors/#tripper.errors.NoSuchIRIError","title":"<code> NoSuchIRIError            (NamespaceError)         </code>","text":"<p>Namespace has no such IRI.</p> Source code in <code>tripper/errors.py</code> <pre><code>class NoSuchIRIError(NamespaceError):\n    \"\"\"Namespace has no such IRI.\"\"\"\n</code></pre>"},{"location":"api_reference/errors/#tripper.errors.TriplestoreError","title":"<code> TriplestoreError            (Exception)         </code>","text":"<p>Base exception for triplestore errors.</p> Source code in <code>tripper/errors.py</code> <pre><code>class TriplestoreError(Exception):\n    \"\"\"Base exception for triplestore errors.\"\"\"\n</code></pre>"},{"location":"api_reference/errors/#tripper.errors.UniquenessError","title":"<code> UniquenessError            (TriplestoreError)         </code>","text":"<p>More than one matching triple.</p> Source code in <code>tripper/errors.py</code> <pre><code>class UniquenessError(TriplestoreError):\n    \"\"\"More than one matching triple.\"\"\"\n</code></pre>"},{"location":"api_reference/errors/#tripper.errors.UnusedArgumentWarning","title":"<code> UnusedArgumentWarning            (Warning)         </code>","text":"<p>Argument is unused.</p> Source code in <code>tripper/errors.py</code> <pre><code>class UnusedArgumentWarning(Warning):\n    \"\"\"Argument is unused.\"\"\"\n</code></pre>"},{"location":"api_reference/interface/","title":"interface","text":"<p>Provides the ITriplestore protocol class, that documents the interface of the triplestore backends.</p>"},{"location":"api_reference/interface/#tripper.interface.ITriplestore","title":"<code> ITriplestore            (Protocol)         </code>","text":"<p>Interface for triplestore backends.</p> <p>In addition to the methods specified by this interface, a backend may also implement the following optional methods:</p> <pre><code>def parse(\n        self,\n        source: Union[str, Path, IO] = None,\n        location: str = None,\n        data: str = None,\n        format: str = None,\n        **kwargs\n    ):\n    \"\"\"Parse source and add the resulting triples to triplestore.\n\n    The source is specified using one of `source`, `location` or `data`.\n\n    Arguments:\n        source: File-like object or file name.\n        location: String with relative or absolute URL to source.\n        data: String containing the data to be parsed.\n        format: Needed if format can not be inferred from source.\n        kwargs: Additional backend-specific parameters controlling\n            the parsing.\n    \"\"\"\n\ndef serialize(\n        self,\n        destination: Union[str, Path, IO] = None,\n        format: str ='xml',\n        **kwargs\n    ):\n    \"\"\"Serialise to destination.\n\n    Arguments:\n        destination: File name or object to write to.  If None, the\n            serialisation is returned.\n        format: Format to serialise as.  Supported formats, depends on\n            the backend.\n        kwargs: Additional backend-specific parameters controlling\n            the serialisation.\n\n    Returns:\n        Serialised string if `destination` is None.\n    \"\"\"\n\ndef query(self, query_object: str, **kwargs) -&gt; List[Tuple[str, ...]]:\n    \"\"\"SPARQL query.\n\n    Arguments:\n        query_object: String with the SPARQL query.\n        kwargs: Additional backend-specific keyword arguments.\n\n    Returns:\n        The return type depends on type of query:\n          - SELECT: list of tuples of IRIs for each matching row\n          - ASK: bool\n          - CONSTRUCT, DESCRIBE: generator over triples\n    \"\"\"\n\ndef update(self, update_object: str, **kwargs):\n    \"\"\"Update triplestore with SPARQL.\n\n    Arguments:\n        query_object: String with the SPARQL query.\n        kwargs: Additional backend-specific keyword arguments.\n\n    Note:\n        This method is intended for INSERT and DELETE queries.  Use\n        the query() method for SELECT queries.\n    \"\"\"\n\ndef bind(self, prefix: str, namespace: str) -&gt; Namespace:\n    \"\"\"Bind prefix to namespace.\n\n    Should only be defined if the backend supports namespaces.\n    \"\"\"\n\ndef namespaces(self) -&gt; dict:\n    \"\"\"Returns a dict mapping prefixes to namespaces.\n\n    Should only be defined if the backend supports namespaces.\n    Used by triplestore.parse() to get prefixes after reading\n    triples from an external source.\n    \"\"\"\n\n@classmethod\ndef create_database(cls, database: str, **kwargs):\n    \"\"\"Create a new database in backend.\n\n    Parameters:\n        database: Name of the new database.\n        kwargs: Keyword arguments passed to the backend\n            create_database() method.\n\n    Note:\n        This is a class method, which operates on the backend\n        triplestore without connecting to it.\n    \"\"\"\n\n@classmethod\ndef remove_database(cls, database: str, **kwargs):\n    \"\"\"Remove a database in backend.\n\n    Parameters:\n        database: Name of the database to be removed.\n        kwargs: Keyword arguments passed to the backend\n            remove_database() method.\n\n    Note:\n        This is a class method, which operates on the backend\n        triplestore without connecting to it.\n    \"\"\"\n\n@classmethod\ndef list_databases(cls, **kwargs):\n    \"\"\"For backends that supports multiple databases, list of all\n    databases.\n\n    Parameters:\n        kwargs: Keyword arguments passed to the backend\n            list_database() method.\n\n    Note:\n        This is a class method, which operates on the backend\n        triplestore without connecting to it.\n    \"\"\"\n</code></pre> Source code in <code>tripper/interface.py</code> <pre><code>class ITriplestore(Protocol):\n    '''Interface for triplestore backends.\n\n    In addition to the methods specified by this interface, a backend\n    may also implement the following optional methods:\n\n    ```python\n\n    def parse(\n            self,\n            source: Union[str, Path, IO] = None,\n            location: str = None,\n            data: str = None,\n            format: str = None,\n            **kwargs\n        ):\n        \"\"\"Parse source and add the resulting triples to triplestore.\n\n        The source is specified using one of `source`, `location` or `data`.\n\n        Arguments:\n            source: File-like object or file name.\n            location: String with relative or absolute URL to source.\n            data: String containing the data to be parsed.\n            format: Needed if format can not be inferred from source.\n            kwargs: Additional backend-specific parameters controlling\n                the parsing.\n        \"\"\"\n\n    def serialize(\n            self,\n            destination: Union[str, Path, IO] = None,\n            format: str ='xml',\n            **kwargs\n        ):\n        \"\"\"Serialise to destination.\n\n        Arguments:\n            destination: File name or object to write to.  If None, the\n                serialisation is returned.\n            format: Format to serialise as.  Supported formats, depends on\n                the backend.\n            kwargs: Additional backend-specific parameters controlling\n                the serialisation.\n\n        Returns:\n            Serialised string if `destination` is None.\n        \"\"\"\n\n    def query(self, query_object: str, **kwargs) -&gt; List[Tuple[str, ...]]:\n        \"\"\"SPARQL query.\n\n        Arguments:\n            query_object: String with the SPARQL query.\n            kwargs: Additional backend-specific keyword arguments.\n\n        Returns:\n            The return type depends on type of query:\n              - SELECT: list of tuples of IRIs for each matching row\n              - ASK: bool\n              - CONSTRUCT, DESCRIBE: generator over triples\n        \"\"\"\n\n    def update(self, update_object: str, **kwargs):\n        \"\"\"Update triplestore with SPARQL.\n\n        Arguments:\n            query_object: String with the SPARQL query.\n            kwargs: Additional backend-specific keyword arguments.\n\n        Note:\n            This method is intended for INSERT and DELETE queries.  Use\n            the query() method for SELECT queries.\n        \"\"\"\n\n    def bind(self, prefix: str, namespace: str) -&gt; Namespace:\n        \"\"\"Bind prefix to namespace.\n\n        Should only be defined if the backend supports namespaces.\n        \"\"\"\n\n    def namespaces(self) -&gt; dict:\n        \"\"\"Returns a dict mapping prefixes to namespaces.\n\n        Should only be defined if the backend supports namespaces.\n        Used by triplestore.parse() to get prefixes after reading\n        triples from an external source.\n        \"\"\"\n\n    @classmethod\n    def create_database(cls, database: str, **kwargs):\n        \"\"\"Create a new database in backend.\n\n        Parameters:\n            database: Name of the new database.\n            kwargs: Keyword arguments passed to the backend\n                create_database() method.\n\n        Note:\n            This is a class method, which operates on the backend\n            triplestore without connecting to it.\n        \"\"\"\n\n    @classmethod\n    def remove_database(cls, database: str, **kwargs):\n        \"\"\"Remove a database in backend.\n\n        Parameters:\n            database: Name of the database to be removed.\n            kwargs: Keyword arguments passed to the backend\n                remove_database() method.\n\n        Note:\n            This is a class method, which operates on the backend\n            triplestore without connecting to it.\n        \"\"\"\n\n    @classmethod\n    def list_databases(cls, **kwargs):\n        \"\"\"For backends that supports multiple databases, list of all\n        databases.\n\n        Parameters:\n            kwargs: Keyword arguments passed to the backend\n                list_database() method.\n\n        Note:\n            This is a class method, which operates on the backend\n            triplestore without connecting to it.\n        \"\"\"\n\n    ```\n    '''\n\n    def __init__(self, base_iri: \"Optional[str]\" = None, **kwargs):\n        \"\"\"Initialise triplestore.\n\n        Arguments:\n            base_iri: Optional base IRI to initiate the triplestore from.\n            kwargs: Additional keyword arguments passed to the backend.\n        \"\"\"\n\n    def triples(self, triple: \"Triple\") -&gt; \"Generator\":\n        \"\"\"Returns a generator over matching triples.\n\n        Arguments:\n            triple: A `(s, p, o)` tuple where `s`, `p` and `o` should\n                either be None (matching anything) or an exact IRI to\n                match.\n        \"\"\"\n\n    def add_triples(self, triples: \"Sequence[Triple]\"):\n        \"\"\"Add a sequence of triples.\n\n        Arguments:\n            triples: A sequence of `(s, p, o)` tuples to add to the\n                triplestore.\n        \"\"\"\n\n    def remove(self, triple: \"Triple\"):\n        \"\"\"Remove all matching triples from the backend.\"\"\"\n</code></pre>"},{"location":"api_reference/interface/#tripper.interface.ITriplestore.add_triples","title":"<code>add_triples(self, triples)</code>","text":"<p>Add a sequence of triples.</p> <p>Parameters:</p> Name Type Description Default <code>triples</code> <code>Sequence[Triple]</code> <p>A sequence of <code>(s, p, o)</code> tuples to add to the triplestore.</p> required Source code in <code>tripper/interface.py</code> <pre><code>def add_triples(self, triples: \"Sequence[Triple]\"):\n    \"\"\"Add a sequence of triples.\n\n    Arguments:\n        triples: A sequence of `(s, p, o)` tuples to add to the\n            triplestore.\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interface/#tripper.interface.ITriplestore.remove","title":"<code>remove(self, triple)</code>","text":"<p>Remove all matching triples from the backend.</p> Source code in <code>tripper/interface.py</code> <pre><code>def remove(self, triple: \"Triple\"):\n    \"\"\"Remove all matching triples from the backend.\"\"\"\n</code></pre>"},{"location":"api_reference/interface/#tripper.interface.ITriplestore.triples","title":"<code>triples(self, triple)</code>","text":"<p>Returns a generator over matching triples.</p> <p>Parameters:</p> Name Type Description Default <code>triple</code> <code>Triple</code> <p>A <code>(s, p, o)</code> tuple where <code>s</code>, <code>p</code> and <code>o</code> should either be None (matching anything) or an exact IRI to match.</p> required Source code in <code>tripper/interface.py</code> <pre><code>def triples(self, triple: \"Triple\") -&gt; \"Generator\":\n    \"\"\"Returns a generator over matching triples.\n\n    Arguments:\n        triple: A `(s, p, o)` tuple where `s`, `p` and `o` should\n            either be None (matching anything) or an exact IRI to\n            match.\n    \"\"\"\n</code></pre>"},{"location":"api_reference/literal/","title":"literal","text":"<p>Literal rdf values.</p>"},{"location":"api_reference/literal/#tripper.literal.Literal","title":"<code> Literal            (str)         </code>","text":"<p>A literal RDF value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[datetime, bytes, bytearray, bool, int, float, str]</code> <p>The literal value. See the <code>datatypes</code> class attribute for valid supported data types.  A localised string is provided as a string with <code>lang</code> set to a language code.</p> required <code>lang</code> <code>Optional[str]</code> <p>A standard language code, like \"en\", \"no\", etc. Implies that the <code>value</code> is a localised string.</p> required <code>datatype</code> <code>Any</code> <p>Explicit specification of the type of <code>value</code>. Should not be combined with <code>lang</code>.</p> required Source code in <code>tripper/literal.py</code> <pre><code>class Literal(str):\n    \"\"\"A literal RDF value.\n\n    Arguments:\n        value (Union[datetime, bytes, bytearray, bool, int, float, str]):\n            The literal value. See the `datatypes` class attribute for valid\n            supported data types.  A localised string is provided as a string\n            with `lang` set to a language code.\n        lang (Optional[str]): A standard language code, like \"en\", \"no\", etc.\n            Implies that the `value` is a localised string.\n        datatype (Any): Explicit specification of the type of `value`. Should\n            not be combined with `lang`.\n    \"\"\"\n\n    lang: \"Union[str, None]\"\n    datatype: \"Any\"\n\n    # Note that the order of datatypes matters - it is used by\n    # utils.parse_literal() when inferring the datatype of a literal.\n    datatypes = {\n        datetime: (XSD.dateTime,),\n        bytes: (XSD.hexBinary, XSD.base64Binary),\n        bytearray: (XSD.hexBinary, XSD.base64Binary),\n        bool: (XSD.boolean,),\n        int: (\n            XSD.integer,\n            XSD.int,\n            XSD.short,\n            XSD.long,\n            XSD.nonNegativeInteger,\n            XSD.nonPositiveInteger,\n            XSD.negativeInteger,\n            XSD.unsignedInt,\n            XSD.unsignedShort,\n            XSD.unsignedLong,\n            XSD.byte,\n            XSD.unsignedByte,\n        ),\n        float: (\n            XSD.double,\n            XSD.decimal,\n            XSD.dateTimeStamp,\n            XSD.real,\n            XSD.rational,\n        ),\n        str: (\n            XSD.string,\n            RDFS.Literal,\n            RDF.PlainLiteral,\n            RDF.HTML,\n            RDF.JSON,\n            RDF.XMLLiteral,\n            RDF.langString,\n            XSD.NCName,\n            XSD.NMTOKEN,\n            XSD.Name,\n            XSD.anyURI,\n            XSD.language,\n            XSD.normalizedString,\n            XSD.token,\n        ),\n    }\n\n    def __new__(\n        cls,\n        value: \"Union[datetime, bytes, bytearray, bool, int, float, str]\",\n        lang: \"Optional[str]\" = None,\n        datatype: \"Optional[Any]\" = None,\n    ):\n        # pylint: disable=too-many-branches\n        string = super().__new__(cls, value)\n        string.lang = None\n        string.datatype = None\n\n        # Get lang\n        if lang:\n            if datatype:\n                raise TypeError(\n                    \"A literal can only have one of `lang` or `datatype`.\"\n                )\n            string.lang = str(lang)\n\n        # Get datatype\n        elif datatype in cls.datatypes:\n            string.datatype = cls.datatypes[datatype][0]\n        elif datatype:\n            # Create canonical representation of value for\n            # given datatype\n            val = None\n            for typ, names in cls.datatypes.items():\n                for name in names:\n                    if name == datatype:\n                        try:\n                            val = typ(value)\n                            break\n                        except:  # pylint: disable=bare-except\n                            pass  # nosec\n                    if val:\n                        break\n            if val is not None:\n                # Re-initialize the value anew, similarly to what is done in\n                # the first line of this method.\n                string = super().__new__(cls, val)\n                string.lang = None\n\n            string.datatype = datatype\n\n        # Infer datatype from value\n        elif isinstance(value, Literal):\n            string.lang = value.lang\n            string.datatype = value.datatype\n        elif isinstance(value, str):\n            string.datatype = None\n        elif isinstance(value, bool):\n            string.datatype = XSD.boolean\n        elif isinstance(value, int):\n            string.datatype = XSD.integer\n        elif isinstance(value, float):\n            string.datatype = XSD.double\n        elif isinstance(value, (bytes, bytearray)):\n            # Re-initialize the value anew, similarly to what is done in\n            # the first line of this method.\n            string = super().__new__(cls, value.hex())\n            string.lang = None\n            string.datatype = XSD.hexBinary\n        elif isinstance(value, datetime):\n            string.datatype = XSD.dateTime\n\n        # Some consistency checking\n        if (\n            string.datatype == XSD.nonPositiveInteger\n            and int(value) &gt; 0  # type: ignore[arg-type]\n        ):\n            raise TypeError(f\"not a xsd:nonPositiveInteger: '{string}'\")\n        if (\n            string.datatype == XSD.nonNegativeInteger\n            and int(value) &lt; 0  # type: ignore[arg-type]\n        ):\n            raise TypeError(f\"not a xsd:nonNegativeInteger: '{string}'\")\n        if (\n            string.datatype\n            in (\n                XSD.unsignedInt,\n                XSD.unsignedShort,\n                XSD.unsignedLong,\n                XSD.unsignedByte,\n            )\n            and int(value) &lt; 0  # type: ignore[arg-type]\n        ):\n            raise TypeError(f\"not an unsigned integer: '{string}'\")\n\n        # Check if datatype is known\n        if string.datatype and not any(\n            string.datatype in types for types in cls.datatypes.values()\n        ):\n            warnings.warn(\n                f\"unknown datatype: {string.datatype} - assuming xsd:string\"\n            )\n\n        return string\n\n    def __hash__(self):\n        return hash((str(self), self.lang, self.datatype))\n\n    def __eq__(self, other):  # pylint: disable=too-many-return-statements\n        if not isinstance(other, Literal):\n            if isinstance(other, str) and (\n                self.lang or self.datatype in self.datatypes[str]\n            ):\n                return str(self) == other\n            other = Literal(other)\n        if str(self) != str(other):\n            return False\n        if self.lang and other.lang and self.lang != other.lang:\n            return False\n        if (\n            self.datatype\n            and other.datatype\n            and self.datatype != other.datatype\n        ):\n            return False\n        strings = set(self.datatypes[str] + (None,))\n        if self.datatype is None and other.datatype not in strings:\n            return False\n        if other.datatype is None and self.datatype not in strings:\n            return False\n        return True\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __repr__(self) -&gt; str:\n        lang = f\", lang='{self.lang}'\" if self.lang else \"\"\n        datatype = f\", datatype='{self.datatype}'\" if self.datatype else \"\"\n        return f\"Literal('{self}'{lang}{datatype})\"\n\n    value = property(\n        fget=lambda self: self.to_python(),\n        doc=\"Appropriate python datatype derived from this RDF literal.\",\n    )\n\n    def to_python(self):\n        \"\"\"Returns an appropriate python datatype derived from this RDF\n        literal.\"\"\"\n        value = str(self)\n\n        if self.datatype == XSD.boolean:\n            value = False if str(self) == \"False\" else bool(self)\n        elif self.datatype in self.datatypes[int]:\n            value = int(self)\n        elif self.datatype in self.datatypes[float]:\n            value = float(self)\n        elif self.datatype == XSD.dateTime:\n            value = datetime.fromisoformat(self)\n\n        return value\n\n    def n3(self) -&gt; str:  # pylint: disable=invalid-name\n        \"\"\"Returns a representation in n3 format.\"\"\"\n        if self.lang:\n            return f'\"{self}\"@{self.lang}'\n        if self.datatype:\n            return f'\"{self}\"^^&lt;{self.datatype}&gt;'\n        return f'\"{self}\"'\n</code></pre>"},{"location":"api_reference/literal/#tripper.literal.Literal.value","title":"<code>value</code>  <code>property</code> <code>readonly</code>","text":"<p>Appropriate python datatype derived from this RDF literal.</p>"},{"location":"api_reference/literal/#tripper.literal.Literal.__new__","title":"<code>__new__(cls, value, lang=None, datatype=None)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>Create and return a new object.  See help(type) for accurate signature.</p> Source code in <code>tripper/literal.py</code> <pre><code>def __new__(\n    cls,\n    value: \"Union[datetime, bytes, bytearray, bool, int, float, str]\",\n    lang: \"Optional[str]\" = None,\n    datatype: \"Optional[Any]\" = None,\n):\n    # pylint: disable=too-many-branches\n    string = super().__new__(cls, value)\n    string.lang = None\n    string.datatype = None\n\n    # Get lang\n    if lang:\n        if datatype:\n            raise TypeError(\n                \"A literal can only have one of `lang` or `datatype`.\"\n            )\n        string.lang = str(lang)\n\n    # Get datatype\n    elif datatype in cls.datatypes:\n        string.datatype = cls.datatypes[datatype][0]\n    elif datatype:\n        # Create canonical representation of value for\n        # given datatype\n        val = None\n        for typ, names in cls.datatypes.items():\n            for name in names:\n                if name == datatype:\n                    try:\n                        val = typ(value)\n                        break\n                    except:  # pylint: disable=bare-except\n                        pass  # nosec\n                if val:\n                    break\n        if val is not None:\n            # Re-initialize the value anew, similarly to what is done in\n            # the first line of this method.\n            string = super().__new__(cls, val)\n            string.lang = None\n\n        string.datatype = datatype\n\n    # Infer datatype from value\n    elif isinstance(value, Literal):\n        string.lang = value.lang\n        string.datatype = value.datatype\n    elif isinstance(value, str):\n        string.datatype = None\n    elif isinstance(value, bool):\n        string.datatype = XSD.boolean\n    elif isinstance(value, int):\n        string.datatype = XSD.integer\n    elif isinstance(value, float):\n        string.datatype = XSD.double\n    elif isinstance(value, (bytes, bytearray)):\n        # Re-initialize the value anew, similarly to what is done in\n        # the first line of this method.\n        string = super().__new__(cls, value.hex())\n        string.lang = None\n        string.datatype = XSD.hexBinary\n    elif isinstance(value, datetime):\n        string.datatype = XSD.dateTime\n\n    # Some consistency checking\n    if (\n        string.datatype == XSD.nonPositiveInteger\n        and int(value) &gt; 0  # type: ignore[arg-type]\n    ):\n        raise TypeError(f\"not a xsd:nonPositiveInteger: '{string}'\")\n    if (\n        string.datatype == XSD.nonNegativeInteger\n        and int(value) &lt; 0  # type: ignore[arg-type]\n    ):\n        raise TypeError(f\"not a xsd:nonNegativeInteger: '{string}'\")\n    if (\n        string.datatype\n        in (\n            XSD.unsignedInt,\n            XSD.unsignedShort,\n            XSD.unsignedLong,\n            XSD.unsignedByte,\n        )\n        and int(value) &lt; 0  # type: ignore[arg-type]\n    ):\n        raise TypeError(f\"not an unsigned integer: '{string}'\")\n\n    # Check if datatype is known\n    if string.datatype and not any(\n        string.datatype in types for types in cls.datatypes.values()\n    ):\n        warnings.warn(\n            f\"unknown datatype: {string.datatype} - assuming xsd:string\"\n        )\n\n    return string\n</code></pre>"},{"location":"api_reference/literal/#tripper.literal.Literal.n3","title":"<code>n3(self)</code>","text":"<p>Returns a representation in n3 format.</p> Source code in <code>tripper/literal.py</code> <pre><code>def n3(self) -&gt; str:  # pylint: disable=invalid-name\n    \"\"\"Returns a representation in n3 format.\"\"\"\n    if self.lang:\n        return f'\"{self}\"@{self.lang}'\n    if self.datatype:\n        return f'\"{self}\"^^&lt;{self.datatype}&gt;'\n    return f'\"{self}\"'\n</code></pre>"},{"location":"api_reference/literal/#tripper.literal.Literal.to_python","title":"<code>to_python(self)</code>","text":"<p>Returns an appropriate python datatype derived from this RDF literal.</p> Source code in <code>tripper/literal.py</code> <pre><code>def to_python(self):\n    \"\"\"Returns an appropriate python datatype derived from this RDF\n    literal.\"\"\"\n    value = str(self)\n\n    if self.datatype == XSD.boolean:\n        value = False if str(self) == \"False\" else bool(self)\n    elif self.datatype in self.datatypes[int]:\n        value = int(self)\n    elif self.datatype in self.datatypes[float]:\n        value = float(self)\n    elif self.datatype == XSD.dateTime:\n        value = datetime.fromisoformat(self)\n\n    return value\n</code></pre>"},{"location":"api_reference/namespace/","title":"namespace","text":"<p>Provides a simple representation of namespaces.</p>"},{"location":"api_reference/namespace/#tripper.namespace.Namespace","title":"<code> Namespace        </code>","text":"<p>Represent a namespace.</p> <p>Parameters:</p> Name Type Description Default <code>iri</code> <code>str</code> <p>IRI of namespace to represent.</p> required <code>label_annotations</code> <code>Sequence</code> <p>Sequence of label annotations. If given, check the underlying ontology during attribute access if the name correspond to a label. The label annotations should be ordered from highest to lowest precedense. If True is provided, <code>label_annotations</code> is set to <code>(SKOS.prefLabel, RDF.label, SKOS.altLabel)</code>.</p> <code>()</code> <code>check</code> <code>bool</code> <p>Whether to check underlying ontology if the IRI exists during attribute access.  If true, NoSuchIRIError will be raised if the IRI does not exist in this namespace.</p> <code>False</code> <code>reload</code> <code>Optional[bool]</code> <p>Whether to reload the ontology (which is needed when <code>label_annotations</code> or <code>check</code> are given) disregardless whether it has been cached locally.</p> <code>None</code> <code>triplestore</code> <code>Optional[Union[Triplestore, str]]</code> <p>Use this triplestore for label lookup and checking. Can be either a Triplestore object or an URL to load from. Defaults to <code>iri</code>.</p> <code>None</code> <code>format</code> <code>Optional[str]</code> <p>Format to use when loading from a triplestore.</p> <code>None</code> <code>cachemode</code> <code>int</code> <p>Deprecated. Use <code>reload</code> instead (with <code>cachemode=NO_CACHE</code> corresponding to <code>reload=True</code>).</p> <code>-1</code> <code>triplestore_url</code> <code>Optional[str]</code> <p>Deprecated. Use the <code>triplestore</code> argument instead.</p> <code>None</code> Source code in <code>tripper/namespace.py</code> <pre><code>class Namespace:\n    \"\"\"Represent a namespace.\n\n    Arguments:\n        iri: IRI of namespace to represent.\n        label_annotations: Sequence of label annotations. If given, check\n            the underlying ontology during attribute access if the name\n            correspond to a label. The label annotations should be ordered\n            from highest to lowest precedense.\n            If True is provided, `label_annotations` is set to\n            ``(SKOS.prefLabel, RDF.label, SKOS.altLabel)``.\n        check: Whether to check underlying ontology if the IRI exists during\n            attribute access.  If true, NoSuchIRIError will be raised if the\n            IRI does not exist in this namespace.\n        reload: Whether to reload the ontology (which is needed when\n            `label_annotations` or `check` are given) disregardless whether it\n            has been cached locally.\n        triplestore: Use this triplestore for label lookup and checking.\n            Can be either a Triplestore object or an URL to load from.\n            Defaults to `iri`.\n        format: Format to use when loading from a triplestore.\n        cachemode: Deprecated. Use `reload` instead (with `cachemode=NO_CACHE`\n            corresponding to `reload=True`).\n        triplestore_url: Deprecated. Use the `triplestore` argument instead.\n    \"\"\"\n\n    __slots__ = (\n        \"_iri\",  # Ontology IRI\n        \"_label_annotations\",  # Recognised annotations for labels\n        \"_check\",  # Whether to check that IRIs exists\n        \"_iris\",  # Dict mapping labels to IRIs\n    )\n\n    def __init__(\n        self,\n        iri: str,\n        label_annotations: \"Sequence\" = (),\n        check: bool = False,\n        reload: \"Optional[bool]\" = None,\n        triplestore: \"Optional[Union[Triplestore, str]]\" = None,\n        format: \"Optional[str]\" = None,\n        cachemode: int = -1,\n        triplestore_url: \"Optional[str]\" = None,\n    ):\n        # pylint: disable=redefined-builtin\n        if cachemode != -1:\n            warnings.warn(\n                \"The `cachemode` argument of Triplestore.__init__() is \"\n                \"deprecated.  Use `reload` instead (with `cachemode=NO_CACHE` \"\n                \"corresponding to `reload=True`).\\n\\n\"\n                \"Will be removed in v0.3.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            if reload is None and cachemode == 0:\n                reload = True\n\n        if triplestore_url:\n            warnings.warn(\n                \"The `triplestore_url` argument of Triplestore.__init__() is \"\n                \"deprecated.  Use the `triplestore` argument instead (which \"\n                \"now accepts a string argument with the URL).\\n\\n\"\n                \"Will be removed in v0.3.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            if triplestore is None:\n                triplestore = triplestore_url\n\n        if label_annotations is True:\n            label_annotations = (SKOS.prefLabel, RDF.label, SKOS.altLabel)\n\n        need_triplestore = bool(check or label_annotations)\n\n        self._iri = str(iri)\n        self._label_annotations = (\n            tuple(label_annotations) if label_annotations else ()\n        )\n        self._check = bool(check)\n        self._iris: \"Optional[dict]\" = {} if need_triplestore else None\n\n        if need_triplestore:\n            self._update_iris(triplestore, reload=reload, format=format)\n\n    def _update_iris(self, triplestore=None, reload=False, format=None):\n        \"\"\"Update the internal cache from `triplestore`.\n\n        If `reload` is true, reload regardless we have a local cache.\n        \"\"\"\n        # pylint: disable=redefined-builtin\n\n        # Import Triplestore here to avoid cyclic import\n        from .triplestore import (  # pylint: disable=import-outside-toplevel,cyclic-import\n            Triplestore,\n        )\n\n        if not reload and self._load_cache():\n            return\n\n        if triplestore is None:\n            triplestore = self._iri\n\n        if isinstance(triplestore, (str, Path)):\n            # Ignore UnusedArgumentWarning when creating triplestore\n            with warnings.catch_warnings():\n                warnings.simplefilter(\"ignore\", category=UnusedArgumentWarning)\n                ts = Triplestore(\"rdflib\")\n            ts.parse(triplestore, format=format)\n        elif isinstance(triplestore, Triplestore):\n            ts = triplestore\n        elif not isinstance(triplestore, Triplestore):\n            raise NamespaceError(\n                \"If given, `triplestore` argument must be either a URL \"\n                \"(string), Path or a Triplestore object.\"\n            )\n\n        # Add (label, full_iri) pairs\n        iri = self._iri.rstrip(\"/#\")\n        for label in reversed(self._label_annotations):\n            self._iris.update(\n                (getattr(o, \"value\", o), s)\n                for s, o in ts.subject_objects(label)\n                if s.startswith(iri)\n            )\n\n        # Add (name, full_iri) pairs\n        self._iris.update(\n            (s[len(self._iri) :], s)\n            for s in ts.subjects()\n            if s.startswith(iri)\n        )\n\n    def _get_cachefile(self) -&gt; Path:\n        \"\"\"Return path to cache file for this namespace.\"\"\"\n        # pylint: disable=too-many-function-args\n        name = self._iri.rstrip(\"#/\").rsplit(\"/\", 1)[-1]\n        hashno = hashlib.shake_128(self._iri.encode()).hexdigest(5)\n        return get_cachedir() / f\"{name}-{hashno}.cache\"\n\n    def _save_cache(self):\n        \"\"\"Save current cache.\"\"\"\n        # pylint: disable=invalid-name\n        try:\n            cachefile = self._get_cachefile()\n            if self._iris and not sys.is_finalizing():\n                with open(cachefile, \"wb\") as f:\n                    pickle.dump(self._iris, f)\n        except OSError as exc:\n            warnings.warn(\n                f\"Cannot access cache file: {exc}\\n\\n\"\n                \"You can select cache directory with the XDG_CACHE_HOME \"\n                \"environment variable.\"\n            )\n\n    def _load_cache(self) -&gt; bool:\n        \"\"\"Update cache with cache file.\n\n        Returns true if there exists a cache file to load from.\n        \"\"\"\n        # pylint: disable=invalid-name\n        try:\n            cachefile = self._get_cachefile()\n            if self._iris is None:\n                self._iris = {}\n            if cachefile.exists():\n                with open(cachefile, \"rb\") as f:\n                    self._iris.update(pickle.load(f))  # nosec\n                return True\n            return False\n        except OSError as exc:\n            warnings.warn(\n                f\"Cannot create cache directory: {exc}\\n\\n\"\n                \"You can select cache directory with the XDG_CACHE_HOME \"\n                \"environment variable.\"\n            )\n            return False\n\n    def __getattr__(self, name):\n        if self._iris and name in self._iris:\n            return self._iris[name]\n        if self._check:\n            msg = \"\"\n            try:\n                cachefile = self._get_cachefile()\n                if cachefile.exists():\n                    msg = (\n                        \"\\nMaybe you have to remove the cache file: \"\n                        f\"{cachefile}\"\n                    )\n            except OSError as exc:\n                warnings.warn(\n                    f\"Cannot access cache file: {exc}\\n\\n\"\n                    \"You can select cache directory with the XDG_CACHE_HOME \"\n                    \"environment variable.\"\n                )\n            raise NoSuchIRIError(self._iri + name + msg)\n        return self._iri + name\n\n    def __getitem__(self, key):\n        return self.__getattr__(key)\n\n    def __repr__(self):\n        return f\"Namespace('{self._iri}')\"\n\n    def __str__(self):\n        return self._iri\n\n    def __add__(self, other):\n        return self._iri + str(other)\n\n    def __hash__(self):\n        return hash(self._iri)\n\n    def __eq__(self, other):\n        return self._iri == str(other)\n\n    def __del__(self):\n        if self._iris:\n            self._save_cache()\n</code></pre>"},{"location":"api_reference/namespace/#tripper.namespace.get_cachedir","title":"<code>get_cachedir(create=True)</code>","text":"<p>Returns cross-platform path to tripper cache directory.</p> <p>If <code>create</code> is true, create the cache directory if it doesn't exists.</p> <p>The XDG_CACHE_HOME environment variable is used if it exists.</p> Source code in <code>tripper/namespace.py</code> <pre><code>def get_cachedir(create=True) -&gt; Path:\n    \"\"\"Returns cross-platform path to tripper cache directory.\n\n    If `create` is true, create the cache directory if it doesn't exists.\n\n    The XDG_CACHE_HOME environment variable is used if it exists.\n    \"\"\"\n    site_cachedir = os.getenv(\"XDG_CACHE_HOME\")\n    finaldir = None\n    if not site_cachedir:\n        if sys.platform.startswith(\"win32\"):\n            site_cachedir = Path.home() / \"AppData\" / \"Local\"\n            finaldir = \"Cache\"\n        elif sys.platform.startswith(\"darwin\"):\n            site_cachedir = Path.home() / \"Library\" / \"Caches\"\n        else:  # Default to UNIX\n            site_cachedir = Path.home() / \".cache\"  # type: ignore\n    cachedir = Path(site_cachedir) / \"tripper\"  # type: ignore\n    if finaldir:\n        cachedir /= finaldir\n\n    if create:\n        path = Path(cachedir.root)\n        for part in cachedir.parts[1:]:\n            path /= part\n            if not path.exists():\n                path.mkdir()\n\n    return cachedir\n</code></pre>"},{"location":"api_reference/testutils/","title":"testutils","text":"<p>Motule primarly intended to be imported by tests.</p> <p>It defines some directories and some utility functions that can be used with or without conftest.</p>"},{"location":"api_reference/triplestore/","title":"triplestore","text":"<p>A module encapsulating different triplestores using the strategy design pattern.</p> <p>See https://raw.githubusercontent.com/EMMC-ASBL/tripper/master/README.md for an introduction and for a table over available backends.</p> <p>This module has no dependencies outside the standard library, but the triplestore backends may have.</p> <p>For developers: The usage of <code>s</code>, <code>p</code>, and <code>o</code> represent the different parts of an RDF Triple: subject, predicate, and object.</p>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore","title":"<code> Triplestore        </code>","text":"<p>Provides a common frontend to a range of triplestore backends.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>class Triplestore:\n    \"\"\"Provides a common frontend to a range of triplestore backends.\"\"\"\n\n    default_namespaces = {\n        \"xml\": XML,\n        \"rdf\": RDF,\n        \"rdfs\": RDFS,\n        \"xsd\": XSD,\n        \"owl\": OWL,\n        # \"skos\": SKOS,\n        # \"dcat\": DCAT,\n        # \"dc\": DC,\n        # \"dcterms\": DCTERMS,\n        # \"foaf\": FOAF,\n        # \"doap\": DOAP,\n        # \"fno\": FNO,\n        # \"emmo\": EMMO,\n        # \"map\": MAP,\n        # \"dm\": DM,\n    }\n\n    def __init__(\n        self,\n        backend: str,\n        base_iri: \"Optional[str]\" = None,\n        database: \"Optional[str]\" = None,\n        package: \"Optional[str]\" = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Initialise triplestore using the backend with the given name.\n\n        Parameters:\n            backend: Name of the backend module.\n\n                For built-in backends or backends provided via a\n                backend package (using entrypoints), this should just\n                be the name of the backend with no dots (ex: \"rdflib\").\n\n                For a custom backend, you can provide the full module name,\n                including the dots (ex:\"mypackage.mybackend\").  If `package`\n                is given, `backend` is interpreted relative to `package`\n                (ex: ..mybackend).\n\n                For a list over available backends, see\n                https://github.com/EMMC-ASBL/tripper#available-backends\n\n            base_iri: Base IRI used by the add_function() method when adding\n                new triples. May also be used by the backend.\n            database: Name of database to connect to (for backends that\n                supports it).\n            package: Required when `backend` is a relative module.  In that\n                case, it is relative to `package`.\n            kwargs: Keyword arguments passed to the backend's __init__()\n                method.\n\n        \"\"\"\n        backend_name = backend.rsplit(\".\", 1)[-1]\n        module = self._load_backend(backend, package)\n        cls = getattr(module, f\"{backend_name.title()}Strategy\")\n        self.base_iri = base_iri\n        self.namespaces: \"Dict[str, Namespace]\" = {}\n        self.closed = False\n        self.backend_name = backend_name\n        self.backend = cls(base_iri=base_iri, database=database, **kwargs)\n\n        # Cache functions in the triplestore for fast access\n        self.function_repo: \"Dict[str, Union[float, Callable, None]]\" = {}\n\n        for prefix, namespace in self.default_namespaces.items():\n            self.bind(prefix, namespace)\n\n    @classmethod\n    def _load_backend(cls, backend: str, package: \"Optional[str]\" = None):\n        \"\"\"Load and return backend module.  The arguments has the same meaning\n        as corresponding arguments to __init__().\n\n        If `backend` contains a dot or `package` is given, import `backend`\n        using `package` for relative imports.\n\n        Otherwise, if there in the \"tripper.backends\" entry point group exists\n        an entry point who's name matches `backend`, then the corresponding\n        module is loaded.\n\n        Otherwise, look for the `backend` in any of the (sub)packages listed\n        `backend_packages` module variable.\n        \"\"\"\n        # Explicitly specified backend\n        if \".\" in backend or package:\n            return importlib.import_module(backend, package)\n\n        # Installed backend package\n        if sys.version_info &lt; (3, 10):\n            # Fallback for Python &lt; 3.10\n            eps = entry_points().get(\"tripper.backends\", ())\n        else:\n            # New entry_point interface from Python 3.10+\n            eps = entry_points(  # pylint: disable=unexpected-keyword-arg\n                group=\"tripper.backends\"\n            )\n        for entry_point in eps:\n            if entry_point.name == backend:\n                return importlib.import_module(entry_point.module)\n\n        # Backend module\n        for pack in backend_packages:\n            try:\n                return importlib.import_module(f\"{pack}.{backend}\")\n            except ModuleNotFoundError:\n                pass\n\n        raise ModuleNotFoundError(\n            f\"No tripper backend named '{backend}'\",\n            name=backend,\n        )\n\n    # Methods implemented by backend\n    # ------------------------------\n    def triples(  # pylint: disable=redefined-builtin\n        self,\n        subject: \"Optional[Union[str, Triple]]\" = None,\n        predicate: \"Optional[str]\" = None,\n        object: \"Optional[Union[str, Literal]]\" = None,\n        triple: \"Optional[Triple]\" = None,\n    ) -&gt; \"Generator[Triple, None, None]\":\n        \"\"\"Returns a generator over matching triples.\n\n        Arguments:\n            subject: If given, match triples with this subject.\n            predicate: If given, match triples with this predicate.\n            object: If given, match triples with this object.\n            triple: Deprecated. A `(s, p, o)` tuple where `s`, `p` and `o`\n                should either be None (matching anything) or an exact IRI\n                to match.\n\n        Returns:\n            Generator over all matching triples.\n        \"\"\"\n        # __TODO__: Remove these lines when deprecated\n        if triple or (subject and not isinstance(subject, str)):\n            warnings.warn(\n                \"The `triple` argument is deprecated.  Use `subject`, \"\n                \"`predicate` and `object` arguments instead.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n        if subject and not isinstance(subject, str):\n            subject, predicate, object = subject\n        elif triple:\n            subject, predicate, object = triple\n\n        return self.backend.triples((subject, predicate, object))\n\n    def add_triples(\n        self, triples: \"Union[Sequence[Triple], Generator[Triple, None, None]]\"\n    ):\n        \"\"\"Add a sequence of triples.\n\n        Arguments:\n            triples: A sequence of `(s, p, o)` tuples to add to the\n                triplestore.\n        \"\"\"\n        self.backend.add_triples(triples)\n\n    def remove(  # pylint: disable=redefined-builtin\n        self,\n        subject: \"Optional[Union[str, Triple]]\" = None,\n        predicate: \"Optional[str]\" = None,\n        object: \"Optional[Union[str, Literal]]\" = None,\n        triple: \"Optional[Triple]\" = None,\n    ) -&gt; None:\n        \"\"\"Remove all matching triples from the backend.\n\n        Arguments:\n            subject: If given, match triples with this subject.\n            predicate: If given, match triples with this predicate.\n            object: If given, match triples with this object.\n            triple: Deprecated. A `(s, p, o)` tuple where `s`, `p` and `o`\n                should either be None (matching anything) or an exact IRI\n                to match.\n        \"\"\"\n        # __TODO__: Remove these lines when deprecated\n        if triple or (subject and not isinstance(subject, str)):\n            warnings.warn(\n                \"The `triple` argument is deprecated.  Use `subject`, \"\n                \"`predicate` and `object` arguments instead.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n        if subject and not isinstance(subject, str):\n            subject, predicate, object = subject\n        elif triple:\n            subject, predicate, object = triple\n\n        return self.backend.remove((subject, predicate, object))\n\n    # Methods optionally implemented by backend\n    # -----------------------------------------\n    def close(self):\n        \"\"\"Calls the backend close() method if it is implemented.\n        Otherwise, this method has no effect.\n        \"\"\"\n        # It should be ok to call close() regardless of whether the backend\n        # implements this method or not.  Hence, don't call _check_method().\n        if not self.closed and hasattr(self.backend, \"close\"):\n            self.backend.close()\n        self.closed = True\n\n    def parse(\n        self,\n        source=None,\n        format=None,\n        fallback_backend=\"rdflib\",\n        fallback_backend_kwargs=None,\n        **kwargs,  # pylint: disable=redefined-builtin\n    ) -&gt; None:\n        \"\"\"Parse source and add the resulting triples to triplestore.\n\n        Parameters:\n            source: File-like object or file name.\n            format: Needed if format can not be inferred from source.\n            fallback_backend: If the current backend doesn't implement\n                parse, use the `fallback_backend` instead.\n            fallback_backend_kwargs: Dict with additional keyword arguments\n                for initialising `fallback_backend`.\n            kwargs: Keyword arguments passed to the backend.\n                The rdflib backend supports e.g. `location` (absolute\n                or relative URL) and `data` (string containing the\n                data to be parsed) arguments.\n        \"\"\"\n        if hasattr(self.backend, \"parse\"):\n            self._check_method(\"parse\")\n            self.backend.parse(source=source, format=format, **kwargs)\n        else:\n            if fallback_backend_kwargs is None:\n                fallback_backend_kwargs = {}\n            ts = Triplestore(\n                backend=fallback_backend, **fallback_backend_kwargs\n            )\n            ts.parse(source=source, format=format, **kwargs)\n            self.add_triples(ts.triples())\n\n        if hasattr(self.backend, \"namespaces\"):\n            for prefix, namespace in self.backend.namespaces().items():\n                if prefix and prefix not in self.namespaces:\n                    self.namespaces[prefix] = Namespace(namespace)\n\n    def serialize(\n        self,\n        destination=None,\n        format=\"turtle\",  # pylint: disable=redefined-builtin\n        fallback_backend=\"rdflib\",\n        fallback_backend_kwargs=None,\n        **kwargs,\n    ) -&gt; \"Union[None, str]\":\n        \"\"\"Serialise triplestore.\n\n        Parameters:\n            destination: File name or object to write to.  If None, the\n                serialisation is returned.\n            format: Format to serialise as.  Supported formats, depends on\n                the backend.\n            fallback_backend: If the current backend doesn't implement\n                serialisation, use the `fallback_backend` instead.\n            fallback_backend_kwargs: Dict with additional keyword arguments\n                for initialising `fallback_backend`.\n            kwargs: Passed to the backend serialize() method.\n\n        Returns:\n            Serialized string if `destination` is None.\n        \"\"\"\n        if hasattr(self.backend, \"parse\"):\n            self._check_method(\"serialize\")\n            return self.backend.serialize(\n                destination=destination, format=format, **kwargs\n            )\n\n        if fallback_backend_kwargs is None:\n            fallback_backend_kwargs = {}\n        ts = Triplestore(backend=fallback_backend, **fallback_backend_kwargs)\n        ts.add_triples(self.triples())\n        for prefix, iri in self.namespaces.items():\n            ts.bind(prefix, iri)\n        return ts.serialize(destination=destination, format=format, **kwargs)\n\n    def query(\n        self, query_object, **kwargs\n    ) -&gt; \"Union[List[Tuple[str, ...]], bool, Generator[Triple, None, None]]\":\n        \"\"\"SPARQL query.\n\n        Parameters:\n            query_object: String with the SPARQL query.\n            kwargs: Keyword arguments passed to the backend query() method.\n\n        Returns:\n            The return type depends on type of query:\n              - SELECT: list of tuples of IRIs for each matching row\n              - ASK: bool\n              - CONSTRUCT, DESCRIBE: generator over triples\n\n        Note:\n            This method is intended for SELECT, ASK, CONSTRUCT and\n            DESCRIBE queries.  Use the update() method for INSERT and\n            DELETE queries.\n\n            Not all backends may support all types of queries.\n\n        \"\"\"\n        self._check_method(\"query\")\n        return self.backend.query(query_object=query_object, **kwargs)\n\n    def update(self, update_object, **kwargs) -&gt; None:\n        \"\"\"Update triplestore with SPARQL.\n\n        Parameters:\n            update_object: String with the SPARQL query.\n            kwargs: Keyword arguments passed to the backend update() method.\n\n        Note:\n            This method is intended for INSERT and DELETE queries. Use\n            the query() method for SELECT, ASK, CONSTRUCT and DESCRIBE queries.\n\n        \"\"\"\n        self._check_method(\"update\")\n        return self.backend.update(update_object=update_object, **kwargs)\n\n    def bind(  # pylint: disable=inconsistent-return-statements\n        self,\n        prefix: str,\n        namespace: \"Union[str, Namespace, Triplestore, None]\" = \"\",\n        **kwargs,\n    ) -&gt; Namespace:\n        \"\"\"Bind prefix to namespace and return the new Namespace object.\n\n        Parameters:\n            prefix: Prefix to bind the the namespace.\n            namespace: Namespace to bind to.  The default is to bind to the\n                `base_iri` of the current triplestore.\n                If `namespace` is None, the corresponding prefix is removed.\n            kwargs: Keyword arguments are passed to the Namespace()\n                constructor.\n\n        Returns:\n            New Namespace object or None if namespace is removed.\n        \"\"\"\n        if namespace == \"\":\n            namespace = self\n\n        if isinstance(namespace, str):\n            ns = Namespace(namespace, **kwargs)\n        elif isinstance(namespace, Triplestore):\n            if not namespace.base_iri:\n                raise ValueError(\n                    f\"triplestore object {namespace} has no `base_iri`\"\n                )\n            ns = Namespace(namespace.base_iri, **kwargs)\n        elif isinstance(namespace, Namespace):\n            # pylint: disable=protected-access\n            ns = Namespace(namespace._iri, **kwargs)\n        elif namespace is None:\n            del self.namespaces[prefix]\n            return  # type: ignore\n        else:\n            raise TypeError(f\"invalid `namespace` type: {type(namespace)}\")\n\n        if hasattr(self.backend, \"bind\"):\n            self.backend.bind(\n                prefix, ns._iri  # pylint: disable=protected-access\n            )\n\n        self.namespaces[prefix] = ns\n        return ns\n\n    @classmethod\n    def create_database(cls, backend: str, database: str, **kwargs):\n        \"\"\"Create a new database in backend.\n\n        Parameters:\n            backend: Name of backend.\n            database: Name of the new database.\n            kwargs: Keyword arguments passed to the backend\n                create_database() method.\n\n        Note:\n            This is a class method, which operates on the backend\n            triplestore without connecting to it.\n        \"\"\"\n        cls._check_backend_method(backend, \"create_database\")\n        backend_class = cls._get_backend(backend)\n        return backend_class.create_database(database=database, **kwargs)\n\n    @classmethod\n    def remove_database(cls, backend: str, database: str, **kwargs):\n        \"\"\"Remove a database in backend.\n\n        Parameters:\n            backend: Name of backend.\n            database: Name of the database to be removed.\n            kwargs: Keyword arguments passed to the backend\n                remove_database() method.\n\n        Note:\n            This is a class method, which operates on the backend\n            triplestore without connecting to it.\n        \"\"\"\n        cls._check_backend_method(backend, \"remove_database\")\n        backend_class = cls._get_backend(backend)\n        return backend_class.remove_database(database=database, **kwargs)\n\n    @classmethod\n    def list_databases(cls, backend: str, **kwargs):\n        \"\"\"For backends that supports multiple databases, list of all\n        databases.\n\n        Parameters:\n            backend: Name of backend.\n            kwargs: Keyword arguments passed to the backend\n                list_databases() method.\n\n        Note:\n            This is a class method, which operates on the backend\n            triplestore without connecting to it.\n        \"\"\"\n        cls._check_backend_method(backend, \"list_databases\")\n        backend_class = cls._get_backend(backend)\n        return backend_class.list_databases(**kwargs)\n\n    # Convenient methods\n    # ------------------\n    # These methods are modelled after rdflib and provide some convinient\n    # interfaces to the triples(), add_triples() and remove() methods\n    # implemented by all backends.\n\n    @classmethod\n    def _get_backend(cls, backend: str, package: \"Optional[str]\" = None):\n        \"\"\"Returns the class implementing the given backend.\"\"\"\n        module = cls._load_backend(backend, package=package)\n        return getattr(module, f\"{backend.title()}Strategy\")\n\n    @classmethod\n    def _check_backend_method(cls, backend: str, name: str):\n        \"\"\"Checks that `backend` has a method called `name`.\n\n        Raises NotImplementedError if it hasn't.\n        \"\"\"\n        backend_class = cls._get_backend(backend)\n        if not hasattr(backend_class, name):\n            raise NotImplementedError(\n                f\"Triplestore backend {backend!r} do not implement a \"\n                f'\"{name}()\" method.'\n            )\n\n    def _check_method(self, name):\n        \"\"\"Check that backend implements the given method.\"\"\"\n        self._check_backend_method(self.backend_name, name)\n\n    def add(self, triple: \"Triple\"):\n        \"\"\"Add `triple` to triplestore.\"\"\"\n        self.add_triples([triple])\n\n    def value(  # pylint: disable=redefined-builtin\n        self,\n        subject=None,\n        predicate=None,\n        object=None,\n        default=None,\n        any=False,\n        lang=None,\n    ) -&gt; \"Union[str, Literal]\":\n        \"\"\"Return the value for a pair of two criteria.\n\n        Useful if one knows that there may only be one value.\n        Two of `subject`, `predicate` or `object` must be provided.\n\n        Parameters:\n            subject: Possible criteria to match.\n            predicate: Possible criteria to match.\n            object: Possible criteria to match.\n            default: Value to return if no matches are found.\n            any: If true, return any matching value, otherwise raise\n                UniquenessError.\n            lang: If provided, require that the value must be a localised\n                literal with the given language code.\n\n        Returns:\n            The value of the `subject`, `predicate` or `object` that is\n            None.\n        \"\"\"\n        spo = (subject, predicate, object)\n        if sum(iri is None for iri in spo) != 1:\n            raise ValueError(\n                \"Exactly one of `subject`, `predicate` or `object` must be \"\n                \"None.\"\n            )\n\n        # Index of subject-predicate-object argument that is None\n        (idx,) = [i for i, v in enumerate(spo) if v is None]\n\n        triples = self.triples(subject, predicate, object)\n        if lang:\n            first = None\n            if idx != 2:\n                raise ValueError(\"`object` must be None if `lang` is given\")\n            for triple in triples:\n                value = triple[idx]\n                if isinstance(value, Literal) and value.lang == lang:\n                    if any:\n                        return value\n                    if first:\n                        raise UniquenessError(\"More than one match\")\n                    first = value\n            if first is None:\n                return default\n        else:\n            try:\n                triple = next(triples)\n            except StopIteration:\n                return default\n\n        try:\n            next(triples)\n        except StopIteration:\n            return triple[idx]\n\n        if any:\n            return triple[idx]\n        raise UniquenessError(\"More than one match\")\n\n    def subjects(\n        self, predicate=None, object=None  # pylint: disable=redefined-builtin\n    ):\n        \"\"\"Returns a generator of subjects for given predicate and object.\"\"\"\n        for s, _, _ in self.triples(predicate=predicate, object=object):\n            yield s\n\n    def predicates(\n        self, subject=None, object=None  # pylint: disable=redefined-builtin\n    ):\n        \"\"\"Returns a generator of predicates for given subject and object.\"\"\"\n        for _, p, _ in self.triples(subject=subject, object=object):\n            yield p\n\n    def objects(self, subject=None, predicate=None):\n        \"\"\"Returns a generator of objects for given subject and predicate.\"\"\"\n        for _, _, o in self.triples(subject=subject, predicate=predicate):\n            yield o\n\n    def subject_predicates(\n        self, object=None\n    ):  # pylint: disable=redefined-builtin\n        \"\"\"Returns a generator of (subject, predicate) tuples for given\n        object.\"\"\"\n        for s, p, _ in self.triples(object=object):\n            yield s, p\n\n    def subject_objects(self, predicate=None):\n        \"\"\"Returns a generator of (subject, object) tuples for given\n        predicate.\"\"\"\n        for s, _, o in self.triples(predicate=predicate):\n            yield s, o\n\n    def predicate_objects(self, subject=None):\n        \"\"\"Returns a generator of (predicate, object) tuples for given\n        subject.\"\"\"\n        for _, p, o in self.triples(subject=subject):\n            yield p, o\n\n    def set(self, triple):\n        \"\"\"Convenience method to update the value of object.\n\n        Removes any existing triples for subject and predicate before adding\n        the given `triple`.\n        \"\"\"\n        s, p, _ = triple\n        self.remove(s, p)\n        self.add(triple)\n\n    def has(\n        self, subject=None, predicate=None, object=None\n    ):  # pylint: disable=redefined-builtin\n        \"\"\"Returns true if the triplestore has any triple matching\n        the give subject, predicate and/or object.\"\"\"\n        triple = self.triples(\n            subject=subject, predicate=predicate, object=object\n        )\n        try:\n            next(triple)\n        except StopIteration:\n            return False\n        return True\n\n    # Methods providing additional functionality\n    # ------------------------------------------\n    def expand_iri(self, iri: str):\n        \"\"\"Return the full IRI if `iri` is prefixed.  Otherwise `iri` is\n        returned.\"\"\"\n        match = re.match(_MATCH_PREFIXED_IRI, iri)\n        if match:\n            prefix, name = match.groups()\n            if prefix not in self.namespaces:\n                raise NamespaceError(f\"unknown namespace: {prefix}\")\n            return f\"{self.namespaces[prefix]}{name}\"\n        return iri\n\n    def prefix_iri(self, iri: str, require_prefixed: bool = False):\n        \"\"\"Return prefixed IRI.\n\n        This is the reverse of expand_iri().\n\n        If `require_prefixed` is true, a NamespaceError exception is raised\n        if no prefix can be found.\n        \"\"\"\n        if not re.match(_MATCH_PREFIXED_IRI, iri):\n            for prefix, namespace in self.namespaces.items():\n                if iri.startswith(str(namespace)):\n                    return f\"{prefix}:{iri[len(str(namespace)):]}\"\n            if require_prefixed:\n                raise NamespaceError(f\"No prefix defined for IRI: {iri}\")\n        return iri\n\n    # Types of restrictions defined in OWL\n    _restriction_types = {\n        \"some\": (OWL.someValueFrom, None),\n        \"only\": (OWL.allValueFrom, None),\n        \"exactly\": (OWL.onClass, OWL.qualifiedCardinality),\n        \"min\": (OWL.onClass, OWL.minQualifiedCardinality),\n        \"max\": (OWL.onClass, OWL.maxQualifiedCardinality),\n        \"value\": (OWL.hasValue, None),\n    }\n\n    def add_restriction(  # pylint: disable=redefined-builtin\n        self,\n        cls: str,\n        property: str,\n        value: \"Union[str, Literal]\",\n        type: \"RestrictionType\",\n        cardinality: \"Optional[int]\" = None,\n        hashlength: int = 16,\n    ) -&gt; str:\n        \"\"\"Add a restriction to a class in the triplestore.\n\n        Parameters:\n            cls: IRI of class to which the restriction applies.\n            property: IRI of restriction property.\n            value: The IRI or literal value of the restriction target.\n            type: The type of the restriction.  Should be one of:\n                - some: existential restriction (value is a class IRI)\n                - only: universal restriction (value is a class IRI)\n                - exactly: cardinality restriction (value is a class IRI)\n                - min: minimum cardinality restriction (value is a class IRI)\n                - max: maximum cardinality restriction (value is a class IRI)\n                - value: Value restriction (value is an IRI of an individual\n                  or a literal)\n\n            cardinality: the cardinality value for cardinality restrictions.\n            hashlength: Number of bytes in the hash part of the bnode IRI.\n\n        Returns:\n            The IRI of the created blank node representing the restriction.\n        \"\"\"\n        iri = bnode_iri(\n            prefix=\"restriction\",\n            source=f\"{cls} {property} {value} {type} {cardinality}\",\n            length=hashlength,\n        )\n        triples = [\n            (cls, RDFS.subClassOf, iri),\n            (iri, RDF.type, OWL.Restriction),\n            (iri, OWL.onProperty, property),\n        ]\n        if type not in self._restriction_types:\n            raise ArgumentValueError(\n                '`type` must be one of: \"some\", \"only\", \"exactly\", \"min\", '\n                '\"max\" or \"value\"'\n            )\n        pred, card = self._restriction_types[type]\n        triples.append((iri, pred, value))\n        if card:\n            if not cardinality:\n                raise ArgumentTypeError(\n                    f\"`cardinality` must be provided for type='{type}'\"\n                )\n            triples.append(\n                (\n                    iri,\n                    card,\n                    Literal(cardinality, datatype=XSD.nonNegativeInteger),\n                ),\n            )\n\n        self.add_triples(triples)\n        return iri\n\n    def restrictions(  # pylint: disable=redefined-builtin\n        self,\n        cls: \"Optional[str]\" = None,\n        property: \"Optional[str]\" = None,\n        value: \"Optional[Union[str, Literal]]\" = None,\n        type: \"Optional[RestrictionType]\" = None,\n        cardinality: \"Optional[int]\" = None,\n        asdict: bool = True,\n    ) -&gt; \"Generator[Triple, None, None]\":\n        # pylint: disable=too-many-boolean-expressions\n        \"\"\"Returns a generator over matching restrictions.\n\n        Parameters:\n            cls: IRI of class to which the restriction applies.\n            property: IRI of restriction property.\n            value: The IRI or literal value of the restriction target.\n            type: The type of the restriction.  Should be one of:\n                - some: existential restriction (value is a class IRI)\n                - only: universal restriction (value is a class IRI)\n                - exactly: cardinality restriction (value is a class IRI)\n                - min: minimum cardinality restriction (value is a class IRI)\n                - max: maximum cardinality restriction (value is a class IRI)\n                - value: Value restriction (value is an IRI of an individual\n                  or a literal)\n\n            cardinality: the cardinality value for cardinality restrictions.\n            asdict: Whether to returned generator is over dicts (see\n                _get_restriction_dict()). Default is to return a generator\n                over blank node IRIs.\n\n        Returns:\n            A generator over matching restrictions.  See `asdict` argument\n            for types iterated over.\n        \"\"\"\n        if type is None:\n            types = set(self._restriction_types.keys())\n        elif type not in self._restriction_types:\n            raise ArgumentValueError(\n                f\"Invalid `type='{type}'`, it must be one of: \"\n                f\"{', '.join(self._restriction_types.keys())}.\"\n            )\n        else:\n            types = {type} if isinstance(type, str) else set(type)\n\n        if isinstance(value, Literal):\n            types.intersection_update({\"value\"})\n        elif isinstance(value, str):\n            types.difference_update({\"value\"})\n\n        if cardinality:\n            types.intersection_update({\"exactly\", \"min\", \"max\"})\n        if not types:\n            raise ArgumentValueError(\n                f\"Inconsistent type='{type}', value='{value}' and \"\n                f\"cardinality='{cardinality}' arguments\"\n            )\n        pred = {self._restriction_types[t][0] for t in types}\n        card = {\n            self._restriction_types[t][1]\n            for t in types\n            if self._restriction_types[t][1]\n        }\n\n        if cardinality:\n            lcard = Literal(cardinality, datatype=XSD.nonNegativeInteger)\n\n        for iri in self.subjects(predicate=OWL.onProperty, object=property):\n            if (\n                self.has(iri, RDF.type, OWL.Restriction)\n                and (not cls or self.has(cls, RDFS.subClassOf, iri))\n                and any(self.has(iri, p, value) for p in pred)\n                and (\n                    not card\n                    or not cardinality\n                    or any(self.has(iri, c, lcard) for c in card)\n                )\n            ):\n                yield self._get_restriction_dict(iri) if asdict else iri\n\n    def _get_restriction_dict(self, iri):\n        \"\"\"Return a dict describing restriction with `iri`.\n\n        The returned dict has the following keys:\n        - iri: (str) IRI of the restriction itself (blank node).\n        - cls: (str) IRI of class to which the restriction applies.\n        - property: (str) IRI of restriction property\n        - type: (str) One of: \"some\", \"only\", \"exactly\", \"min\", \"max\", \"value\".\n        - cardinality: (int) Restriction cardinality (optional).\n        - value: (str|Literal) IRI or literal value of the restriction target.\n        \"\"\"\n        dct = dict(self.predicate_objects(iri))\n        if OWL.onClass in dct:\n            ((t, p, c),) = [\n                (t, p, c)\n                for t, (p, c) in self._restriction_types.items()\n                if c in dct\n            ]\n        else:\n            ((t, p, c),) = [\n                (t, p, c)\n                for t, (p, c) in self._restriction_types.items()\n                if p in dct\n            ]\n        return {\n            \"iri\": iri,\n            \"cls\": self.value(predicate=RDFS.subClassOf, object=iri),\n            \"property\": dct[OWL.onProperty],\n            \"type\": t,\n            \"cardinality\": int(dct[c]) if c else None,\n            \"value\": dct[p],\n        }\n\n    def map(\n        self,\n        source: str,\n        target: str,\n        cost: \"Optional[Union[float, Callable]]\" = None,\n        target_cost: bool = True,\n    ):\n        \"\"\"Add 'mapsTo' relation to the triplestore.\n\n        Parameters:\n            source: Source IRI.\n            target: IRI of target ontological concept.\n            cost: User-defined cost of following this mapping relation\n                represented as a float.  It may be given either as a\n                float or as a callable taking three arguments\n\n                    cost(triplestore, input_iris, output_iri)\n\n                and returning the cost as a float.\n            target_cost: Whether the cost is assigned to mapping steps\n                that have `target` as output.\n        \"\"\"\n        return self.add_mapsTo(\n            target=target,\n            source=source,\n            cost=cost,\n            target_cost=target_cost,\n        )\n\n    def add_mapsTo(\n        self,\n        target: str,\n        source: str,\n        property_name: \"Optional[str]\" = None,\n        cost: \"Optional[Union[float, Callable]]\" = None,\n        target_cost: bool = True,\n    ):\n        \"\"\"Add 'mapsTo' relation to triplestore.\n\n        Parameters:\n            target: IRI of target ontological concept.\n            source: Source IRI (or entity object).\n            property_name: Name of property if `source` is an entity or\n                an entity IRI.\n            cost: User-defined cost of following this mapping relation\n                represented as a float.  It may be given either as a\n                float or as a callable taking three arguments\n\n                    cost(triplestore, input_iris, output_iri)\n\n                and returning the cost as a float.\n            target_cost: Whether the cost is assigned to mapping steps\n                that have `target` as output.\n\n        Note:\n            This is equivalent to the `map()` method, but reverts the\n            two first arguments and adds the `property_name` argument.\n        \"\"\"\n        self.bind(\"map\", MAP)\n\n        if not property_name and not isinstance(source, str):\n            raise TriplestoreError(\n                \"`property_name` is required when `target` is not a string.\"\n            )\n\n        target = self.expand_iri(target)\n        source = self.expand_iri(infer_iri(source))\n        if property_name:\n            self.add((f\"{source}#{property_name}\", MAP.mapsTo, target))\n        else:\n            self.add((source, MAP.mapsTo, target))\n        if cost is not None:\n            dest = target if target_cost else source\n            self._add_cost(cost, dest)\n\n    def _get_function(self, func_iri):\n        \"\"\"Returns Python function object corresponding to `func_iri`.\n\n        Raises CannotGetFunctionError on failure.\n\n        If the function is cached in the the `function_repo` attribute,\n        it is returned directly.\n\n        Otherwise an attempt is made to import the module implementing the\n        function.  If that fails, the corresponding PyPI package is first\n        installed before importing the module again.\n\n        Finally the function is cached and returned.\n\n        Note: Don't use call this method directly.  Use instead the\n        `eval_function()` method, which will at some point will provide\n        sandboxing for security.\n        \"\"\"\n        if func_iri in self.function_repo and self.function_repo[func_iri]:\n            return self.function_repo[func_iri]\n\n        func_name = self.value(func_iri, OTEIO.hasPythonFunctionName)\n        module_name = self.value(func_iri, OTEIO.hasPythonModuleName)\n        package_name = self.value(func_iri, OTEIO.hasPythonPackageName)\n\n        if not func_name or not module_name:\n            raise CannotGetFunctionError(\n                f\"no documentation of how to access function: {func_iri}\"\n            )\n\n        # Import module implementing the function\n        try:\n            module = importlib.import_module(module_name, package_name)\n        except ModuleNotFoundError:\n            # If we cannot find the module, try to install the pypi\n            # package and try to import the module again\n            pypi_package = self.value(func_iri, OTEIO.hasPypiPackageName)\n            if not pypi_package:\n                raise CannotGetFunctionError(  # pylint: disable=raise-missing-from\n                    f\"PyPI package not documented for function: {func_iri}\"\n                )\n\n            try:\n                subprocess.run(  # nosec\n                    args=[\n                        sys.executable,\n                        \"-m\",\n                        \"pip\",\n                        \"install\",\n                        pypi_package,\n                    ],\n                    check=True,\n                )\n            except subprocess.CalledProcessError as exc:\n                raise CannotGetFunctionError(\n                    f\"failed installing PyPI package '{pypi_package}'\"\n                ) from exc\n\n            try:\n                module = importlib.import_module(module_name, package_name)\n            except ModuleNotFoundError as exc:\n                raise CannotGetFunctionError(\n                    f\"failed importing module '{module_name}'\"\n                    + f\" from '{package_name}'\"\n                    if package_name\n                    else \"\"\n                ) from exc\n\n        func = getattr(module, str(func_name))\n        self.function_repo[func_iri] = func\n\n        return func\n\n    def eval_function(self, func_iri, args=(), kwargs=None) -&gt; \"Any\":\n        \"\"\"Evaluate mapping function and return the result.\n\n        Parameters:\n            func_iri: IRI of the function to be evaluated.\n            args: Sequence of positional arguments passed to the function.\n            kwargs: Mapping of keyword arguments passed to the function.\n\n        Returns:\n            The return value of the function.\n\n        Note:\n            The current implementation does not protect against side\n            effect or malicious code.  Be warned!\n            This may be improved in the future.\n        \"\"\"\n        func = self._get_function(func_iri)\n        if not kwargs:\n            kwargs = {}\n\n        # FIXME: Add sandboxing\n        result = func(*args, **kwargs)\n\n        return result\n\n    def add_function(\n        self,\n        func: \"Union[Callable, str]\",\n        expects: \"Union[str, Sequence, Mapping]\" = (),\n        returns: \"Union[str, Sequence]\" = (),\n        base_iri: \"Optional[str]\" = None,\n        standard: str = \"emmo\",\n        cost: \"Optional[Union[float, Callable]]\" = None,\n        func_name: \"Optional[str]\" = None,\n        module_name: \"Optional[str]\" = None,\n        package_name: \"Optional[str]\" = None,\n        pypi_package_name: \"Optional[str]\" = None,\n    ):\n        # pylint: disable=too-many-branches,too-many-arguments\n        \"\"\"Inspect function and add triples describing it to the triplestore.\n\n        Parameters:\n            func: Function to describe.  Should either be a callable or a\n                string with a unique function IRI.\n            expects: Sequence of IRIs to ontological concepts corresponding\n                to positional arguments of `func`.  May also be given as a\n                dict mapping argument names to corresponding ontological IRIs.\n            returns: IRI of return value.  May also be given as a sequence\n                of IRIs, if multiple values are returned.\n            base_iri: Base of the IRI representing the function in the\n                knowledge base.  Defaults to the base IRI of the triplestore.\n            standard: Name of ontology to use when describing the function.\n                Valid values are:\n                - \"emmo\": Elementary Multiperspective Material Ontology (EMMO)\n                - \"fno\": Function Ontology (FnO)\n            cost: User-defined cost of following this mapping relation\n                represented as a float.  It may be given either as a\n                float or as a callable taking three arguments\n\n                    cost(triplestore, input_iris, output_iri)\n\n                and returning the cost as a float.\n            func_name: Function name.  Needed if `func` is given as an IRI.\n            module_name: Fully qualified name of Python module implementing\n                this function.  Default is to infer from `func`.\n                implementing the function.\n            package_name: Name of Python package implementing this function.\n                Default is inferred from either the module or first part of\n                `module_name`.\n            pypi_package_name: Name and version of PyPI package implementing\n                this mapping function (specified as in requirements.txt).\n                Defaults to `package_name`.\n\n        Returns:\n            func_iri: IRI of the added function.\n        \"\"\"\n        if isinstance(expects, str):\n            expects = [expects]\n        if isinstance(returns, str):\n            returns = [returns]\n\n        method = getattr(self, f\"_add_function_{standard}\")\n        func_iri = method(func, expects, returns, base_iri)\n        self.function_repo[func_iri] = func if callable(func) else None\n        if cost is not None:\n            self._add_cost(cost, func_iri)\n\n        # Add standard-independent documentation of how to access the\n        # mapping function\n        self._add_function_doc(\n            func=func if callable(func) else None,\n            func_iri=func_iri,\n            func_name=func_name,\n            module_name=module_name,\n            package_name=package_name,\n            pypi_package_name=pypi_package_name,\n        )\n\n        return func_iri\n\n    def _add_function_doc(\n        self,\n        func_iri: \"str\",\n        func: \"Optional[Callable]\" = None,\n        func_name: \"Optional[str]\" = None,\n        module_name: \"Optional[str]\" = None,\n        package_name: \"Optional[str]\" = None,\n        pypi_package_name: \"Optional[str]\" = None,\n    ):\n        \"\"\"Add standard-independent documentation of how to access the\n        function.\n\n        Parameters:\n            func_iri: IRI of individual in the triplestore that stands for\n                the function.\n            func: Optional reference to the function itself.\n            func_name: Function name.  Needed if `func` is given as an IRI.\n            module_name: Fully qualified name of Python module implementing\n                this function.  Default is to infer from `func`.\n                implementing the function.\n            package_name: Name of Python package implementing this function.\n                Default is inferred from either the module or first part of\n                `module_name`.\n            pypi_package_name: Name and version of PyPI package implementing\n                this mapping function (specified as in requirements.txt).\n                Defaults to `package_name`.\n        \"\"\"\n        if callable(func):\n            func_name = func.__name__\n            module = inspect.getmodule(func)\n            if not module:\n                raise TypeError(\n                    f\"inspect is not able to infer module from function \"\n                    f\"'{func.__name__}'\"\n                )\n            if not module_name:\n                module_name = module.__name__\n            if not package_name:\n                package_name = module.__package__  # type: ignore\n            if not pypi_package_name:\n                pypi_package_name = package_name\n\n        if func_name and module_name:\n            self.bind(\"oteio\", OTEIO)\n            self.add(\n                (\n                    func_iri,\n                    OTEIO.hasPythonFunctionName,\n                    Literal(func_name, datatype=XSD.string),\n                )\n            )\n            self.add(\n                (\n                    func_iri,\n                    OTEIO.hasPythonModuleName,\n                    Literal(module_name, datatype=XSD.string),\n                )\n            )\n            if package_name:\n                self.add(\n                    (\n                        func_iri,\n                        OTEIO.hasPythonPackageName,\n                        Literal(package_name, datatype=XSD.string),\n                    )\n                )\n            if pypi_package_name:\n                self.add(\n                    (\n                        func_iri,\n                        OTEIO.hasPypiPackageName,\n                        Literal(pypi_package_name, datatype=XSD.string),\n                    )\n                )\n        else:\n            warnings.warn(\n                f\"Function and module name for function '{func_name}' \"\n                \"is not provided and cannot be inferred.  How to access \"\n                \"the function will not be documented.\",\n                stacklevel=3,\n            )\n\n    def _add_cost(\n        self,\n        cost: \"Union[float, Callable]\",\n        dest_iri,\n        base_iri=None,\n        pypi_package_name=None,\n    ):\n        \"\"\"Help function that adds `cost` to destination IRI `dest_iri`.\n\n        Parameters:\n            cost: User-defined cost of following this mapping relation\n                represented as a float.  It may be given either as a\n                float or as a callable taking three arguments\n\n                    cost(triplestore, input_iris, output_iri)\n\n                and returning the cost as a float.\n            dest_iri: destination iri that the cost should be associated with.\n            base_iri: Base of the IRI representing the function in the\n                knowledge base.  Defaults to the base IRI of the triplestore.\n            pypi_package_name: Name and version of PyPI package implementing\n                this cost function (specified as in requirements.txt).\n        \"\"\"\n        if base_iri is None:\n            base_iri = self.base_iri if self.base_iri else \":\"\n\n        if self.has(dest_iri, DM.hasCost):\n            warnings.warn(f\"A cost is already assigned to IRI: {dest_iri}\")\n        elif callable(cost):\n            cost_iri = f\"{base_iri}cost_function{function_id(cost)}\"\n            self.add(\n                (dest_iri, DM.hasCost, Literal(cost_iri, datatype=XSD.anyURI))\n            )\n            self.function_repo[cost_iri] = cost\n            self._add_function_doc(\n                func=cost,\n                func_iri=cost_iri,\n                pypi_package_name=pypi_package_name,\n            )\n        else:\n            self.add((dest_iri, DM.hasCost, Literal(cost)))\n\n    def _get_cost(self, dest_iri, input_iris=(), output_iri=None):\n        \"\"\"Return evaluated cost for given destination iri.\"\"\"\n        v = self.value(dest_iri, DM.hasCost)\n\n        if v.datatype and v.datatype != XSD.anyURI:\n            return v.value\n        cost = self._get_function(v.value)\n        return cost(self, input_iris, output_iri)\n\n    def _add_function_fno(self, func, expects, returns, base_iri):\n        \"\"\"Implementing add_function() for FnO.\"\"\"\n        # pylint: disable=too-many-locals,too-many-statements\n        self.bind(\"fno\", FNO)\n        self.bind(\"dcterms\", DCTERMS)\n        self.bind(\"map\", MAP)\n\n        if base_iri is None:\n            base_iri = self.base_iri if self.base_iri else \":\"\n\n        if callable(func):\n            fid = function_id(func)  # Function id\n            func_iri = f\"{base_iri}{func.__name__}_{fid}\"\n            name = func.__name__\n            doc_string = inspect.getdoc(func)\n            parlist = f\"_:{func.__name__}{fid}_parlist\"\n            outlist = f\"_:{func.__name__}{fid}_outlist\"\n            if isinstance(expects, Sequence):\n                pars = list(zip(expects, inspect.signature(func).parameters))\n            else:\n                pars = [\n                    (expects[par], par)\n                    for par in inspect.signature(func).parameters\n                ]\n        elif isinstance(func, str):\n            func_iri = func\n            name = split_iri(func)[1]\n            doc_string = \"\"\n            parlist = f\"_:{func_iri}_parlist\"\n            outlist = f\"_:{func_iri}_outlist\"\n            pariris = (\n                expects if isinstance(expects, Sequence) else expects.values()\n            )\n            parnames = [split_iri(pariri)[1] for pariri in pariris]\n            pars = list(zip(pariris, parnames))\n        else:\n            raise TypeError(\"`func` should be either a callable or an IRI\")\n\n        self.add((func_iri, RDF.type, FNO.Function))\n        self.add((func_iri, RDFS.label, en(name)))\n        self.add((func_iri, FNO.expects, parlist))\n        self.add((func_iri, FNO.returns, outlist))\n        if doc_string:\n            self.add((func_iri, DCTERMS.description, en(doc_string)))\n\n        lst = parlist\n        for i, (iri, parname) in enumerate(pars):\n            lst_next = f\"{parlist}{i+2}\" if i &lt; len(pars) - 1 else RDF.nil\n            par = f\"{func_iri}_parameter{i+1}_{parname}\"\n            self.add((par, RDF.type, FNO.Parameter))\n            self.add((par, RDFS.label, en(parname)))\n            self.add((par, MAP.mapsTo, iri))\n            self.add((lst, RDF.first, par))\n            self.add((lst, RDF.rest, lst_next))\n            lst = lst_next\n\n        lst = outlist\n        for i, iri in enumerate(returns):\n            lst_next = f\"{outlist}{i+2}\" if i &lt; len(returns) - 1 else RDF.nil\n            val = f\"{func_iri}_output{i+1}\"\n            self.add((val, RDF.type, FNO.Output))\n            self.add((val, MAP.mapsTo, iri))\n            self.add((lst, RDF.first, val))\n            self.add((lst, RDF.rest, lst_next))\n            lst = lst_next\n\n        return func_iri\n\n    def _add_function_emmo(self, func, expects, returns, base_iri):\n        \"\"\"Implementing add_function() method for the \"emmo\" standard.\"\"\"\n        # pylint: disable=too-many-locals\n        self.bind(\"emmo\", EMMO)\n        self.bind(\"dcterms\", DCTERMS)\n        self.bind(\"map\", MAP)\n\n        # Hardcode EMMO IRIs to avoid slow lookup\n        Task = EMMO.EMMO_4299e344_a321_4ef2_a744_bacfcce80afc\n        Datum = EMMO.EMMO_50d6236a_7667_4883_8ae1_9bb5d190423a\n        hasInput = EMMO.EMMO_36e69413_8c59_4799_946c_10b05d266e22\n        hasOutput = EMMO.EMMO_c4bace1d_4db0_4cd3_87e9_18122bae2840\n        # Software = EMMO.EMMO_8681074a_e225_4e38_b586_e85b0f43ce38\n        # hasSoftware = EMMO.Software  # TODO: fix when EMMO has hasSoftware\n\n        if base_iri is None:\n            base_iri = self.base_iri if self.base_iri else \":\"\n\n        if callable(func):\n            fid = function_id(func)  # Function id\n            func_iri = f\"{base_iri}{func.__name__}_{fid}\"\n            name = func.__name__\n            doc_string = inspect.getdoc(func)\n            if isinstance(expects, Sequence):\n                pars = list(zip(inspect.signature(func).parameters, expects))\n            else:\n                pars = expects.items()\n        elif isinstance(func, str):\n            func_iri = func\n            name = split_iri(func)[1]\n            doc_string = \"\"\n            pariris = (\n                expects if isinstance(expects, Sequence) else expects.values()\n            )\n            parnames = [split_iri(pariri)[1] for pariri in pariris]\n            pars = list(zip(parnames, pariris))\n        else:\n            raise TypeError(\"`func` should be either a callable or an IRI\")\n\n        self.add((func_iri, RDF.type, Task))\n        self.add((func_iri, RDFS.label, en(name)))\n        for parname, iri in pars:\n            self.add((iri, RDF.type, Datum))\n            self.add((iri, RDFS.label, en(parname)))\n            self.add((func_iri, hasInput, iri))\n        for iri in returns:\n            self.add((iri, RDF.type, Datum))\n            self.add((func_iri, hasOutput, iri))\n        if doc_string:\n            self.add((func_iri, DCTERMS.description, en(doc_string)))\n\n        return func_iri\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.__init__","title":"<code>__init__(self, backend, base_iri=None, database=None, package=None, **kwargs)</code>  <code>special</code>","text":"<p>Initialise triplestore using the backend with the given name.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>str</code> <p>Name of the backend module.</p> <p>For built-in backends or backends provided via a backend package (using entrypoints), this should just be the name of the backend with no dots (ex: \"rdflib\").</p> <p>For a custom backend, you can provide the full module name, including the dots (ex:\"mypackage.mybackend\").  If <code>package</code> is given, <code>backend</code> is interpreted relative to <code>package</code> (ex: ..mybackend).</p> <p>For a list over available backends, see https://github.com/EMMC-ASBL/tripper#available-backends</p> required <code>base_iri</code> <code>'Optional[str]'</code> <p>Base IRI used by the add_function() method when adding new triples. May also be used by the backend.</p> <code>None</code> <code>database</code> <code>'Optional[str]'</code> <p>Name of database to connect to (for backends that supports it).</p> <code>None</code> <code>package</code> <code>'Optional[str]'</code> <p>Required when <code>backend</code> is a relative module.  In that case, it is relative to <code>package</code>.</p> <code>None</code> <code>kwargs</code> <p>Keyword arguments passed to the backend's init() method.</p> <code>{}</code> Source code in <code>tripper/triplestore.py</code> <pre><code>def __init__(\n    self,\n    backend: str,\n    base_iri: \"Optional[str]\" = None,\n    database: \"Optional[str]\" = None,\n    package: \"Optional[str]\" = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Initialise triplestore using the backend with the given name.\n\n    Parameters:\n        backend: Name of the backend module.\n\n            For built-in backends or backends provided via a\n            backend package (using entrypoints), this should just\n            be the name of the backend with no dots (ex: \"rdflib\").\n\n            For a custom backend, you can provide the full module name,\n            including the dots (ex:\"mypackage.mybackend\").  If `package`\n            is given, `backend` is interpreted relative to `package`\n            (ex: ..mybackend).\n\n            For a list over available backends, see\n            https://github.com/EMMC-ASBL/tripper#available-backends\n\n        base_iri: Base IRI used by the add_function() method when adding\n            new triples. May also be used by the backend.\n        database: Name of database to connect to (for backends that\n            supports it).\n        package: Required when `backend` is a relative module.  In that\n            case, it is relative to `package`.\n        kwargs: Keyword arguments passed to the backend's __init__()\n            method.\n\n    \"\"\"\n    backend_name = backend.rsplit(\".\", 1)[-1]\n    module = self._load_backend(backend, package)\n    cls = getattr(module, f\"{backend_name.title()}Strategy\")\n    self.base_iri = base_iri\n    self.namespaces: \"Dict[str, Namespace]\" = {}\n    self.closed = False\n    self.backend_name = backend_name\n    self.backend = cls(base_iri=base_iri, database=database, **kwargs)\n\n    # Cache functions in the triplestore for fast access\n    self.function_repo: \"Dict[str, Union[float, Callable, None]]\" = {}\n\n    for prefix, namespace in self.default_namespaces.items():\n        self.bind(prefix, namespace)\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.add","title":"<code>add(self, triple)</code>","text":"<p>Add <code>triple</code> to triplestore.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def add(self, triple: \"Triple\"):\n    \"\"\"Add `triple` to triplestore.\"\"\"\n    self.add_triples([triple])\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.add_function","title":"<code>add_function(self, func, expects=(), returns=(), base_iri=None, standard='emmo', cost=None, func_name=None, module_name=None, package_name=None, pypi_package_name=None)</code>","text":"<p>Inspect function and add triples describing it to the triplestore.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>'Union[Callable, str]'</code> <p>Function to describe.  Should either be a callable or a string with a unique function IRI.</p> required <code>expects</code> <code>'Union[str, Sequence, Mapping]'</code> <p>Sequence of IRIs to ontological concepts corresponding to positional arguments of <code>func</code>.  May also be given as a dict mapping argument names to corresponding ontological IRIs.</p> <code>()</code> <code>returns</code> <code>'Union[str, Sequence]'</code> <p>IRI of return value.  May also be given as a sequence of IRIs, if multiple values are returned.</p> <code>()</code> <code>base_iri</code> <code>'Optional[str]'</code> <p>Base of the IRI representing the function in the knowledge base.  Defaults to the base IRI of the triplestore.</p> <code>None</code> <code>standard</code> <code>str</code> <p>Name of ontology to use when describing the function. Valid values are: - \"emmo\": Elementary Multiperspective Material Ontology (EMMO) - \"fno\": Function Ontology (FnO)</p> <code>'emmo'</code> <code>cost</code> <code>'Optional[Union[float, Callable]]'</code> <p>User-defined cost of following this mapping relation represented as a float.  It may be given either as a float or as a callable taking three arguments</p> <pre><code>cost(triplestore, input_iris, output_iri)\n</code></pre> <p>and returning the cost as a float.</p> <code>None</code> <code>func_name</code> <code>'Optional[str]'</code> <p>Function name.  Needed if <code>func</code> is given as an IRI.</p> <code>None</code> <code>module_name</code> <code>'Optional[str]'</code> <p>Fully qualified name of Python module implementing this function.  Default is to infer from <code>func</code>. implementing the function.</p> <code>None</code> <code>package_name</code> <code>'Optional[str]'</code> <p>Name of Python package implementing this function. Default is inferred from either the module or first part of <code>module_name</code>.</p> <code>None</code> <code>pypi_package_name</code> <code>'Optional[str]'</code> <p>Name and version of PyPI package implementing this mapping function (specified as in requirements.txt). Defaults to <code>package_name</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>func_iri</code> <p>IRI of the added function.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def add_function(\n    self,\n    func: \"Union[Callable, str]\",\n    expects: \"Union[str, Sequence, Mapping]\" = (),\n    returns: \"Union[str, Sequence]\" = (),\n    base_iri: \"Optional[str]\" = None,\n    standard: str = \"emmo\",\n    cost: \"Optional[Union[float, Callable]]\" = None,\n    func_name: \"Optional[str]\" = None,\n    module_name: \"Optional[str]\" = None,\n    package_name: \"Optional[str]\" = None,\n    pypi_package_name: \"Optional[str]\" = None,\n):\n    # pylint: disable=too-many-branches,too-many-arguments\n    \"\"\"Inspect function and add triples describing it to the triplestore.\n\n    Parameters:\n        func: Function to describe.  Should either be a callable or a\n            string with a unique function IRI.\n        expects: Sequence of IRIs to ontological concepts corresponding\n            to positional arguments of `func`.  May also be given as a\n            dict mapping argument names to corresponding ontological IRIs.\n        returns: IRI of return value.  May also be given as a sequence\n            of IRIs, if multiple values are returned.\n        base_iri: Base of the IRI representing the function in the\n            knowledge base.  Defaults to the base IRI of the triplestore.\n        standard: Name of ontology to use when describing the function.\n            Valid values are:\n            - \"emmo\": Elementary Multiperspective Material Ontology (EMMO)\n            - \"fno\": Function Ontology (FnO)\n        cost: User-defined cost of following this mapping relation\n            represented as a float.  It may be given either as a\n            float or as a callable taking three arguments\n\n                cost(triplestore, input_iris, output_iri)\n\n            and returning the cost as a float.\n        func_name: Function name.  Needed if `func` is given as an IRI.\n        module_name: Fully qualified name of Python module implementing\n            this function.  Default is to infer from `func`.\n            implementing the function.\n        package_name: Name of Python package implementing this function.\n            Default is inferred from either the module or first part of\n            `module_name`.\n        pypi_package_name: Name and version of PyPI package implementing\n            this mapping function (specified as in requirements.txt).\n            Defaults to `package_name`.\n\n    Returns:\n        func_iri: IRI of the added function.\n    \"\"\"\n    if isinstance(expects, str):\n        expects = [expects]\n    if isinstance(returns, str):\n        returns = [returns]\n\n    method = getattr(self, f\"_add_function_{standard}\")\n    func_iri = method(func, expects, returns, base_iri)\n    self.function_repo[func_iri] = func if callable(func) else None\n    if cost is not None:\n        self._add_cost(cost, func_iri)\n\n    # Add standard-independent documentation of how to access the\n    # mapping function\n    self._add_function_doc(\n        func=func if callable(func) else None,\n        func_iri=func_iri,\n        func_name=func_name,\n        module_name=module_name,\n        package_name=package_name,\n        pypi_package_name=pypi_package_name,\n    )\n\n    return func_iri\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.add_mapsTo","title":"<code>add_mapsTo(self, target, source, property_name=None, cost=None, target_cost=True)</code>","text":"<p>Add 'mapsTo' relation to triplestore.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>IRI of target ontological concept.</p> required <code>source</code> <code>str</code> <p>Source IRI (or entity object).</p> required <code>property_name</code> <code>'Optional[str]'</code> <p>Name of property if <code>source</code> is an entity or an entity IRI.</p> <code>None</code> <code>cost</code> <code>'Optional[Union[float, Callable]]'</code> <p>User-defined cost of following this mapping relation represented as a float.  It may be given either as a float or as a callable taking three arguments</p> <pre><code>cost(triplestore, input_iris, output_iri)\n</code></pre> <p>and returning the cost as a float.</p> <code>None</code> <code>target_cost</code> <code>bool</code> <p>Whether the cost is assigned to mapping steps that have <code>target</code> as output.</p> <code>True</code> <p>Note</p> <p>This is equivalent to the <code>map()</code> method, but reverts the two first arguments and adds the <code>property_name</code> argument.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def add_mapsTo(\n    self,\n    target: str,\n    source: str,\n    property_name: \"Optional[str]\" = None,\n    cost: \"Optional[Union[float, Callable]]\" = None,\n    target_cost: bool = True,\n):\n    \"\"\"Add 'mapsTo' relation to triplestore.\n\n    Parameters:\n        target: IRI of target ontological concept.\n        source: Source IRI (or entity object).\n        property_name: Name of property if `source` is an entity or\n            an entity IRI.\n        cost: User-defined cost of following this mapping relation\n            represented as a float.  It may be given either as a\n            float or as a callable taking three arguments\n\n                cost(triplestore, input_iris, output_iri)\n\n            and returning the cost as a float.\n        target_cost: Whether the cost is assigned to mapping steps\n            that have `target` as output.\n\n    Note:\n        This is equivalent to the `map()` method, but reverts the\n        two first arguments and adds the `property_name` argument.\n    \"\"\"\n    self.bind(\"map\", MAP)\n\n    if not property_name and not isinstance(source, str):\n        raise TriplestoreError(\n            \"`property_name` is required when `target` is not a string.\"\n        )\n\n    target = self.expand_iri(target)\n    source = self.expand_iri(infer_iri(source))\n    if property_name:\n        self.add((f\"{source}#{property_name}\", MAP.mapsTo, target))\n    else:\n        self.add((source, MAP.mapsTo, target))\n    if cost is not None:\n        dest = target if target_cost else source\n        self._add_cost(cost, dest)\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.add_restriction","title":"<code>add_restriction(self, cls, property, value, type, cardinality=None, hashlength=16)</code>","text":"<p>Add a restriction to a class in the triplestore.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>str</code> <p>IRI of class to which the restriction applies.</p> required <code>property</code> <code>str</code> <p>IRI of restriction property.</p> required <code>value</code> <code>'Union[str, Literal]'</code> <p>The IRI or literal value of the restriction target.</p> required <code>type</code> <code>'RestrictionType'</code> <p>The type of the restriction.  Should be one of: - some: existential restriction (value is a class IRI) - only: universal restriction (value is a class IRI) - exactly: cardinality restriction (value is a class IRI) - min: minimum cardinality restriction (value is a class IRI) - max: maximum cardinality restriction (value is a class IRI) - value: Value restriction (value is an IRI of an individual   or a literal)</p> required <code>cardinality</code> <code>'Optional[int]'</code> <p>the cardinality value for cardinality restrictions.</p> <code>None</code> <code>hashlength</code> <code>int</code> <p>Number of bytes in the hash part of the bnode IRI.</p> <code>16</code> <p>Returns:</p> Type Description <code>str</code> <p>The IRI of the created blank node representing the restriction.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def add_restriction(  # pylint: disable=redefined-builtin\n    self,\n    cls: str,\n    property: str,\n    value: \"Union[str, Literal]\",\n    type: \"RestrictionType\",\n    cardinality: \"Optional[int]\" = None,\n    hashlength: int = 16,\n) -&gt; str:\n    \"\"\"Add a restriction to a class in the triplestore.\n\n    Parameters:\n        cls: IRI of class to which the restriction applies.\n        property: IRI of restriction property.\n        value: The IRI or literal value of the restriction target.\n        type: The type of the restriction.  Should be one of:\n            - some: existential restriction (value is a class IRI)\n            - only: universal restriction (value is a class IRI)\n            - exactly: cardinality restriction (value is a class IRI)\n            - min: minimum cardinality restriction (value is a class IRI)\n            - max: maximum cardinality restriction (value is a class IRI)\n            - value: Value restriction (value is an IRI of an individual\n              or a literal)\n\n        cardinality: the cardinality value for cardinality restrictions.\n        hashlength: Number of bytes in the hash part of the bnode IRI.\n\n    Returns:\n        The IRI of the created blank node representing the restriction.\n    \"\"\"\n    iri = bnode_iri(\n        prefix=\"restriction\",\n        source=f\"{cls} {property} {value} {type} {cardinality}\",\n        length=hashlength,\n    )\n    triples = [\n        (cls, RDFS.subClassOf, iri),\n        (iri, RDF.type, OWL.Restriction),\n        (iri, OWL.onProperty, property),\n    ]\n    if type not in self._restriction_types:\n        raise ArgumentValueError(\n            '`type` must be one of: \"some\", \"only\", \"exactly\", \"min\", '\n            '\"max\" or \"value\"'\n        )\n    pred, card = self._restriction_types[type]\n    triples.append((iri, pred, value))\n    if card:\n        if not cardinality:\n            raise ArgumentTypeError(\n                f\"`cardinality` must be provided for type='{type}'\"\n            )\n        triples.append(\n            (\n                iri,\n                card,\n                Literal(cardinality, datatype=XSD.nonNegativeInteger),\n            ),\n        )\n\n    self.add_triples(triples)\n    return iri\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.add_triples","title":"<code>add_triples(self, triples)</code>","text":"<p>Add a sequence of triples.</p> <p>Parameters:</p> Name Type Description Default <code>triples</code> <code>'Union[Sequence[Triple], Generator[Triple, None, None]]'</code> <p>A sequence of <code>(s, p, o)</code> tuples to add to the triplestore.</p> required Source code in <code>tripper/triplestore.py</code> <pre><code>def add_triples(\n    self, triples: \"Union[Sequence[Triple], Generator[Triple, None, None]]\"\n):\n    \"\"\"Add a sequence of triples.\n\n    Arguments:\n        triples: A sequence of `(s, p, o)` tuples to add to the\n            triplestore.\n    \"\"\"\n    self.backend.add_triples(triples)\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.bind","title":"<code>bind(self, prefix, namespace='', **kwargs)</code>","text":"<p>Bind prefix to namespace and return the new Namespace object.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Prefix to bind the the namespace.</p> required <code>namespace</code> <code>'Union[str, Namespace, Triplestore, None]'</code> <p>Namespace to bind to.  The default is to bind to the <code>base_iri</code> of the current triplestore. If <code>namespace</code> is None, the corresponding prefix is removed.</p> <code>''</code> <code>kwargs</code> <p>Keyword arguments are passed to the Namespace() constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Namespace</code> <p>New Namespace object or None if namespace is removed.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def bind(  # pylint: disable=inconsistent-return-statements\n    self,\n    prefix: str,\n    namespace: \"Union[str, Namespace, Triplestore, None]\" = \"\",\n    **kwargs,\n) -&gt; Namespace:\n    \"\"\"Bind prefix to namespace and return the new Namespace object.\n\n    Parameters:\n        prefix: Prefix to bind the the namespace.\n        namespace: Namespace to bind to.  The default is to bind to the\n            `base_iri` of the current triplestore.\n            If `namespace` is None, the corresponding prefix is removed.\n        kwargs: Keyword arguments are passed to the Namespace()\n            constructor.\n\n    Returns:\n        New Namespace object or None if namespace is removed.\n    \"\"\"\n    if namespace == \"\":\n        namespace = self\n\n    if isinstance(namespace, str):\n        ns = Namespace(namespace, **kwargs)\n    elif isinstance(namespace, Triplestore):\n        if not namespace.base_iri:\n            raise ValueError(\n                f\"triplestore object {namespace} has no `base_iri`\"\n            )\n        ns = Namespace(namespace.base_iri, **kwargs)\n    elif isinstance(namespace, Namespace):\n        # pylint: disable=protected-access\n        ns = Namespace(namespace._iri, **kwargs)\n    elif namespace is None:\n        del self.namespaces[prefix]\n        return  # type: ignore\n    else:\n        raise TypeError(f\"invalid `namespace` type: {type(namespace)}\")\n\n    if hasattr(self.backend, \"bind\"):\n        self.backend.bind(\n            prefix, ns._iri  # pylint: disable=protected-access\n        )\n\n    self.namespaces[prefix] = ns\n    return ns\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.close","title":"<code>close(self)</code>","text":"<p>Calls the backend close() method if it is implemented. Otherwise, this method has no effect.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def close(self):\n    \"\"\"Calls the backend close() method if it is implemented.\n    Otherwise, this method has no effect.\n    \"\"\"\n    # It should be ok to call close() regardless of whether the backend\n    # implements this method or not.  Hence, don't call _check_method().\n    if not self.closed and hasattr(self.backend, \"close\"):\n        self.backend.close()\n    self.closed = True\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.create_database","title":"<code>create_database(backend, database, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a new database in backend.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>str</code> <p>Name of backend.</p> required <code>database</code> <code>str</code> <p>Name of the new database.</p> required <code>kwargs</code> <p>Keyword arguments passed to the backend create_database() method.</p> <code>{}</code> <p>Note</p> <p>This is a class method, which operates on the backend triplestore without connecting to it.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>@classmethod\ndef create_database(cls, backend: str, database: str, **kwargs):\n    \"\"\"Create a new database in backend.\n\n    Parameters:\n        backend: Name of backend.\n        database: Name of the new database.\n        kwargs: Keyword arguments passed to the backend\n            create_database() method.\n\n    Note:\n        This is a class method, which operates on the backend\n        triplestore without connecting to it.\n    \"\"\"\n    cls._check_backend_method(backend, \"create_database\")\n    backend_class = cls._get_backend(backend)\n    return backend_class.create_database(database=database, **kwargs)\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.eval_function","title":"<code>eval_function(self, func_iri, args=(), kwargs=None)</code>","text":"<p>Evaluate mapping function and return the result.</p> <p>Parameters:</p> Name Type Description Default <code>func_iri</code> <p>IRI of the function to be evaluated.</p> required <code>args</code> <p>Sequence of positional arguments passed to the function.</p> <code>()</code> <code>kwargs</code> <p>Mapping of keyword arguments passed to the function.</p> <code>None</code> <p>Returns:</p> Type Description <code>'Any'</code> <p>The return value of the function.</p> <p>Note</p> <p>The current implementation does not protect against side effect or malicious code.  Be warned! This may be improved in the future.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def eval_function(self, func_iri, args=(), kwargs=None) -&gt; \"Any\":\n    \"\"\"Evaluate mapping function and return the result.\n\n    Parameters:\n        func_iri: IRI of the function to be evaluated.\n        args: Sequence of positional arguments passed to the function.\n        kwargs: Mapping of keyword arguments passed to the function.\n\n    Returns:\n        The return value of the function.\n\n    Note:\n        The current implementation does not protect against side\n        effect or malicious code.  Be warned!\n        This may be improved in the future.\n    \"\"\"\n    func = self._get_function(func_iri)\n    if not kwargs:\n        kwargs = {}\n\n    # FIXME: Add sandboxing\n    result = func(*args, **kwargs)\n\n    return result\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.expand_iri","title":"<code>expand_iri(self, iri)</code>","text":"<p>Return the full IRI if <code>iri</code> is prefixed.  Otherwise <code>iri</code> is returned.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def expand_iri(self, iri: str):\n    \"\"\"Return the full IRI if `iri` is prefixed.  Otherwise `iri` is\n    returned.\"\"\"\n    match = re.match(_MATCH_PREFIXED_IRI, iri)\n    if match:\n        prefix, name = match.groups()\n        if prefix not in self.namespaces:\n            raise NamespaceError(f\"unknown namespace: {prefix}\")\n        return f\"{self.namespaces[prefix]}{name}\"\n    return iri\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.has","title":"<code>has(self, subject=None, predicate=None, object=None)</code>","text":"<p>Returns true if the triplestore has any triple matching the give subject, predicate and/or object.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def has(\n    self, subject=None, predicate=None, object=None\n):  # pylint: disable=redefined-builtin\n    \"\"\"Returns true if the triplestore has any triple matching\n    the give subject, predicate and/or object.\"\"\"\n    triple = self.triples(\n        subject=subject, predicate=predicate, object=object\n    )\n    try:\n        next(triple)\n    except StopIteration:\n        return False\n    return True\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.list_databases","title":"<code>list_databases(backend, **kwargs)</code>  <code>classmethod</code>","text":"<p>For backends that supports multiple databases, list of all databases.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>str</code> <p>Name of backend.</p> required <code>kwargs</code> <p>Keyword arguments passed to the backend list_databases() method.</p> <code>{}</code> <p>Note</p> <p>This is a class method, which operates on the backend triplestore without connecting to it.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>@classmethod\ndef list_databases(cls, backend: str, **kwargs):\n    \"\"\"For backends that supports multiple databases, list of all\n    databases.\n\n    Parameters:\n        backend: Name of backend.\n        kwargs: Keyword arguments passed to the backend\n            list_databases() method.\n\n    Note:\n        This is a class method, which operates on the backend\n        triplestore without connecting to it.\n    \"\"\"\n    cls._check_backend_method(backend, \"list_databases\")\n    backend_class = cls._get_backend(backend)\n    return backend_class.list_databases(**kwargs)\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.map","title":"<code>map(self, source, target, cost=None, target_cost=True)</code>","text":"<p>Add 'mapsTo' relation to the triplestore.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source IRI.</p> required <code>target</code> <code>str</code> <p>IRI of target ontological concept.</p> required <code>cost</code> <code>'Optional[Union[float, Callable]]'</code> <p>User-defined cost of following this mapping relation represented as a float.  It may be given either as a float or as a callable taking three arguments</p> <pre><code>cost(triplestore, input_iris, output_iri)\n</code></pre> <p>and returning the cost as a float.</p> <code>None</code> <code>target_cost</code> <code>bool</code> <p>Whether the cost is assigned to mapping steps that have <code>target</code> as output.</p> <code>True</code> Source code in <code>tripper/triplestore.py</code> <pre><code>def map(\n    self,\n    source: str,\n    target: str,\n    cost: \"Optional[Union[float, Callable]]\" = None,\n    target_cost: bool = True,\n):\n    \"\"\"Add 'mapsTo' relation to the triplestore.\n\n    Parameters:\n        source: Source IRI.\n        target: IRI of target ontological concept.\n        cost: User-defined cost of following this mapping relation\n            represented as a float.  It may be given either as a\n            float or as a callable taking three arguments\n\n                cost(triplestore, input_iris, output_iri)\n\n            and returning the cost as a float.\n        target_cost: Whether the cost is assigned to mapping steps\n            that have `target` as output.\n    \"\"\"\n    return self.add_mapsTo(\n        target=target,\n        source=source,\n        cost=cost,\n        target_cost=target_cost,\n    )\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.objects","title":"<code>objects(self, subject=None, predicate=None)</code>","text":"<p>Returns a generator of objects for given subject and predicate.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def objects(self, subject=None, predicate=None):\n    \"\"\"Returns a generator of objects for given subject and predicate.\"\"\"\n    for _, _, o in self.triples(subject=subject, predicate=predicate):\n        yield o\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.parse","title":"<code>parse(self, source=None, format=None, fallback_backend='rdflib', fallback_backend_kwargs=None, **kwargs)</code>","text":"<p>Parse source and add the resulting triples to triplestore.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <p>File-like object or file name.</p> <code>None</code> <code>format</code> <p>Needed if format can not be inferred from source.</p> <code>None</code> <code>fallback_backend</code> <p>If the current backend doesn't implement parse, use the <code>fallback_backend</code> instead.</p> <code>'rdflib'</code> <code>fallback_backend_kwargs</code> <p>Dict with additional keyword arguments for initialising <code>fallback_backend</code>.</p> <code>None</code> <code>kwargs</code> <p>Keyword arguments passed to the backend. The rdflib backend supports e.g. <code>location</code> (absolute or relative URL) and <code>data</code> (string containing the data to be parsed) arguments.</p> <code>{}</code> Source code in <code>tripper/triplestore.py</code> <pre><code>def parse(\n    self,\n    source=None,\n    format=None,\n    fallback_backend=\"rdflib\",\n    fallback_backend_kwargs=None,\n    **kwargs,  # pylint: disable=redefined-builtin\n) -&gt; None:\n    \"\"\"Parse source and add the resulting triples to triplestore.\n\n    Parameters:\n        source: File-like object or file name.\n        format: Needed if format can not be inferred from source.\n        fallback_backend: If the current backend doesn't implement\n            parse, use the `fallback_backend` instead.\n        fallback_backend_kwargs: Dict with additional keyword arguments\n            for initialising `fallback_backend`.\n        kwargs: Keyword arguments passed to the backend.\n            The rdflib backend supports e.g. `location` (absolute\n            or relative URL) and `data` (string containing the\n            data to be parsed) arguments.\n    \"\"\"\n    if hasattr(self.backend, \"parse\"):\n        self._check_method(\"parse\")\n        self.backend.parse(source=source, format=format, **kwargs)\n    else:\n        if fallback_backend_kwargs is None:\n            fallback_backend_kwargs = {}\n        ts = Triplestore(\n            backend=fallback_backend, **fallback_backend_kwargs\n        )\n        ts.parse(source=source, format=format, **kwargs)\n        self.add_triples(ts.triples())\n\n    if hasattr(self.backend, \"namespaces\"):\n        for prefix, namespace in self.backend.namespaces().items():\n            if prefix and prefix not in self.namespaces:\n                self.namespaces[prefix] = Namespace(namespace)\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.predicate_objects","title":"<code>predicate_objects(self, subject=None)</code>","text":"<p>Returns a generator of (predicate, object) tuples for given subject.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def predicate_objects(self, subject=None):\n    \"\"\"Returns a generator of (predicate, object) tuples for given\n    subject.\"\"\"\n    for _, p, o in self.triples(subject=subject):\n        yield p, o\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.predicates","title":"<code>predicates(self, subject=None, object=None)</code>","text":"<p>Returns a generator of predicates for given subject and object.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def predicates(\n    self, subject=None, object=None  # pylint: disable=redefined-builtin\n):\n    \"\"\"Returns a generator of predicates for given subject and object.\"\"\"\n    for _, p, _ in self.triples(subject=subject, object=object):\n        yield p\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.prefix_iri","title":"<code>prefix_iri(self, iri, require_prefixed=False)</code>","text":"<p>Return prefixed IRI.</p> <p>This is the reverse of expand_iri().</p> <p>If <code>require_prefixed</code> is true, a NamespaceError exception is raised if no prefix can be found.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def prefix_iri(self, iri: str, require_prefixed: bool = False):\n    \"\"\"Return prefixed IRI.\n\n    This is the reverse of expand_iri().\n\n    If `require_prefixed` is true, a NamespaceError exception is raised\n    if no prefix can be found.\n    \"\"\"\n    if not re.match(_MATCH_PREFIXED_IRI, iri):\n        for prefix, namespace in self.namespaces.items():\n            if iri.startswith(str(namespace)):\n                return f\"{prefix}:{iri[len(str(namespace)):]}\"\n        if require_prefixed:\n            raise NamespaceError(f\"No prefix defined for IRI: {iri}\")\n    return iri\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.query","title":"<code>query(self, query_object, **kwargs)</code>","text":"<p>SPARQL query.</p> <p>Parameters:</p> Name Type Description Default <code>query_object</code> <p>String with the SPARQL query.</p> required <code>kwargs</code> <p>Keyword arguments passed to the backend query() method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>The return type depends on type of query</code> <ul> <li>SELECT: list of tuples of IRIs for each matching row</li> <li>ASK: bool</li> <li>CONSTRUCT, DESCRIBE: generator over triples</li> </ul> <p>Note</p> <p>This method is intended for SELECT, ASK, CONSTRUCT and DESCRIBE queries.  Use the update() method for INSERT and DELETE queries.</p> <p>Not all backends may support all types of queries.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def query(\n    self, query_object, **kwargs\n) -&gt; \"Union[List[Tuple[str, ...]], bool, Generator[Triple, None, None]]\":\n    \"\"\"SPARQL query.\n\n    Parameters:\n        query_object: String with the SPARQL query.\n        kwargs: Keyword arguments passed to the backend query() method.\n\n    Returns:\n        The return type depends on type of query:\n          - SELECT: list of tuples of IRIs for each matching row\n          - ASK: bool\n          - CONSTRUCT, DESCRIBE: generator over triples\n\n    Note:\n        This method is intended for SELECT, ASK, CONSTRUCT and\n        DESCRIBE queries.  Use the update() method for INSERT and\n        DELETE queries.\n\n        Not all backends may support all types of queries.\n\n    \"\"\"\n    self._check_method(\"query\")\n    return self.backend.query(query_object=query_object, **kwargs)\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.remove","title":"<code>remove(self, subject=None, predicate=None, object=None, triple=None)</code>","text":"<p>Remove all matching triples from the backend.</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>'Optional[Union[str, Triple]]'</code> <p>If given, match triples with this subject.</p> <code>None</code> <code>predicate</code> <code>'Optional[str]'</code> <p>If given, match triples with this predicate.</p> <code>None</code> <code>object</code> <code>'Optional[Union[str, Literal]]'</code> <p>If given, match triples with this object.</p> <code>None</code> <code>triple</code> <code>'Optional[Triple]'</code> <p>Deprecated. A <code>(s, p, o)</code> tuple where <code>s</code>, <code>p</code> and <code>o</code> should either be None (matching anything) or an exact IRI to match.</p> <code>None</code> Source code in <code>tripper/triplestore.py</code> <pre><code>def remove(  # pylint: disable=redefined-builtin\n    self,\n    subject: \"Optional[Union[str, Triple]]\" = None,\n    predicate: \"Optional[str]\" = None,\n    object: \"Optional[Union[str, Literal]]\" = None,\n    triple: \"Optional[Triple]\" = None,\n) -&gt; None:\n    \"\"\"Remove all matching triples from the backend.\n\n    Arguments:\n        subject: If given, match triples with this subject.\n        predicate: If given, match triples with this predicate.\n        object: If given, match triples with this object.\n        triple: Deprecated. A `(s, p, o)` tuple where `s`, `p` and `o`\n            should either be None (matching anything) or an exact IRI\n            to match.\n    \"\"\"\n    # __TODO__: Remove these lines when deprecated\n    if triple or (subject and not isinstance(subject, str)):\n        warnings.warn(\n            \"The `triple` argument is deprecated.  Use `subject`, \"\n            \"`predicate` and `object` arguments instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n    if subject and not isinstance(subject, str):\n        subject, predicate, object = subject\n    elif triple:\n        subject, predicate, object = triple\n\n    return self.backend.remove((subject, predicate, object))\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.remove_database","title":"<code>remove_database(backend, database, **kwargs)</code>  <code>classmethod</code>","text":"<p>Remove a database in backend.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>str</code> <p>Name of backend.</p> required <code>database</code> <code>str</code> <p>Name of the database to be removed.</p> required <code>kwargs</code> <p>Keyword arguments passed to the backend remove_database() method.</p> <code>{}</code> <p>Note</p> <p>This is a class method, which operates on the backend triplestore without connecting to it.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>@classmethod\ndef remove_database(cls, backend: str, database: str, **kwargs):\n    \"\"\"Remove a database in backend.\n\n    Parameters:\n        backend: Name of backend.\n        database: Name of the database to be removed.\n        kwargs: Keyword arguments passed to the backend\n            remove_database() method.\n\n    Note:\n        This is a class method, which operates on the backend\n        triplestore without connecting to it.\n    \"\"\"\n    cls._check_backend_method(backend, \"remove_database\")\n    backend_class = cls._get_backend(backend)\n    return backend_class.remove_database(database=database, **kwargs)\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.restrictions","title":"<code>restrictions(self, cls=None, property=None, value=None, type=None, cardinality=None, asdict=True)</code>","text":"<p>Returns a generator over matching restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>'Optional[str]'</code> <p>IRI of class to which the restriction applies.</p> <code>None</code> <code>property</code> <code>'Optional[str]'</code> <p>IRI of restriction property.</p> <code>None</code> <code>value</code> <code>'Optional[Union[str, Literal]]'</code> <p>The IRI or literal value of the restriction target.</p> <code>None</code> <code>type</code> <code>'Optional[RestrictionType]'</code> <p>The type of the restriction.  Should be one of: - some: existential restriction (value is a class IRI) - only: universal restriction (value is a class IRI) - exactly: cardinality restriction (value is a class IRI) - min: minimum cardinality restriction (value is a class IRI) - max: maximum cardinality restriction (value is a class IRI) - value: Value restriction (value is an IRI of an individual   or a literal)</p> <code>None</code> <code>cardinality</code> <code>'Optional[int]'</code> <p>the cardinality value for cardinality restrictions.</p> <code>None</code> <code>asdict</code> <code>bool</code> <p>Whether to returned generator is over dicts (see _get_restriction_dict()). Default is to return a generator over blank node IRIs.</p> <code>True</code> <p>Returns:</p> Type Description <code>'Generator[Triple, None, None]'</code> <p>A generator over matching restrictions.  See <code>asdict</code> argument for types iterated over.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def restrictions(  # pylint: disable=redefined-builtin\n    self,\n    cls: \"Optional[str]\" = None,\n    property: \"Optional[str]\" = None,\n    value: \"Optional[Union[str, Literal]]\" = None,\n    type: \"Optional[RestrictionType]\" = None,\n    cardinality: \"Optional[int]\" = None,\n    asdict: bool = True,\n) -&gt; \"Generator[Triple, None, None]\":\n    # pylint: disable=too-many-boolean-expressions\n    \"\"\"Returns a generator over matching restrictions.\n\n    Parameters:\n        cls: IRI of class to which the restriction applies.\n        property: IRI of restriction property.\n        value: The IRI or literal value of the restriction target.\n        type: The type of the restriction.  Should be one of:\n            - some: existential restriction (value is a class IRI)\n            - only: universal restriction (value is a class IRI)\n            - exactly: cardinality restriction (value is a class IRI)\n            - min: minimum cardinality restriction (value is a class IRI)\n            - max: maximum cardinality restriction (value is a class IRI)\n            - value: Value restriction (value is an IRI of an individual\n              or a literal)\n\n        cardinality: the cardinality value for cardinality restrictions.\n        asdict: Whether to returned generator is over dicts (see\n            _get_restriction_dict()). Default is to return a generator\n            over blank node IRIs.\n\n    Returns:\n        A generator over matching restrictions.  See `asdict` argument\n        for types iterated over.\n    \"\"\"\n    if type is None:\n        types = set(self._restriction_types.keys())\n    elif type not in self._restriction_types:\n        raise ArgumentValueError(\n            f\"Invalid `type='{type}'`, it must be one of: \"\n            f\"{', '.join(self._restriction_types.keys())}.\"\n        )\n    else:\n        types = {type} if isinstance(type, str) else set(type)\n\n    if isinstance(value, Literal):\n        types.intersection_update({\"value\"})\n    elif isinstance(value, str):\n        types.difference_update({\"value\"})\n\n    if cardinality:\n        types.intersection_update({\"exactly\", \"min\", \"max\"})\n    if not types:\n        raise ArgumentValueError(\n            f\"Inconsistent type='{type}', value='{value}' and \"\n            f\"cardinality='{cardinality}' arguments\"\n        )\n    pred = {self._restriction_types[t][0] for t in types}\n    card = {\n        self._restriction_types[t][1]\n        for t in types\n        if self._restriction_types[t][1]\n    }\n\n    if cardinality:\n        lcard = Literal(cardinality, datatype=XSD.nonNegativeInteger)\n\n    for iri in self.subjects(predicate=OWL.onProperty, object=property):\n        if (\n            self.has(iri, RDF.type, OWL.Restriction)\n            and (not cls or self.has(cls, RDFS.subClassOf, iri))\n            and any(self.has(iri, p, value) for p in pred)\n            and (\n                not card\n                or not cardinality\n                or any(self.has(iri, c, lcard) for c in card)\n            )\n        ):\n            yield self._get_restriction_dict(iri) if asdict else iri\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.serialize","title":"<code>serialize(self, destination=None, format='turtle', fallback_backend='rdflib', fallback_backend_kwargs=None, **kwargs)</code>","text":"<p>Serialise triplestore.</p> <p>Parameters:</p> Name Type Description Default <code>destination</code> <p>File name or object to write to.  If None, the serialisation is returned.</p> <code>None</code> <code>format</code> <p>Format to serialise as.  Supported formats, depends on the backend.</p> <code>'turtle'</code> <code>fallback_backend</code> <p>If the current backend doesn't implement serialisation, use the <code>fallback_backend</code> instead.</p> <code>'rdflib'</code> <code>fallback_backend_kwargs</code> <p>Dict with additional keyword arguments for initialising <code>fallback_backend</code>.</p> <code>None</code> <code>kwargs</code> <p>Passed to the backend serialize() method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>'Union[None, str]'</code> <p>Serialized string if <code>destination</code> is None.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def serialize(\n    self,\n    destination=None,\n    format=\"turtle\",  # pylint: disable=redefined-builtin\n    fallback_backend=\"rdflib\",\n    fallback_backend_kwargs=None,\n    **kwargs,\n) -&gt; \"Union[None, str]\":\n    \"\"\"Serialise triplestore.\n\n    Parameters:\n        destination: File name or object to write to.  If None, the\n            serialisation is returned.\n        format: Format to serialise as.  Supported formats, depends on\n            the backend.\n        fallback_backend: If the current backend doesn't implement\n            serialisation, use the `fallback_backend` instead.\n        fallback_backend_kwargs: Dict with additional keyword arguments\n            for initialising `fallback_backend`.\n        kwargs: Passed to the backend serialize() method.\n\n    Returns:\n        Serialized string if `destination` is None.\n    \"\"\"\n    if hasattr(self.backend, \"parse\"):\n        self._check_method(\"serialize\")\n        return self.backend.serialize(\n            destination=destination, format=format, **kwargs\n        )\n\n    if fallback_backend_kwargs is None:\n        fallback_backend_kwargs = {}\n    ts = Triplestore(backend=fallback_backend, **fallback_backend_kwargs)\n    ts.add_triples(self.triples())\n    for prefix, iri in self.namespaces.items():\n        ts.bind(prefix, iri)\n    return ts.serialize(destination=destination, format=format, **kwargs)\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.set","title":"<code>set(self, triple)</code>","text":"<p>Convenience method to update the value of object.</p> <p>Removes any existing triples for subject and predicate before adding the given <code>triple</code>.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def set(self, triple):\n    \"\"\"Convenience method to update the value of object.\n\n    Removes any existing triples for subject and predicate before adding\n    the given `triple`.\n    \"\"\"\n    s, p, _ = triple\n    self.remove(s, p)\n    self.add(triple)\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.subject_objects","title":"<code>subject_objects(self, predicate=None)</code>","text":"<p>Returns a generator of (subject, object) tuples for given predicate.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def subject_objects(self, predicate=None):\n    \"\"\"Returns a generator of (subject, object) tuples for given\n    predicate.\"\"\"\n    for s, _, o in self.triples(predicate=predicate):\n        yield s, o\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.subject_predicates","title":"<code>subject_predicates(self, object=None)</code>","text":"<p>Returns a generator of (subject, predicate) tuples for given object.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def subject_predicates(\n    self, object=None\n):  # pylint: disable=redefined-builtin\n    \"\"\"Returns a generator of (subject, predicate) tuples for given\n    object.\"\"\"\n    for s, p, _ in self.triples(object=object):\n        yield s, p\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.subjects","title":"<code>subjects(self, predicate=None, object=None)</code>","text":"<p>Returns a generator of subjects for given predicate and object.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def subjects(\n    self, predicate=None, object=None  # pylint: disable=redefined-builtin\n):\n    \"\"\"Returns a generator of subjects for given predicate and object.\"\"\"\n    for s, _, _ in self.triples(predicate=predicate, object=object):\n        yield s\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.triples","title":"<code>triples(self, subject=None, predicate=None, object=None, triple=None)</code>","text":"<p>Returns a generator over matching triples.</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>'Optional[Union[str, Triple]]'</code> <p>If given, match triples with this subject.</p> <code>None</code> <code>predicate</code> <code>'Optional[str]'</code> <p>If given, match triples with this predicate.</p> <code>None</code> <code>object</code> <code>'Optional[Union[str, Literal]]'</code> <p>If given, match triples with this object.</p> <code>None</code> <code>triple</code> <code>'Optional[Triple]'</code> <p>Deprecated. A <code>(s, p, o)</code> tuple where <code>s</code>, <code>p</code> and <code>o</code> should either be None (matching anything) or an exact IRI to match.</p> <code>None</code> <p>Returns:</p> Type Description <code>'Generator[Triple, None, None]'</code> <p>Generator over all matching triples.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def triples(  # pylint: disable=redefined-builtin\n    self,\n    subject: \"Optional[Union[str, Triple]]\" = None,\n    predicate: \"Optional[str]\" = None,\n    object: \"Optional[Union[str, Literal]]\" = None,\n    triple: \"Optional[Triple]\" = None,\n) -&gt; \"Generator[Triple, None, None]\":\n    \"\"\"Returns a generator over matching triples.\n\n    Arguments:\n        subject: If given, match triples with this subject.\n        predicate: If given, match triples with this predicate.\n        object: If given, match triples with this object.\n        triple: Deprecated. A `(s, p, o)` tuple where `s`, `p` and `o`\n            should either be None (matching anything) or an exact IRI\n            to match.\n\n    Returns:\n        Generator over all matching triples.\n    \"\"\"\n    # __TODO__: Remove these lines when deprecated\n    if triple or (subject and not isinstance(subject, str)):\n        warnings.warn(\n            \"The `triple` argument is deprecated.  Use `subject`, \"\n            \"`predicate` and `object` arguments instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n    if subject and not isinstance(subject, str):\n        subject, predicate, object = subject\n    elif triple:\n        subject, predicate, object = triple\n\n    return self.backend.triples((subject, predicate, object))\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.update","title":"<code>update(self, update_object, **kwargs)</code>","text":"<p>Update triplestore with SPARQL.</p> <p>Parameters:</p> Name Type Description Default <code>update_object</code> <p>String with the SPARQL query.</p> required <code>kwargs</code> <p>Keyword arguments passed to the backend update() method.</p> <code>{}</code> <p>Note</p> <p>This method is intended for INSERT and DELETE queries. Use the query() method for SELECT, ASK, CONSTRUCT and DESCRIBE queries.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def update(self, update_object, **kwargs) -&gt; None:\n    \"\"\"Update triplestore with SPARQL.\n\n    Parameters:\n        update_object: String with the SPARQL query.\n        kwargs: Keyword arguments passed to the backend update() method.\n\n    Note:\n        This method is intended for INSERT and DELETE queries. Use\n        the query() method for SELECT, ASK, CONSTRUCT and DESCRIBE queries.\n\n    \"\"\"\n    self._check_method(\"update\")\n    return self.backend.update(update_object=update_object, **kwargs)\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.value","title":"<code>value(self, subject=None, predicate=None, object=None, default=None, any=False, lang=None)</code>","text":"<p>Return the value for a pair of two criteria.</p> <p>Useful if one knows that there may only be one value. Two of <code>subject</code>, <code>predicate</code> or <code>object</code> must be provided.</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <p>Possible criteria to match.</p> <code>None</code> <code>predicate</code> <p>Possible criteria to match.</p> <code>None</code> <code>object</code> <p>Possible criteria to match.</p> <code>None</code> <code>default</code> <p>Value to return if no matches are found.</p> <code>None</code> <code>any</code> <p>If true, return any matching value, otherwise raise UniquenessError.</p> <code>False</code> <code>lang</code> <p>If provided, require that the value must be a localised literal with the given language code.</p> <code>None</code> <p>Returns:</p> Type Description <code>'Union[str, Literal]'</code> <p>The value of the <code>subject</code>, <code>predicate</code> or <code>object</code> that is None.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def value(  # pylint: disable=redefined-builtin\n    self,\n    subject=None,\n    predicate=None,\n    object=None,\n    default=None,\n    any=False,\n    lang=None,\n) -&gt; \"Union[str, Literal]\":\n    \"\"\"Return the value for a pair of two criteria.\n\n    Useful if one knows that there may only be one value.\n    Two of `subject`, `predicate` or `object` must be provided.\n\n    Parameters:\n        subject: Possible criteria to match.\n        predicate: Possible criteria to match.\n        object: Possible criteria to match.\n        default: Value to return if no matches are found.\n        any: If true, return any matching value, otherwise raise\n            UniquenessError.\n        lang: If provided, require that the value must be a localised\n            literal with the given language code.\n\n    Returns:\n        The value of the `subject`, `predicate` or `object` that is\n        None.\n    \"\"\"\n    spo = (subject, predicate, object)\n    if sum(iri is None for iri in spo) != 1:\n        raise ValueError(\n            \"Exactly one of `subject`, `predicate` or `object` must be \"\n            \"None.\"\n        )\n\n    # Index of subject-predicate-object argument that is None\n    (idx,) = [i for i, v in enumerate(spo) if v is None]\n\n    triples = self.triples(subject, predicate, object)\n    if lang:\n        first = None\n        if idx != 2:\n            raise ValueError(\"`object` must be None if `lang` is given\")\n        for triple in triples:\n            value = triple[idx]\n            if isinstance(value, Literal) and value.lang == lang:\n                if any:\n                    return value\n                if first:\n                    raise UniquenessError(\"More than one match\")\n                first = value\n        if first is None:\n            return default\n    else:\n        try:\n            triple = next(triples)\n        except StopIteration:\n            return default\n\n    try:\n        next(triples)\n    except StopIteration:\n        return triple[idx]\n\n    if any:\n        return triple[idx]\n    raise UniquenessError(\"More than one match\")\n</code></pre>"},{"location":"api_reference/tripper/","title":"tripper","text":"<p>A module that adds additional functionality to triplestore</p>"},{"location":"api_reference/tripper/#tripper.tripper.Tripper","title":"<code> Tripper            (Triplestore)         </code>","text":"<p>Class that provides additional methods for handling data in the triplestore, such as get_value, add_data and add_interpolation_source.</p> Source code in <code>tripper/tripper.py</code> <pre><code>class Tripper(Triplestore):\n    \"\"\"\n    Class that provides additional\n    methods for handling data in the triplestore,\n    such as get_value, add_data and add_interpolation_source.\n    \"\"\"\n\n    def add_data(\n        self,\n        func: \"Union[Callable, Literal]\",\n        iri: \"Optional[Union[str, Sequence]]\" = None,\n        configurations: \"Optional[dict]\" = None,\n        base_iri: \"Optional[str]\" = None,\n        standard: str = \"emmo\",\n        cost: \"Optional[Union[float, Callable]]\" = None,\n    ) -&gt; str:\n        \"\"\"Register a data source to the triplestore.\n\n        Parameters:\n            func: A callable that should return the value of the registered\n                data source.  It is called with following protopype:\n\n                    func(returns, configurations, triplestore)\n\n                The returned value may in principle be of any type, but for\n                values with unit, it is recommended to return a\n                tripper.mappings.Value object.\n                Alternatively, `func` may also be a literal value.\n            iri: IRI of ontological concept or individual that the data\n                returned by `func` should be mapped to.  If `func` is a\n                callable and multiple values are returned, it may also be\n                given as a sequenceof IRIs.\n                If not given, it will default to a new blank node.\n            configurations: Configurations passed on to `func`.\n            base_iri: Base of the IRI representing the function in the\n                knowledge base.  Defaults to the base IRI of the triplestore.\n            standard: Name of ontological standard to use when describing the\n                function.  Valid values are:\n                - \"emmo\": Elementary Multiperspective Material Ontology (EMMO)\n                - \"fno\": Function Ontology (FnO)\n            cost: User-defined cost of following this mapping relation\n                represented as a float.  It may be given either as a\n                float or as a callable taking the same arguments as `func`\n                returning the cost as a float.\n\n        Returns:\n            IRI of data source.\n        \"\"\"\n        if iri is None:\n            # pylint complains about uuid being unused if we make this an\n            # f-string\n            iri = \"_bnode_\" + str(uuid.uuid4())\n        data_source = \"_data_source_\" + random_string(8)\n        self.add((data_source, RDF.type, DataSource))\n\n        if isinstance(func, Literal):\n            self.add((data_source, hasDataValue, func))\n            if cost is not None:\n                self._add_cost(cost, data_source)\n            if isinstance(iri, str):\n                self.map(data_source, iri)\n            else:\n                raise TypeError(\"literal data can only have a single `iri`\")\n\n        elif callable(func):\n\n            def fn():\n                return func(iri, configurations, self)\n\n            # Include data source IRI in documentation to ensure that the\n            # function_id of `fn()` will differ for different data sources...\n            fn.__doc__ = (\n                f\"Function for data source: {data_source}.\\n\\n{func.__doc__}\"\n            )\n            fn.__name__ = func.__name__\n\n            func_iri = self.add_function(\n                fn,\n                expects=(),\n                returns=iri,\n                base_iri=base_iri,\n                standard=standard,\n                cost=cost,\n            )\n            self.add((data_source, hasAccessFunction, func_iri))\n        else:\n            raise TypeError(\n                f\"`func` must be a callable or literal, got {type(func)}\"\n            )\n\n        return data_source\n\n    def get_value(\n        self,\n        iri,\n        routeno=0,\n        unit: \"Optional[str]\" = None,\n        magnitude: bool = False,\n        quantity: \"Optional[Any]\" = None,\n        **kwargs,\n    ) -&gt; \"Value\":\n        \"\"\"Return the value of an individual.\n\n        Parameters:\n            iri: IRI of individual who's value we want to return.  IRI may\n                either refer to a data source or an individual mapped to\n                an ontological concept.\n            routeno: Number identifying the mapping route to apply for\n                retrieving the individual value in case IRI does not refer\n                to a data source.\n            unit: return the result in the given unit.\n                Implies `magnitude=True`.\n            magnitude: Whether to only return the magnitude of the evaluated\n                value (with no unit).\n            quantity: Quantity class to use for evaluation.  Defaults to pint.\n            kwargs: Additional arguments passed on to `mapping_routes()`.\n\n        Returns:\n            The value of the individual.\n        \"\"\"\n        from tripper.mappings import (  # pylint: disable=import-outside-toplevel\n            Value,\n            mapping_routes,\n        )\n\n        if self.has(iri, RDF.type, DataSource):\n            # `iri` refer to a DataSource\n            if self.has(iri, hasDataValue):  # literal value\n                return Value(\n                    value=parse_literal(\n                        self.value(iri, hasDataValue)\n                    ).to_python(),\n                    unit=(\n                        parse_literal(self.value(iri, hasUnit)).to_python()\n                        if self.has(iri, hasUnit)\n                        else None\n                    ),\n                    iri=self.value(iri, MAP.mapsTo),\n                    cost=(\n                        parse_literal(self.value(iri, hasCost)).to_python()\n                        if self.has(iri, hasCost)\n                        else 0.0\n                    ),\n                ).get_value(unit=unit, magnitude=magnitude, quantity=quantity)\n\n            if self.has(iri, hasAccessFunction):  # callable\n                func_iri = self.value(iri, hasAccessFunction)\n                func = self.function_repo[func_iri]\n                assert callable(func)  # nosec\n                retval = func()\n                if isinstance(retval, Value):\n                    return retval.get_value(\n                        unit=unit, magnitude=magnitude, quantity=quantity\n                    )\n                return retval\n\n            raise TriplestoreError(\n                f\"data source {iri} has neither a 'hasDataValue' or a \"\n                f\"'hasAccessFunction' property\"\n            )\n\n        # `iri` correspond to an individual mapped to an ontological concept.\n        # In this case we check if there exists a mapping route.\n        routes = mapping_routes(\n            target=iri,\n            sources=list(self.subjects(RDF.type, DataSource)),\n            triplestore=self,\n            **kwargs,\n        )\n        if isinstance(routes, Value):\n            return routes.get_value(\n                unit=unit, magnitude=magnitude, quantity=quantity\n            )\n        return routes.eval(\n            routeno=routeno,\n            unit=unit,\n            magnitude=magnitude,\n            quantity=quantity,\n        )\n\n    def add_interpolation_source(  # pylint: disable=too-many-arguments\n        self,\n        xcoord: str,\n        ycoord: str,\n        input_iri: str,\n        output_iri: str,\n        base_iri: \"Optional[str]\" = None,\n        standard: str = \"emmo\",\n        cost: \"Optional[Union[float, Callable]]\" = None,\n        left: \"Optional[float]\" = None,\n        right: \"Optional[float]\" = None,\n        period: \"Optional[float]\" = None,\n    ) -&gt; str:\n        \"\"\"Add data source to triplestore, such that it can be used to\n        transparently transform other data.\n\n        No data will be fetch before it is actually needed.\n\n        Parameters:\n            xcoord: IRI of data source with x-coordinates `xp`.  Must be\n                increasing if argument `period` is not specified. Otherwise,\n                `xp` is internally sorted after normalising the periodic\n                boundaries with ``xp = xp % period``.\n            ycoord: IRI of data source with y-coordinates `yp`.  Must have\n                the same length as `xp`.\n            input_iri: IRI of ontological concept that interpolation input-\n                data should be mapped to.\n            output_iri: IRI of ontological concept that interpolation output-\n                data should be mapped to.\n            base_iri: Base of the IRI representing the transformation in the\n                knowledge base.  Defaults to the base IRI of the triplestore.\n            standard: Name of ontology to use when describing the\n                transformation.  Valid values are:\n                - \"emmo\": Elementary Multiperspective Material Ontology (EMMO)\n                - \"fno\": Function Ontology (FnO)\n            cost: User-defined cost of following this mapping relation\n                represented as a float.  It may be given either as a\n                float or as a callable taking the same arguments as `func`\n                returning the cost as a float.\n            left: Value to return for `x &lt; xp[0]`, default is `fp[0]`.\n            right: Value to return for `x &gt; xp[-1]`, default is `fp[-1]`.\n            period: A period for the x-coordinates. This parameter allows the\n                proper interpolation of angular x-coordinates. Parameters\n                `left` and `right` are ignored if `period` is specified.\n\n        Returns:\n            transformation_iri: IRI of the added transformation.\n\n        \"\"\"\n        try:\n            import numpy as np  # pylint: disable=import-outside-toplevel\n        except ImportError as exc:\n            raise RuntimeError(\n                \"Triplestore.add_interpolation_source() requires numpy.\\n\"\n                \"Install it with\\n\\n\"\n                \"    pip install numpy\"\n            ) from exc\n\n        def func(x):\n            xp = self.get_value(xcoord)\n            fp = self.get_value(ycoord)\n            return np.interp(\n                x,\n                xp=xp,\n                fp=fp,\n                left=left,\n                right=right,\n                period=period,\n            )\n\n        return self.add_function(\n            func,\n            expects=input_iri,\n            returns=output_iri,\n            base_iri=base_iri,\n            standard=standard,\n            cost=cost,\n        )\n</code></pre>"},{"location":"api_reference/tripper/#tripper.tripper.Tripper.add_data","title":"<code>add_data(self, func, iri=None, configurations=None, base_iri=None, standard='emmo', cost=None)</code>","text":"<p>Register a data source to the triplestore.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>'Union[Callable, Literal]'</code> <p>A callable that should return the value of the registered data source.  It is called with following protopype:</p> <pre><code>func(returns, configurations, triplestore)\n</code></pre> <p>The returned value may in principle be of any type, but for values with unit, it is recommended to return a tripper.mappings.Value object. Alternatively, <code>func</code> may also be a literal value.</p> required <code>iri</code> <code>'Optional[Union[str, Sequence]]'</code> <p>IRI of ontological concept or individual that the data returned by <code>func</code> should be mapped to.  If <code>func</code> is a callable and multiple values are returned, it may also be given as a sequenceof IRIs. If not given, it will default to a new blank node.</p> <code>None</code> <code>configurations</code> <code>'Optional[dict]'</code> <p>Configurations passed on to <code>func</code>.</p> <code>None</code> <code>base_iri</code> <code>'Optional[str]'</code> <p>Base of the IRI representing the function in the knowledge base.  Defaults to the base IRI of the triplestore.</p> <code>None</code> <code>standard</code> <code>str</code> <p>Name of ontological standard to use when describing the function.  Valid values are: - \"emmo\": Elementary Multiperspective Material Ontology (EMMO) - \"fno\": Function Ontology (FnO)</p> <code>'emmo'</code> <code>cost</code> <code>'Optional[Union[float, Callable]]'</code> <p>User-defined cost of following this mapping relation represented as a float.  It may be given either as a float or as a callable taking the same arguments as <code>func</code> returning the cost as a float.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>IRI of data source.</p> Source code in <code>tripper/tripper.py</code> <pre><code>def add_data(\n    self,\n    func: \"Union[Callable, Literal]\",\n    iri: \"Optional[Union[str, Sequence]]\" = None,\n    configurations: \"Optional[dict]\" = None,\n    base_iri: \"Optional[str]\" = None,\n    standard: str = \"emmo\",\n    cost: \"Optional[Union[float, Callable]]\" = None,\n) -&gt; str:\n    \"\"\"Register a data source to the triplestore.\n\n    Parameters:\n        func: A callable that should return the value of the registered\n            data source.  It is called with following protopype:\n\n                func(returns, configurations, triplestore)\n\n            The returned value may in principle be of any type, but for\n            values with unit, it is recommended to return a\n            tripper.mappings.Value object.\n            Alternatively, `func` may also be a literal value.\n        iri: IRI of ontological concept or individual that the data\n            returned by `func` should be mapped to.  If `func` is a\n            callable and multiple values are returned, it may also be\n            given as a sequenceof IRIs.\n            If not given, it will default to a new blank node.\n        configurations: Configurations passed on to `func`.\n        base_iri: Base of the IRI representing the function in the\n            knowledge base.  Defaults to the base IRI of the triplestore.\n        standard: Name of ontological standard to use when describing the\n            function.  Valid values are:\n            - \"emmo\": Elementary Multiperspective Material Ontology (EMMO)\n            - \"fno\": Function Ontology (FnO)\n        cost: User-defined cost of following this mapping relation\n            represented as a float.  It may be given either as a\n            float or as a callable taking the same arguments as `func`\n            returning the cost as a float.\n\n    Returns:\n        IRI of data source.\n    \"\"\"\n    if iri is None:\n        # pylint complains about uuid being unused if we make this an\n        # f-string\n        iri = \"_bnode_\" + str(uuid.uuid4())\n    data_source = \"_data_source_\" + random_string(8)\n    self.add((data_source, RDF.type, DataSource))\n\n    if isinstance(func, Literal):\n        self.add((data_source, hasDataValue, func))\n        if cost is not None:\n            self._add_cost(cost, data_source)\n        if isinstance(iri, str):\n            self.map(data_source, iri)\n        else:\n            raise TypeError(\"literal data can only have a single `iri`\")\n\n    elif callable(func):\n\n        def fn():\n            return func(iri, configurations, self)\n\n        # Include data source IRI in documentation to ensure that the\n        # function_id of `fn()` will differ for different data sources...\n        fn.__doc__ = (\n            f\"Function for data source: {data_source}.\\n\\n{func.__doc__}\"\n        )\n        fn.__name__ = func.__name__\n\n        func_iri = self.add_function(\n            fn,\n            expects=(),\n            returns=iri,\n            base_iri=base_iri,\n            standard=standard,\n            cost=cost,\n        )\n        self.add((data_source, hasAccessFunction, func_iri))\n    else:\n        raise TypeError(\n            f\"`func` must be a callable or literal, got {type(func)}\"\n        )\n\n    return data_source\n</code></pre>"},{"location":"api_reference/tripper/#tripper.tripper.Tripper.add_interpolation_source","title":"<code>add_interpolation_source(self, xcoord, ycoord, input_iri, output_iri, base_iri=None, standard='emmo', cost=None, left=None, right=None, period=None)</code>","text":"<p>Add data source to triplestore, such that it can be used to transparently transform other data.</p> <p>No data will be fetch before it is actually needed.</p> <p>Parameters:</p> Name Type Description Default <code>xcoord</code> <code>str</code> <p>IRI of data source with x-coordinates <code>xp</code>.  Must be increasing if argument <code>period</code> is not specified. Otherwise, <code>xp</code> is internally sorted after normalising the periodic boundaries with <code>xp = xp % period</code>.</p> required <code>ycoord</code> <code>str</code> <p>IRI of data source with y-coordinates <code>yp</code>.  Must have the same length as <code>xp</code>.</p> required <code>input_iri</code> <code>str</code> <p>IRI of ontological concept that interpolation input- data should be mapped to.</p> required <code>output_iri</code> <code>str</code> <p>IRI of ontological concept that interpolation output- data should be mapped to.</p> required <code>base_iri</code> <code>'Optional[str]'</code> <p>Base of the IRI representing the transformation in the knowledge base.  Defaults to the base IRI of the triplestore.</p> <code>None</code> <code>standard</code> <code>str</code> <p>Name of ontology to use when describing the transformation.  Valid values are: - \"emmo\": Elementary Multiperspective Material Ontology (EMMO) - \"fno\": Function Ontology (FnO)</p> <code>'emmo'</code> <code>cost</code> <code>'Optional[Union[float, Callable]]'</code> <p>User-defined cost of following this mapping relation represented as a float.  It may be given either as a float or as a callable taking the same arguments as <code>func</code> returning the cost as a float.</p> <code>None</code> <code>left</code> <code>'Optional[float]'</code> <p>Value to return for <code>x &lt; xp[0]</code>, default is <code>fp[0]</code>.</p> <code>None</code> <code>right</code> <code>'Optional[float]'</code> <p>Value to return for <code>x &gt; xp[-1]</code>, default is <code>fp[-1]</code>.</p> <code>None</code> <code>period</code> <code>'Optional[float]'</code> <p>A period for the x-coordinates. This parameter allows the proper interpolation of angular x-coordinates. Parameters <code>left</code> and <code>right</code> are ignored if <code>period</code> is specified.</p> <code>None</code> <p>Returns:</p> Type Description <code>transformation_iri</code> <p>IRI of the added transformation.</p> Source code in <code>tripper/tripper.py</code> <pre><code>def add_interpolation_source(  # pylint: disable=too-many-arguments\n    self,\n    xcoord: str,\n    ycoord: str,\n    input_iri: str,\n    output_iri: str,\n    base_iri: \"Optional[str]\" = None,\n    standard: str = \"emmo\",\n    cost: \"Optional[Union[float, Callable]]\" = None,\n    left: \"Optional[float]\" = None,\n    right: \"Optional[float]\" = None,\n    period: \"Optional[float]\" = None,\n) -&gt; str:\n    \"\"\"Add data source to triplestore, such that it can be used to\n    transparently transform other data.\n\n    No data will be fetch before it is actually needed.\n\n    Parameters:\n        xcoord: IRI of data source with x-coordinates `xp`.  Must be\n            increasing if argument `period` is not specified. Otherwise,\n            `xp` is internally sorted after normalising the periodic\n            boundaries with ``xp = xp % period``.\n        ycoord: IRI of data source with y-coordinates `yp`.  Must have\n            the same length as `xp`.\n        input_iri: IRI of ontological concept that interpolation input-\n            data should be mapped to.\n        output_iri: IRI of ontological concept that interpolation output-\n            data should be mapped to.\n        base_iri: Base of the IRI representing the transformation in the\n            knowledge base.  Defaults to the base IRI of the triplestore.\n        standard: Name of ontology to use when describing the\n            transformation.  Valid values are:\n            - \"emmo\": Elementary Multiperspective Material Ontology (EMMO)\n            - \"fno\": Function Ontology (FnO)\n        cost: User-defined cost of following this mapping relation\n            represented as a float.  It may be given either as a\n            float or as a callable taking the same arguments as `func`\n            returning the cost as a float.\n        left: Value to return for `x &lt; xp[0]`, default is `fp[0]`.\n        right: Value to return for `x &gt; xp[-1]`, default is `fp[-1]`.\n        period: A period for the x-coordinates. This parameter allows the\n            proper interpolation of angular x-coordinates. Parameters\n            `left` and `right` are ignored if `period` is specified.\n\n    Returns:\n        transformation_iri: IRI of the added transformation.\n\n    \"\"\"\n    try:\n        import numpy as np  # pylint: disable=import-outside-toplevel\n    except ImportError as exc:\n        raise RuntimeError(\n            \"Triplestore.add_interpolation_source() requires numpy.\\n\"\n            \"Install it with\\n\\n\"\n            \"    pip install numpy\"\n        ) from exc\n\n    def func(x):\n        xp = self.get_value(xcoord)\n        fp = self.get_value(ycoord)\n        return np.interp(\n            x,\n            xp=xp,\n            fp=fp,\n            left=left,\n            right=right,\n            period=period,\n        )\n\n    return self.add_function(\n        func,\n        expects=input_iri,\n        returns=output_iri,\n        base_iri=base_iri,\n        standard=standard,\n        cost=cost,\n    )\n</code></pre>"},{"location":"api_reference/tripper/#tripper.tripper.Tripper.get_value","title":"<code>get_value(self, iri, routeno=0, unit=None, magnitude=False, quantity=None, **kwargs)</code>","text":"<p>Return the value of an individual.</p> <p>Parameters:</p> Name Type Description Default <code>iri</code> <p>IRI of individual who's value we want to return.  IRI may either refer to a data source or an individual mapped to an ontological concept.</p> required <code>routeno</code> <p>Number identifying the mapping route to apply for retrieving the individual value in case IRI does not refer to a data source.</p> <code>0</code> <code>unit</code> <code>'Optional[str]'</code> <p>return the result in the given unit. Implies <code>magnitude=True</code>.</p> <code>None</code> <code>magnitude</code> <code>bool</code> <p>Whether to only return the magnitude of the evaluated value (with no unit).</p> <code>False</code> <code>quantity</code> <code>'Optional[Any]'</code> <p>Quantity class to use for evaluation.  Defaults to pint.</p> <code>None</code> <code>kwargs</code> <p>Additional arguments passed on to <code>mapping_routes()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>'Value'</code> <p>The value of the individual.</p> Source code in <code>tripper/tripper.py</code> <pre><code>def get_value(\n    self,\n    iri,\n    routeno=0,\n    unit: \"Optional[str]\" = None,\n    magnitude: bool = False,\n    quantity: \"Optional[Any]\" = None,\n    **kwargs,\n) -&gt; \"Value\":\n    \"\"\"Return the value of an individual.\n\n    Parameters:\n        iri: IRI of individual who's value we want to return.  IRI may\n            either refer to a data source or an individual mapped to\n            an ontological concept.\n        routeno: Number identifying the mapping route to apply for\n            retrieving the individual value in case IRI does not refer\n            to a data source.\n        unit: return the result in the given unit.\n            Implies `magnitude=True`.\n        magnitude: Whether to only return the magnitude of the evaluated\n            value (with no unit).\n        quantity: Quantity class to use for evaluation.  Defaults to pint.\n        kwargs: Additional arguments passed on to `mapping_routes()`.\n\n    Returns:\n        The value of the individual.\n    \"\"\"\n    from tripper.mappings import (  # pylint: disable=import-outside-toplevel\n        Value,\n        mapping_routes,\n    )\n\n    if self.has(iri, RDF.type, DataSource):\n        # `iri` refer to a DataSource\n        if self.has(iri, hasDataValue):  # literal value\n            return Value(\n                value=parse_literal(\n                    self.value(iri, hasDataValue)\n                ).to_python(),\n                unit=(\n                    parse_literal(self.value(iri, hasUnit)).to_python()\n                    if self.has(iri, hasUnit)\n                    else None\n                ),\n                iri=self.value(iri, MAP.mapsTo),\n                cost=(\n                    parse_literal(self.value(iri, hasCost)).to_python()\n                    if self.has(iri, hasCost)\n                    else 0.0\n                ),\n            ).get_value(unit=unit, magnitude=magnitude, quantity=quantity)\n\n        if self.has(iri, hasAccessFunction):  # callable\n            func_iri = self.value(iri, hasAccessFunction)\n            func = self.function_repo[func_iri]\n            assert callable(func)  # nosec\n            retval = func()\n            if isinstance(retval, Value):\n                return retval.get_value(\n                    unit=unit, magnitude=magnitude, quantity=quantity\n                )\n            return retval\n\n        raise TriplestoreError(\n            f\"data source {iri} has neither a 'hasDataValue' or a \"\n            f\"'hasAccessFunction' property\"\n        )\n\n    # `iri` correspond to an individual mapped to an ontological concept.\n    # In this case we check if there exists a mapping route.\n    routes = mapping_routes(\n        target=iri,\n        sources=list(self.subjects(RDF.type, DataSource)),\n        triplestore=self,\n        **kwargs,\n    )\n    if isinstance(routes, Value):\n        return routes.get_value(\n            unit=unit, magnitude=magnitude, quantity=quantity\n        )\n    return routes.eval(\n        routeno=routeno,\n        unit=unit,\n        magnitude=magnitude,\n        quantity=quantity,\n    )\n</code></pre>"},{"location":"api_reference/utils/","title":"utils","text":"<p>Utility functions.</p>"},{"location":"api_reference/utils/#tripper.utils.as_python","title":"<code>as_python(value)</code>","text":"<p>Converts <code>value</code> to a native Python representation.</p> <p>If <code>value</code> is a Literal, its Python representation will be returned. If <code>value</code> is a string, it will first be converted to a Literal, before its Python representation is returned. Otherwise, <code>value</code> will be returned as-is.</p> Source code in <code>tripper/utils.py</code> <pre><code>def as_python(value: \"Any\") -&gt; \"Any\":\n    \"\"\"Converts `value` to a native Python representation.\n\n    If `value` is a Literal, its Python representation will be returned.\n    If `value` is a string, it will first be converted to a Literal, before\n    its Python representation is returned.\n    Otherwise, `value` will be returned as-is.\n    \"\"\"\n    if isinstance(value, Literal):\n        return value.to_python()\n    if isinstance(value, str):\n        return parse_literal(value).to_python()\n    return value\n</code></pre>"},{"location":"api_reference/utils/#tripper.utils.bnode_iri","title":"<code>bnode_iri(prefix='', source='', length=5)</code>","text":"<p>Returns a new IRI for a blank node.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>A prefix to insert between \"_:\" and the hash.</p> <code>''</code> <code>source</code> <code>str</code> <p>An unique string that the returned bnode will be a hash of. The default is to generate a random hash.</p> <code>''</code> <code>length</code> <code>int</code> <p>Length is the number of bytes in the hash.  The default length of 5 is a compromise between readability (10 characters) and safety (corresponding to about 1e12 possibilites).  You can change it to 16 to get 128 bits, corresponding to the uniqueness of UUIDs).  It makes no sense to go beyond 32, because that is the maximum of the underlying shake_128 algorithm.</p> <code>5</code> <p>Returns:</p> Type Description <code>A new bnode IRI of the form \"_</code> <p>\", where <code>&lt;prefix&gt;</code> is <code>prefix</code> and <code>&lt;hash&gt;</code> is a hex-encoded hash of <code>source</code>. Source code in <code>tripper/utils.py</code> <pre><code>def bnode_iri(prefix: str = \"\", source: str = \"\", length: int = 5) -&gt; str:\n    \"\"\"Returns a new IRI for a blank node.\n\n    Parameters:\n        prefix: A prefix to insert between \"_:\" and the hash.\n        source: An unique string that the returned bnode will be a hash of.\n            The default is to generate a random hash.\n        length: Length is the number of bytes in the hash.  The default\n            length of 5 is a compromise between readability (10 characters)\n            and safety (corresponding to about 1e12 possibilites).  You can\n            change it to 16 to get 128 bits, corresponding to the uniqueness\n            of UUIDs).  It makes no sense to go beyond 32, because that is\n            the maximum of the underlying shake_128 algorithm.\n\n    Returns:\n        A new bnode IRI of the form \"_:&lt;prefix&gt;&lt;hash&gt;\", where `&lt;prefix&gt;`\n        is `prefix` and `&lt;hash&gt;` is a hex-encoded hash of `source`.\n    \"\"\"\n    if source:\n        hash = hashlib.shake_128(source.encode()).hexdigest(length)\n    else:\n        # From Python 3.9 we can use random.randbytes(length).hex()\n        hash = \"\".join(\n            hex(random.randint(0, 255))[2:] for i in range(length)  # nosec\n        )\n    return f\"_:{prefix}{hash}\"\n</code></pre>"},{"location":"api_reference/utils/#tripper.utils.check_function","title":"<code>check_function(func, s, exceptions)</code>","text":"<p>Help function returning true if <code>func(s)</code> does not raise an exception.</p> <p>False is returned if <code>func(s)</code> raises an exception listed in <code>exceptions</code>. Otherwise the exception is propagated.</p> Source code in <code>tripper/utils.py</code> <pre><code>def check_function(func: \"Callable\", s: str, exceptions) -&gt; bool:\n    \"\"\"Help function returning true if `func(s)` does not raise an exception.\n\n    False is returned if `func(s)` raises an exception listed in `exceptions`.\n    Otherwise the exception is propagated.\n    \"\"\"\n    # Note that the missing type hint on `exceptions` is deliberate, see\n    # https://peps.python.org/pep-0484/#exceptions\n    try:\n        func(s)\n    except exceptions:\n        return False\n    return True\n</code></pre>"},{"location":"api_reference/utils/#tripper.utils.en","title":"<code>en(value)</code>","text":"<p>Convenience function that returns value as a plain english literal.</p> <p>Equivalent to <code>Literal(value, lang=\"en\")</code>.</p> Source code in <code>tripper/utils.py</code> <pre><code>def en(value) -&gt; \"Literal\":  # pylint: disable=invalid-name\n    \"\"\"Convenience function that returns value as a plain english literal.\n\n    Equivalent to ``Literal(value, lang=\"en\")``.\n    \"\"\"\n    return Literal(value, lang=\"en\")\n</code></pre>"},{"location":"api_reference/utils/#tripper.utils.extend_namespace","title":"<code>extend_namespace(namespace, triplestore, format=None)</code>","text":"<p>Extend a namespace with additional known names.</p> <p>This makes only sense if the namespace was created with <code>label_annotations</code> or <code>check</code> set to true.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>Namespace</code> <p>The namespace to extend.</p> required <code>triplestore</code> <code>Union[Triplestore, str, Path, dict]</code> <p>Source from which to extend the namespace. It can be of one of the following types:   - Triplestore: triplestore object to read from   - str: URL to a triplestore to read from.  May also be a     path to a local file to read from   - Path: path to a local file to read from   - dict: dict mapping new IRI names to their corresponding IRIs</p> required <code>format</code> <code>Optional[str]</code> <p>Format to use when loading from a triplestore.</p> <code>None</code> Source code in <code>tripper/utils.py</code> <pre><code>def extend_namespace(\n    namespace: Namespace,\n    triplestore: \"Union[Triplestore, str, Path, dict]\",\n    format: \"Optional[str]\" = None,\n):\n    \"\"\"Extend a namespace with additional known names.\n\n    This makes only sense if the namespace was created with\n    `label_annotations` or `check` set to true.\n\n    Arguments:\n        namespace: The namespace to extend.\n        triplestore: Source from which to extend the namespace. It can be\n            of one of the following types:\n              - Triplestore: triplestore object to read from\n              - str: URL to a triplestore to read from.  May also be a\n                path to a local file to read from\n              - Path: path to a local file to read from\n              - dict: dict mapping new IRI names to their corresponding IRIs\n        format: Format to use when loading from a triplestore.\n    \"\"\"\n    if namespace._iris is None:  # pylint: disable=protected-access\n        raise TypeError(\n            \"only namespaces created with `label_annotations` or `check` set \"\n            \"to true can be extend\"\n        )\n    if isinstance(triplestore, dict):\n        namespace._iris.update(triplestore)  # pylint: disable=protected-access\n    else:\n        namespace._update_iris(  # pylint: disable=protected-access\n            triplestore, reload=True, format=format\n        )\n</code></pre>"},{"location":"api_reference/utils/#tripper.utils.function_id","title":"<code>function_id(func, length=4)</code>","text":"<p>Return a checksum for function <code>func</code>.</p> <p>The returned object is a string of hexadecimal digits.</p> <p><code>length</code> is the number of bytes in the returned checksum.  Since the current implementation is based on the shake_128 algorithm, it make no sense to set <code>length</code> larger than 32 bytes.</p> Source code in <code>tripper/utils.py</code> <pre><code>def function_id(func: \"Callable\", length: int = 4) -&gt; str:\n    \"\"\"Return a checksum for function `func`.\n\n    The returned object is a string of hexadecimal digits.\n\n    `length` is the number of bytes in the returned checksum.  Since\n    the current implementation is based on the shake_128 algorithm,\n    it make no sense to set `length` larger than 32 bytes.\n    \"\"\"\n    source = inspect.getsource(func)\n    doc = func.__doc__ if func.__doc__ else \"\"\n    return hashlib.shake_128(  # pylint: disable=too-many-function-args\n        (source + doc).encode()\n    ).hexdigest(length)\n</code></pre>"},{"location":"api_reference/utils/#tripper.utils.infer_iri","title":"<code>infer_iri(obj)</code>","text":"<p>Return IRI of the individual that stands for Python object <code>obj</code>.</p> <p>Valid Python objects are DLite and Pydantic instances.</p> <p>References:</p> Source code in <code>tripper/utils.py</code> <pre><code>def infer_iri(obj):\n    \"\"\"Return IRI of the individual that stands for Python object `obj`.\n\n    Valid Python objects are [DLite] and [Pydantic] instances.\n\n    References:\n\n    [DLite]: https://github.com/SINTEF/dlite\n    [Pydantic]: https://docs.pydantic.dev/\n    \"\"\"\n\n    # Please note that tripper does not depend on neither DLite nor Pydantic.\n    # Hence neither of these packages are imported.  However, due to duck-\n    # typing, infer_iri() is still able to recognise DLite and Pydantic\n    # objects and infer their IRIs.\n\n    if isinstance(obj, str):\n        iri = obj\n    elif hasattr(obj, \"uri\") and isinstance(obj.uri, str):\n        # dlite.Metadata or dataclass (or instance with uri)\n        iri = obj.uri\n    elif hasattr(obj, \"uuid\") and obj.uuid:\n        # dlite.Instance or dataclass\n        iri = str(obj.uuid)\n    elif hasattr(obj, \"schema\") and callable(obj.schema):\n        # pydantic.BaseModel\n        if hasattr(obj, \"identity\") and isinstance(obj.identity, str):\n            # soft7 pydantic model\n            iri = obj.identity\n        else:\n            # pydantic instance\n            schema = obj.schema()\n            properties = schema[\"properties\"]\n            if \"uri\" in properties and isinstance(properties[\"uri\"], str):\n                iri = properties[\"uri\"]\n            elif \"identity\" in properties and isinstance(\n                properties[\"identity\"], str\n            ):\n                iri = properties[\"identity\"]\n            elif \"uuid\" in properties and properties[\"uuid\"]:\n                iri = str(properties[\"uuid\"])\n            else:\n                raise TypeError(\n                    f\"cannot infer IRI from pydantic object: {obj!r}\"\n                )\n    else:\n        raise TypeError(f\"cannot infer IRI from object: {obj!r}\")\n    return str(iri)\n</code></pre>"},{"location":"api_reference/utils/#tripper.utils.parse_literal","title":"<code>parse_literal(literal)</code>","text":"<p>Parse Python object <code>literal</code> and return it as an instance of Literal.</p> <p>The main difference between this function and the Literal constructor, is that this function correctly interprets n3-encoded literal strings.</p> Source code in <code>tripper/utils.py</code> <pre><code>def parse_literal(literal: \"Any\") -&gt; \"Any\":\n    \"\"\"Parse Python object `literal` and return it as an instance of Literal.\n\n    The main difference between this function and the Literal constructor,\n    is that this function correctly interprets n3-encoded literal strings.\n    \"\"\"\n    # pylint: disable=invalid-name,too-many-branches,too-many-return-statements\n    lang, datatype = None, None\n\n    if isinstance(literal, Literal):\n        return literal\n\n    if hasattr(literal, \"lang\"):\n        lang = literal.lang\n    elif hasattr(literal, \"language\"):\n        lang = literal.language\n\n    if (\n        not lang\n        and hasattr(literal, \"datatype\")\n        and literal.datatype is not None\n    ):\n        datatype = str(literal.datatype)\n\n    # This should handle rdflib literals correctly (and probably most other\n    # literal representations as well)\n    if hasattr(literal, \"value\"):\n        # Note that in rdflib 6.3, the `value` attribute may be None for some\n        # datatypes (like rdf:JSON) even though a non-empty value exists.\n        # As a workaround, we use the string representation if the value\n        # attribute is None.\n        if literal.value is not None:\n            return Literal(literal.value, lang=lang, datatype=datatype)\n        return Literal(str(literal), lang=lang, datatype=datatype)\n\n    if not isinstance(literal, str):\n        if isinstance(literal, tuple(Literal.datatypes)):\n            return Literal(\n                literal,\n                lang=lang,\n                datatype=Literal.datatypes.get(type(literal))[\n                    0\n                ],  # type: ignore\n            )\n        raise TypeError(f\"unsupported literal type: {type(literal)}\")\n\n    if hasattr(literal, \"n3\") and callable(literal.n3):\n        return parse_literal(literal.n3())\n\n    match = re.match(r'^\\s*(\"\"\"(.*)\"\"\"|\"(.*)\")\\s*$', literal, flags=re.DOTALL)\n    if match:\n        _, v1, v2 = match.groups()\n        value, datatype = v1 if v1 else v2, XSD.string\n    else:\n        match = re.match(\n            r'^\\s*(\"\"\"(.*)\"\"\"|\"(.*)\")\\^\\^(&lt;([^&gt;]+)&gt;|([^&lt;].*))\\s*$',\n            literal,\n            flags=re.DOTALL,\n        )\n        if match:\n            _, v1, v2, _, d1, d2 = match.groups()\n            value = v1 if v1 else v2\n            datatype = d1 if d1 else d2\n        else:\n            match = re.match(\n                r'^\\s*(\"\"\"(.*)\"\"\"|\"(.*)\")@(.*)\\s*$', literal, flags=re.DOTALL\n            )\n            if match:\n                _, v1, v2, lang = match.groups()\n                value = v1 if v1 else v2\n            else:\n                value = literal\n\n    if lang or datatype:\n        if datatype:\n            types = {}\n            for pytype, datatypes in Literal.datatypes.items():\n                types.update({t: pytype for t in datatypes})\n            type_ = types.get(datatype, str)\n            if type_ is bool and value in (\"False\", \"false\", \"0\", 0, False):\n                return Literal(False)\n            try:\n                value = type_(value)\n            except TypeError:\n                pass\n        return Literal(value, lang=lang, datatype=datatype)\n\n    for type_, datatypes in Literal.datatypes.items():\n        if type_ is not bool:\n            try:\n                return Literal(\n                    type_(literal), lang=lang, datatype=datatypes[0]\n                )\n            except (ValueError, TypeError):\n                pass\n\n    raise ValueError(f'cannot parse literal \"{literal}\"')\n</code></pre>"},{"location":"api_reference/utils/#tripper.utils.parse_object","title":"<code>parse_object(obj)</code>","text":"<p>Applies heuristics to parse RDF object <code>obj</code> to an IRI or literal.</p> <p>The following heuristics is performed (in the given order): - If <code>obj</code> is a Literal, it is returned. - If <code>obj</code> is a string and   - starts with \"_:\", it is assumed to be a blank node and returned.   - starts with a scheme, it is asumed to be an IRI and returned.   - can be converted to a float, int or datetime, it is returned     converted to a literal of the corresponding type.   - it is a valid n3 representation, return it as the given type.   - otherwise, return it as a xsd:string literal. - Otherwise, raise an ValueError.</p> <p>Returns     A string if <code>obj</code> is considered to be an IRI, otherwise a     literal.</p> Source code in <code>tripper/utils.py</code> <pre><code>def parse_object(obj: \"Union[str, Literal]\") -&gt; \"Union[str, Any]\":\n    \"\"\"Applies heuristics to parse RDF object `obj` to an IRI or literal.\n\n    The following heuristics is performed (in the given order):\n    - If `obj` is a Literal, it is returned.\n    - If `obj` is a string and\n      - starts with \"_:\", it is assumed to be a blank node and returned.\n      - starts with a scheme, it is asumed to be an IRI and returned.\n      - can be converted to a float, int or datetime, it is returned\n        converted to a literal of the corresponding type.\n      - it is a valid n3 representation, return it as the given type.\n      - otherwise, return it as a xsd:string literal.\n    - Otherwise, raise an ValueError.\n\n    Returns\n        A string if `obj` is considered to be an IRI, otherwise a\n        literal.\n    \"\"\"\n    # pylint: disable=too-many-return-statements\n    if isinstance(obj, Literal):\n        return obj\n    if isinstance(obj, str):\n        if obj.startswith(\"_:\") or re.match(r\"^[a-z]+://\", obj):  # IRI\n            return obj\n        if obj in (\"true\", \"false\"):  # boolean\n            return Literal(obj, datatype=XSD.boolean)\n        if re.match(r\"^\\s*[+-]?\\d+\\s*$\", obj):  # integer\n            return Literal(obj, datatype=XSD.integer)\n        if check_function(float, obj, ValueError):  #  float\n            return Literal(obj, datatype=XSD.double)\n        if check_function(\n            datetime.datetime.fromisoformat, obj, ValueError\n        ):  #  datetime\n            return Literal(obj, datatype=XSD.dateTime)\n        return parse_literal(obj)\n    raise ValueError(\"`obj` should be a literal or a string.\")\n</code></pre>"},{"location":"api_reference/utils/#tripper.utils.random_string","title":"<code>random_string(length=8)</code>","text":"<p>Return a random string of the given length.</p> Source code in <code>tripper/utils.py</code> <pre><code>def random_string(length=8):\n    \"\"\"Return a random string of the given length.\"\"\"\n    letters = string.ascii_letters + string.digits\n    return \"\".join(random.choice(letters) for i in range(length))  # nosec\n</code></pre>"},{"location":"api_reference/utils/#tripper.utils.split_iri","title":"<code>split_iri(iri)</code>","text":"<p>Split iri into namespace and name parts and return them as a tuple.</p> <p>Parameters:</p> Name Type Description Default <code>iri</code> <code>str</code> <p>The IRI to be split.</p> required <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>A split IRI. Split into namespace and name.</p> Source code in <code>tripper/utils.py</code> <pre><code>def split_iri(iri: str) -&gt; \"Tuple[str, str]\":\n    \"\"\"Split iri into namespace and name parts and return them as a tuple.\n\n    Parameters:\n        iri: The IRI to be split.\n\n    Returns:\n        A split IRI. Split into namespace and name.\n\n    \"\"\"\n    if \"#\" in iri:\n        namespace, name = iri.rsplit(\"#\", 1)\n        return f\"{namespace}#\", name\n\n    if \"/\" in iri:\n        namespace, name = iri.rsplit(\"/\", 1)\n        return f\"{namespace}/\", name\n\n    raise ValueError(\"all IRIs should contain a slash\")\n</code></pre>"},{"location":"api_reference/utils/#tripper.utils.tfilter","title":"<code>tfilter(triples, subject=None, predicate=None, object=None)</code>","text":"<p>Filters out non-matching triples.</p> <p>Parameters:</p> Name Type Description Default <code>triples</code> <code>Iterable[Triple]</code> <p>Triples to filter from.</p> required <code>subject</code> <code>Optional[Union[Iterable[str], str]]</code> <p>If given, only keep triples whos subject matches <code>subject</code>. Can be an iterable of subjects.</p> <code>None</code> <code>predicate</code> <code>Optional[Union[Iterable[str], str]]</code> <p>If given, only keep triples whos predicate matches <code>predicate</code>.  Can be an iterable of subjects.</p> <code>None</code> <code>object</code> <code>Optional[Union[Iterable, str, Literal]]</code> <p>If given, only keep triples whos subject matches <code>object</code>. Can be an iterable of objects.</p> <code>None</code> <p>Returns:</p> Type Description <code>Generator[Triple, None, None]</code> <p>A generator over matching triples.</p> Source code in <code>tripper/utils.py</code> <pre><code>def tfilter(\n    triples: \"Iterable[Triple]\",\n    subject: \"Optional[Union[Iterable[str], str]]\" = None,\n    predicate: \"Optional[Union[Iterable[str], str]]\" = None,\n    object: \"Optional[Union[Iterable, str, Literal]]\" = None,\n) -&gt; \"Generator[Triple, None, None]\":\n    \"\"\"Filters out non-matching triples.\n\n    Parameters:\n        triples: Triples to filter from.\n        subject: If given, only keep triples whos subject matches `subject`.\n            Can be an iterable of subjects.\n        predicate: If given, only keep triples whos predicate matches\n            `predicate`.  Can be an iterable of subjects.\n        object: If given, only keep triples whos subject matches `object`.\n            Can be an iterable of objects.\n\n    Returns:\n        A generator over matching triples.\n    \"\"\"\n    for s, p, o in triples:\n        if subject and (\n            s != subject if isinstance(subject, str) else s not in subject\n        ):\n            continue\n        if predicate and (\n            p != predicate\n            if isinstance(predicate, str)\n            else p not in predicate\n        ):\n            continue\n        if object and (\n            o != object\n            if isinstance(object, (str, Literal))\n            else o not in object\n        ):\n            continue\n        yield s, p, o\n</code></pre>"},{"location":"api_reference/backends/collection/","title":"collection","text":"<p>Backend for DLite collections.</p>"},{"location":"api_reference/backends/collection/#tripper.backends.collection.CollectionStrategy","title":"<code> CollectionStrategy        </code>","text":"<p>Triplestore strategy for DLite collections.</p> <p>Parameters:</p> Name Type Description Default <code>base_iri</code> <code>Optional[str]</code> <p>Unused.</p> <code>None</code> <code>database</code> <code>Optional[str]</code> <p>Unused - collection does not support multiple databases.</p> <code>None</code> <code>collection</code> <code>Optional[Union[dlite.Collection, str]]</code> <p>Optional collection from which to initialise the triplestore from.</p> <code>None</code> Source code in <code>tripper/backends/collection.py</code> <pre><code>class CollectionStrategy:\n    \"\"\"Triplestore strategy for DLite collections.\n\n    Arguments:\n        base_iri: Unused.\n        database: Unused - collection does not support multiple databases.\n        collection: Optional collection from which to initialise the\n            triplestore from.\n    \"\"\"\n\n    def __init__(\n        self,\n        base_iri: \"Optional[str]\" = None,\n        database: \"Optional[str]\" = None,\n        collection: \"Optional[Union[dlite.Collection, str]]\" = None,\n    ):\n        # pylint: disable=unused-argument\n        if collection is None:\n            self.collection = dlite.Collection()\n        elif isinstance(collection, str):\n            self.collection = dlite.get_instance(collection)\n            if self.collection.meta.uri != dlite.COLLECTION_ENTITY:\n                raise TypeError(\n                    f\"expected '{collection}' to be a collection, was a \"\n                    f\"{self.collection.meta.uri}\"\n                )\n        elif isinstance(collection, dlite.Collection):\n            self.collection = collection\n        else:\n            raise TypeError(\n                \"`collection` should be None, string or a collection\"\n            )\n\n    def triples(self, triple: \"Triple\") -&gt; \"Generator[Triple, None, None]\":\n        \"\"\"Returns a generator over matching triples.\"\"\"\n        for s, p, o, d in self.collection.get_relations(*triple, rettype=\"T\"):\n            if d:\n                lang = d[1:] if d[0] == \"@\" else None\n                dt = None if lang else d\n                yield s, p, Literal(o, lang=lang, datatype=dt)\n            else:\n                yield s, p, o\n\n    def add_triples(\n        self, triples: \"Union[Sequence[Triple], Generator[Triple, None, None]]\"\n    ):\n        \"\"\"Add a sequence of triples.\"\"\"\n        for s, p, o in triples:\n            v = parse_object(o)\n            obj = v if isinstance(v, str) else str(v.value)\n            d = (\n                None\n                if not isinstance(v, Literal)\n                else f\"@{v.lang}\" if v.lang else v.datatype\n            )\n            self.collection.add_relation(s, p, obj, d)\n\n    def remove(self, triple: \"Triple\"):\n        \"\"\"Remove all matching triples from the backend.\"\"\"\n        s, p, o = triple\n        v = parse_object(o)\n        obj = v if isinstance(v, str) else str(v.value)\n        d = (\n            None\n            if not isinstance(v, Literal)\n            else f\"@{v.lang}\" if v.lang else v.datatype\n        )\n        self.collection.remove_relations(s, p, obj, d)\n</code></pre>"},{"location":"api_reference/backends/collection/#tripper.backends.collection.CollectionStrategy.add_triples","title":"<code>add_triples(self, triples)</code>","text":"<p>Add a sequence of triples.</p> Source code in <code>tripper/backends/collection.py</code> <pre><code>def add_triples(\n    self, triples: \"Union[Sequence[Triple], Generator[Triple, None, None]]\"\n):\n    \"\"\"Add a sequence of triples.\"\"\"\n    for s, p, o in triples:\n        v = parse_object(o)\n        obj = v if isinstance(v, str) else str(v.value)\n        d = (\n            None\n            if not isinstance(v, Literal)\n            else f\"@{v.lang}\" if v.lang else v.datatype\n        )\n        self.collection.add_relation(s, p, obj, d)\n</code></pre>"},{"location":"api_reference/backends/collection/#tripper.backends.collection.CollectionStrategy.remove","title":"<code>remove(self, triple)</code>","text":"<p>Remove all matching triples from the backend.</p> Source code in <code>tripper/backends/collection.py</code> <pre><code>def remove(self, triple: \"Triple\"):\n    \"\"\"Remove all matching triples from the backend.\"\"\"\n    s, p, o = triple\n    v = parse_object(o)\n    obj = v if isinstance(v, str) else str(v.value)\n    d = (\n        None\n        if not isinstance(v, Literal)\n        else f\"@{v.lang}\" if v.lang else v.datatype\n    )\n    self.collection.remove_relations(s, p, obj, d)\n</code></pre>"},{"location":"api_reference/backends/collection/#tripper.backends.collection.CollectionStrategy.triples","title":"<code>triples(self, triple)</code>","text":"<p>Returns a generator over matching triples.</p> Source code in <code>tripper/backends/collection.py</code> <pre><code>def triples(self, triple: \"Triple\") -&gt; \"Generator[Triple, None, None]\":\n    \"\"\"Returns a generator over matching triples.\"\"\"\n    for s, p, o, d in self.collection.get_relations(*triple, rettype=\"T\"):\n        if d:\n            lang = d[1:] if d[0] == \"@\" else None\n            dt = None if lang else d\n            yield s, p, Literal(o, lang=lang, datatype=dt)\n        else:\n            yield s, p, o\n</code></pre>"},{"location":"api_reference/backends/ontopy/","title":"ontopy","text":"<p>Backend for EMMOntoPy.</p> <p>For developers: The usage of <code>s</code>, <code>p</code>, and <code>o</code> represent the different parts of an RDF Triple: subject, predicate, and object.</p>"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy","title":"<code> OntopyStrategy        </code>","text":"<p>Triplestore strategy for EMMOntoPy.</p> <p>Parameters:</p> Name Type Description Default <code>base_iri</code> <code>Optional[str]</code> <p>The base iri of the ontology. Default to \"http://example.com/onto#\" if <code>onto</code> is not given.</p> <code>None</code> <code>database</code> <code>Optional[str]</code> <p>Unused - ontopy does not support multiple databases.</p> <code>None</code> <code>onto</code> <code>Optional[Ontology]</code> <p>Ontology to initiate the triplestore from.  Defaults to an new ontology with the given <code>base_iri</code>.</p> <code>None</code> <code>load</code> <code>bool</code> <p>Whether to load the ontology.</p> <code>False</code> <code>kwargs</code> <p>Keyword arguments passed to the ontology load() method.</p> <code>{}</code> <p>Either the <code>base_iri</code> or <code>onto</code> argument must be provided.</p> Source code in <code>tripper/backends/ontopy.py</code> <pre><code>class OntopyStrategy:\n    \"\"\"Triplestore strategy for EMMOntoPy.\n\n    Arguments:\n        base_iri: The base iri of the ontology.\n            Default to \"http://example.com/onto#\" if `onto` is not given.\n        database: Unused - ontopy does not support multiple databases.\n        onto: Ontology to initiate the triplestore from.  Defaults to an new\n            ontology with the given `base_iri`.\n        load: Whether to load the ontology.\n        kwargs: Keyword arguments passed to the ontology load() method.\n\n    Either the `base_iri` or `onto` argument must be provided.\n    \"\"\"\n\n    def __init__(\n        self,\n        base_iri: \"Optional[str]\" = None,\n        database: \"Optional[str]\" = None,\n        onto: \"Optional[Ontology]\" = None,\n        load: bool = False,\n        **kwargs,\n    ):\n        # pylint: disable=unused-argument\n        if onto is None:\n            if base_iri is None:\n                base_iri = \"http://example.com/onto#\"\n            self.onto = get_ontology(base_iri)\n        elif isinstance(onto, Ontology):\n            self.onto = onto\n        else:\n            raise TypeError(\"`onto` must be either an ontology or None\")\n\n        if load:\n            self.onto.load(**kwargs)\n\n    def triples(self, triple: \"Triple\") -&gt; \"Generator[Triple, None, None]\":\n        \"\"\"Returns a generator over matching triples.\"\"\"\n\n        def to_literal(o, datatype) -&gt; Literal:\n            \"\"\"Returns a literal from (o, datatype).\"\"\"\n            if isinstance(datatype, str) and datatype.startswith(\"@\"):\n                return Literal(o, lang=datatype[1:], datatype=None)\n            return Literal(o, lang=None, datatype=datatype)\n\n        s, p, o = triple\n        abb = (\n            None if (s) is None else self.onto._abbreviate(s),\n            None if (p) is None else self.onto._abbreviate(p),\n            None if (o) is None else self.onto._abbreviate(o),\n        )\n        for s, p, o in self.onto._get_obj_triples_spo_spo(*abb):\n            yield (\n                _unabbreviate(self.onto, s),\n                _unabbreviate(self.onto, p),\n                _unabbreviate(self.onto, o),\n            )\n        for s, p, o, datatype in self.onto._get_data_triples_spod_spod(\n            *abb, d=\"\"\n        ):\n            yield (\n                _unabbreviate(self.onto, s),\n                _unabbreviate(self.onto, p),\n                to_literal(o, datatype),\n            )\n\n    def add_triples(self, triples: \"Sequence[Triple]\"):\n        \"\"\"Add a sequence of triples.\"\"\"\n        if TYPE_CHECKING:  # pragma: no cover\n            datatype: \"Union[int, str]\"\n        for s, p, o in triples:\n            if isinstance(o, Literal):\n                if o.lang:\n                    datatype = f\"@{o.lang}\"\n                elif o.datatype:\n                    datatype = f\"^^{o.datatype}\"\n                else:\n                    datatype = 0\n                self.onto._add_data_triple_spod(\n                    self.onto._abbreviate(s),\n                    self.onto._abbreviate(p),\n                    self.onto._abbreviate(o),\n                    datatype,\n                )\n            else:\n                self.onto._add_obj_triple_spo(\n                    self.onto._abbreviate(s),\n                    self.onto._abbreviate(p),\n                    self.onto._abbreviate(o),\n                )\n\n    def remove(self, triple: \"Triple\"):\n        \"\"\"Remove all matching triples from the backend.\"\"\"\n        s, p, o = triple\n        to_remove = list(\n            self.onto._get_triples_spod_spod(\n                self.onto._abbreviate(s) if (s) is not None else None,\n                self.onto._abbreviate(p) if (s) is not None else None,\n                self.onto._abbreviate(o) if (s) is not None else None,\n            )\n        )\n        for s, p, o, datatype in to_remove:\n            if datatype:\n                self.onto._del_data_triple_spod(s, p, o, datatype)\n            else:\n                self.onto._del_obj_triple_spo(s, p, o)\n\n    # Optional methods\n    def parse(\n        self,\n        source=None,\n        location=None,\n        data=None,\n        format=None,  # pylint: disable=redefined-builtin\n        encoding=None,\n        **kwargs,\n    ):\n        \"\"\"Parse source and add the resulting triples to triplestore.\n\n        The source is specified using one of `source`, `location` or `data`.\n\n        Parameters:\n            source: File-like object or file name.\n            location: String with relative or absolute URL to source.\n            data: String containing the data to be parsed.\n            format: Needed if format can not be inferred from source.\n            encoding: Encoding argument to io.open().\n            kwargs: Additional keyword arguments passed to Ontology.load().\n        \"\"\"\n        if source:\n            self.onto.load(filename=source, format=format, **kwargs)\n        elif location:\n            self.onto.load(filename=location, format=format, **kwargs)\n        elif data:\n            # s = io.StringIO(data)\n            # self.onto.load(filename=s, format=format, **kwargs)\n\n            # Could have been done much nicer if it hasn't been for Windows\n            filename = None\n            try:\n                tmpfile_options = {\"delete\": False}\n                if isinstance(data, str):\n                    tmpfile_options.update(mode=\"w+t\", encoding=encoding)\n                with tempfile.NamedTemporaryFile(**tmpfile_options) as handle:\n                    handle.write(data)\n                    filename = handle.name\n                self.onto.load(filename=filename, format=format, **kwargs)\n            finally:\n                if filename:\n                    os.remove(filename)\n\n        else:\n            raise ValueError(\n                \"either `source`, `location` or `data` must be given\"\n            )\n\n    def serialize(\n        self,\n        destination=None,\n        format=\"turtle\",  # pylint: disable=redefined-builtin\n        **kwargs,\n    ) -&gt; \"Union[None, str]\":\n        \"\"\"Serialise to destination.\n\n        Parameters:\n            destination: File name or object to write to.  If None, the\n                serialisation is returned.\n            format: Format to serialise as.  Supported formats, depends on\n                the backend.\n            kwargs: Passed to the Ontology.save() method.\n\n        Returns:\n            Serialised string if `destination` is None.\n        \"\"\"\n        if destination:\n            self.onto.save(destination, format=format, **kwargs)\n        else:\n            # Clumsy implementation due to Windows file locking...\n            filename = None\n            try:\n                with tempfile.NamedTemporaryFile(delete=False) as handle:\n                    filename = handle.name\n                    self.onto.save(filename, format=format, **kwargs)\n                with open(filename, \"rt\", encoding=\"utf8\") as handle:\n                    return handle.read()\n            finally:\n                if filename:\n                    os.remove(filename)\n        return None\n\n    def query(\n        self, query_object, native=True, **kwargs\n    ) -&gt; \"Union[List, Result]\":\n        \"\"\"SPARQL query.\n\n        Parameters:\n            query_object: String with the SPARQL query.\n            native: Whether or not to use EMMOntoPy/Owlready2 or RDFLib.\n            kwargs: Keyword arguments passed to rdflib.Graph.query().\n\n        Returns:\n            SPARQL query results.\n\n        \"\"\"\n        if TYPE_CHECKING:  # pragma: no cover\n            res: \"Union[List, Result]\"\n\n        if native:\n            res = self.onto.world.sparql(query_object)\n        else:\n            graph = self.onto.world.as_rdflib_graph()\n            res = graph.query(query_object, **kwargs)\n        # TODO: Convert result to expected type\n        return res\n\n    def update(self, update_object, native=True, **kwargs) -&gt; None:\n        \"\"\"Update triplestore with SPARQL.\n\n        Parameters:\n            update_object: String with the SPARQL query.\n            native: Whether or not to use EMMOntoPy/Owlready2 or RDFLib.\n            kwargs: Keyword arguments passed to rdflib.Graph.update().\n\n        Note:\n            This method is intended for INSERT and DELETE queries. Use\n            the query() method for SELECT queries.\n\n        \"\"\"\n        if native:\n            self.onto.world.sparql(update_object)\n        else:\n            graph = self.onto.world.as_rdflib_graph()\n            graph.update(update_object, **kwargs)\n</code></pre>"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.add_triples","title":"<code>add_triples(self, triples)</code>","text":"<p>Add a sequence of triples.</p> Source code in <code>tripper/backends/ontopy.py</code> <pre><code>def add_triples(self, triples: \"Sequence[Triple]\"):\n    \"\"\"Add a sequence of triples.\"\"\"\n    if TYPE_CHECKING:  # pragma: no cover\n        datatype: \"Union[int, str]\"\n    for s, p, o in triples:\n        if isinstance(o, Literal):\n            if o.lang:\n                datatype = f\"@{o.lang}\"\n            elif o.datatype:\n                datatype = f\"^^{o.datatype}\"\n            else:\n                datatype = 0\n            self.onto._add_data_triple_spod(\n                self.onto._abbreviate(s),\n                self.onto._abbreviate(p),\n                self.onto._abbreviate(o),\n                datatype,\n            )\n        else:\n            self.onto._add_obj_triple_spo(\n                self.onto._abbreviate(s),\n                self.onto._abbreviate(p),\n                self.onto._abbreviate(o),\n            )\n</code></pre>"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.parse","title":"<code>parse(self, source=None, location=None, data=None, format=None, encoding=None, **kwargs)</code>","text":"<p>Parse source and add the resulting triples to triplestore.</p> <p>The source is specified using one of <code>source</code>, <code>location</code> or <code>data</code>.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <p>File-like object or file name.</p> <code>None</code> <code>location</code> <p>String with relative or absolute URL to source.</p> <code>None</code> <code>data</code> <p>String containing the data to be parsed.</p> <code>None</code> <code>format</code> <p>Needed if format can not be inferred from source.</p> <code>None</code> <code>encoding</code> <p>Encoding argument to io.open().</p> <code>None</code> <code>kwargs</code> <p>Additional keyword arguments passed to Ontology.load().</p> <code>{}</code> Source code in <code>tripper/backends/ontopy.py</code> <pre><code>def parse(\n    self,\n    source=None,\n    location=None,\n    data=None,\n    format=None,  # pylint: disable=redefined-builtin\n    encoding=None,\n    **kwargs,\n):\n    \"\"\"Parse source and add the resulting triples to triplestore.\n\n    The source is specified using one of `source`, `location` or `data`.\n\n    Parameters:\n        source: File-like object or file name.\n        location: String with relative or absolute URL to source.\n        data: String containing the data to be parsed.\n        format: Needed if format can not be inferred from source.\n        encoding: Encoding argument to io.open().\n        kwargs: Additional keyword arguments passed to Ontology.load().\n    \"\"\"\n    if source:\n        self.onto.load(filename=source, format=format, **kwargs)\n    elif location:\n        self.onto.load(filename=location, format=format, **kwargs)\n    elif data:\n        # s = io.StringIO(data)\n        # self.onto.load(filename=s, format=format, **kwargs)\n\n        # Could have been done much nicer if it hasn't been for Windows\n        filename = None\n        try:\n            tmpfile_options = {\"delete\": False}\n            if isinstance(data, str):\n                tmpfile_options.update(mode=\"w+t\", encoding=encoding)\n            with tempfile.NamedTemporaryFile(**tmpfile_options) as handle:\n                handle.write(data)\n                filename = handle.name\n            self.onto.load(filename=filename, format=format, **kwargs)\n        finally:\n            if filename:\n                os.remove(filename)\n\n    else:\n        raise ValueError(\n            \"either `source`, `location` or `data` must be given\"\n        )\n</code></pre>"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.query","title":"<code>query(self, query_object, native=True, **kwargs)</code>","text":"<p>SPARQL query.</p> <p>Parameters:</p> Name Type Description Default <code>query_object</code> <p>String with the SPARQL query.</p> required <code>native</code> <p>Whether or not to use EMMOntoPy/Owlready2 or RDFLib.</p> <code>True</code> <code>kwargs</code> <p>Keyword arguments passed to rdflib.Graph.query().</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[List, Result]</code> <p>SPARQL query results.</p> Source code in <code>tripper/backends/ontopy.py</code> <pre><code>def query(\n    self, query_object, native=True, **kwargs\n) -&gt; \"Union[List, Result]\":\n    \"\"\"SPARQL query.\n\n    Parameters:\n        query_object: String with the SPARQL query.\n        native: Whether or not to use EMMOntoPy/Owlready2 or RDFLib.\n        kwargs: Keyword arguments passed to rdflib.Graph.query().\n\n    Returns:\n        SPARQL query results.\n\n    \"\"\"\n    if TYPE_CHECKING:  # pragma: no cover\n        res: \"Union[List, Result]\"\n\n    if native:\n        res = self.onto.world.sparql(query_object)\n    else:\n        graph = self.onto.world.as_rdflib_graph()\n        res = graph.query(query_object, **kwargs)\n    # TODO: Convert result to expected type\n    return res\n</code></pre>"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.remove","title":"<code>remove(self, triple)</code>","text":"<p>Remove all matching triples from the backend.</p> Source code in <code>tripper/backends/ontopy.py</code> <pre><code>def remove(self, triple: \"Triple\"):\n    \"\"\"Remove all matching triples from the backend.\"\"\"\n    s, p, o = triple\n    to_remove = list(\n        self.onto._get_triples_spod_spod(\n            self.onto._abbreviate(s) if (s) is not None else None,\n            self.onto._abbreviate(p) if (s) is not None else None,\n            self.onto._abbreviate(o) if (s) is not None else None,\n        )\n    )\n    for s, p, o, datatype in to_remove:\n        if datatype:\n            self.onto._del_data_triple_spod(s, p, o, datatype)\n        else:\n            self.onto._del_obj_triple_spo(s, p, o)\n</code></pre>"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.serialize","title":"<code>serialize(self, destination=None, format='turtle', **kwargs)</code>","text":"<p>Serialise to destination.</p> <p>Parameters:</p> Name Type Description Default <code>destination</code> <p>File name or object to write to.  If None, the serialisation is returned.</p> <code>None</code> <code>format</code> <p>Format to serialise as.  Supported formats, depends on the backend.</p> <code>'turtle'</code> <code>kwargs</code> <p>Passed to the Ontology.save() method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[None, str]</code> <p>Serialised string if <code>destination</code> is None.</p> Source code in <code>tripper/backends/ontopy.py</code> <pre><code>def serialize(\n    self,\n    destination=None,\n    format=\"turtle\",  # pylint: disable=redefined-builtin\n    **kwargs,\n) -&gt; \"Union[None, str]\":\n    \"\"\"Serialise to destination.\n\n    Parameters:\n        destination: File name or object to write to.  If None, the\n            serialisation is returned.\n        format: Format to serialise as.  Supported formats, depends on\n            the backend.\n        kwargs: Passed to the Ontology.save() method.\n\n    Returns:\n        Serialised string if `destination` is None.\n    \"\"\"\n    if destination:\n        self.onto.save(destination, format=format, **kwargs)\n    else:\n        # Clumsy implementation due to Windows file locking...\n        filename = None\n        try:\n            with tempfile.NamedTemporaryFile(delete=False) as handle:\n                filename = handle.name\n                self.onto.save(filename, format=format, **kwargs)\n            with open(filename, \"rt\", encoding=\"utf8\") as handle:\n                return handle.read()\n        finally:\n            if filename:\n                os.remove(filename)\n    return None\n</code></pre>"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.triples","title":"<code>triples(self, triple)</code>","text":"<p>Returns a generator over matching triples.</p> Source code in <code>tripper/backends/ontopy.py</code> <pre><code>def triples(self, triple: \"Triple\") -&gt; \"Generator[Triple, None, None]\":\n    \"\"\"Returns a generator over matching triples.\"\"\"\n\n    def to_literal(o, datatype) -&gt; Literal:\n        \"\"\"Returns a literal from (o, datatype).\"\"\"\n        if isinstance(datatype, str) and datatype.startswith(\"@\"):\n            return Literal(o, lang=datatype[1:], datatype=None)\n        return Literal(o, lang=None, datatype=datatype)\n\n    s, p, o = triple\n    abb = (\n        None if (s) is None else self.onto._abbreviate(s),\n        None if (p) is None else self.onto._abbreviate(p),\n        None if (o) is None else self.onto._abbreviate(o),\n    )\n    for s, p, o in self.onto._get_obj_triples_spo_spo(*abb):\n        yield (\n            _unabbreviate(self.onto, s),\n            _unabbreviate(self.onto, p),\n            _unabbreviate(self.onto, o),\n        )\n    for s, p, o, datatype in self.onto._get_data_triples_spod_spod(\n        *abb, d=\"\"\n    ):\n        yield (\n            _unabbreviate(self.onto, s),\n            _unabbreviate(self.onto, p),\n            to_literal(o, datatype),\n        )\n</code></pre>"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.update","title":"<code>update(self, update_object, native=True, **kwargs)</code>","text":"<p>Update triplestore with SPARQL.</p> <p>Parameters:</p> Name Type Description Default <code>update_object</code> <p>String with the SPARQL query.</p> required <code>native</code> <p>Whether or not to use EMMOntoPy/Owlready2 or RDFLib.</p> <code>True</code> <code>kwargs</code> <p>Keyword arguments passed to rdflib.Graph.update().</p> <code>{}</code> <p>Note</p> <p>This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries.</p> Source code in <code>tripper/backends/ontopy.py</code> <pre><code>def update(self, update_object, native=True, **kwargs) -&gt; None:\n    \"\"\"Update triplestore with SPARQL.\n\n    Parameters:\n        update_object: String with the SPARQL query.\n        native: Whether or not to use EMMOntoPy/Owlready2 or RDFLib.\n        kwargs: Keyword arguments passed to rdflib.Graph.update().\n\n    Note:\n        This method is intended for INSERT and DELETE queries. Use\n        the query() method for SELECT queries.\n\n    \"\"\"\n    if native:\n        self.onto.world.sparql(update_object)\n    else:\n        graph = self.onto.world.as_rdflib_graph()\n        graph.update(update_object, **kwargs)\n</code></pre>"},{"location":"api_reference/backends/rdflib/","title":"rdflib","text":"<p>Backend for RDFLib.</p> <p>For developers: The usage of <code>s</code>, <code>p</code>, and <code>o</code> represent the different parts of an RDF Triple: subject, predicate, and object.</p> <p>There is a issue with rdflib raising an <code>urllib.error.HTTPError</code> exception if you don't have write permissions to the cache directory. See Known issues for more details.</p>"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy","title":"<code> RdflibStrategy        </code>","text":"<p>Triplestore strategy for rdflib.</p> <p>Parameters:</p> Name Type Description Default <code>base_iri</code> <code>Optional[str]</code> <p>Unused by the rdflib backend.  The <code>base_iri</code> argument is still used for encapsulating the Triplestore class.</p> <code>None</code> <code>database</code> <code>Optional[str]</code> <p>Unused - rdflib does not support multiple databases.</p> <code>None</code> <code>triplestore_url</code> <code>Optional[str]</code> <p>If given, initialise the triplestore from this storage.  When <code>close()</code> is called, the storage will be overwritten with the current content of the triplestore.</p> <code>None</code> <code>format</code> <code>Optional[str]</code> <p>Format of storage specified with <code>base_iri</code>.</p> <code>None</code> <code>graph</code> <code>Optional[Graph]</code> <p>A rdflib.Graph instance to expose with tripper, instead of creating a new empty Graph object.</p> <code>None</code> Source code in <code>tripper/backends/rdflib.py</code> <pre><code>class RdflibStrategy:\n    \"\"\"Triplestore strategy for rdflib.\n\n    Arguments:\n        base_iri: Unused by the rdflib backend.  The `base_iri` argument is\n            still used for encapsulating the Triplestore class.\n        database: Unused - rdflib does not support multiple databases.\n        triplestore_url: If given, initialise the triplestore from this\n            storage.  When `close()` is called, the storage will be\n            overwritten with the current content of the triplestore.\n        format: Format of storage specified with `base_iri`.\n        graph: A rdflib.Graph instance to expose with tripper, instead of\n            creating a new empty Graph object.\n    \"\"\"\n\n    def __init__(\n        self,\n        base_iri: \"Optional[str]\" = None,  # pylint: disable=unused-argument\n        database: \"Optional[str]\" = None,\n        triplestore_url: \"Optional[str]\" = None,\n        format: \"Optional[str]\" = None,  # pylint: disable=redefined-builtin\n        graph: \"Optional[Graph]\" = None,\n    ) -&gt; None:\n        # Note that although `base_iri` is unused in this backend, it may\n        # still be used by calling Triplestore object.\n        if database:\n            warnings.warn(\"database\", UnusedArgumentWarning, stacklevel=3)\n\n        self.graph = graph if graph else Graph()\n        self.triplestore_url = triplestore_url\n        if self.triplestore_url is not None:\n            if format is None:\n                format = guess_format(self.triplestore_url)\n            self.parse(location=self.triplestore_url, format=format)\n        self.base_format = format\n\n    def triples(self, triple: \"Triple\") -&gt; \"Generator[Triple, None, None]\":\n        \"\"\"Returns a generator over matching triples.\"\"\"\n        return _convert_triples_to_tripper(\n            self.graph.triples(astriple(triple))\n        )\n\n    def add_triples(self, triples: \"Sequence[Triple]\"):\n        \"\"\"Add a sequence of triples.\"\"\"\n        for triple in triples:\n            self.graph.add(astriple(triple))\n\n    def remove(self, triple: \"Triple\"):\n        \"\"\"Remove all matching triples from the backend.\"\"\"\n        self.graph.remove(astriple(triple))\n\n    # Optional methods\n    def close(self):\n        \"\"\"Close the internal RDFLib graph.\"\"\"\n        if self.triplestore_url:\n            self.serialize(\n                destination=self.triplestore_url, format=self.base_format\n            )\n        self.graph.close()\n\n    def parse(\n        self,\n        source=None,\n        location=None,\n        data=None,\n        format=None,  # pylint: disable=redefined-builtin\n        **kwargs,\n    ):\n        \"\"\"Parse source and add the resulting triples to triplestore.\n\n        The source is specified using one of `source`, `location` or `data`.\n\n        Parameters:\n            source: File-like object or file name.\n            location: String with relative or absolute URL to source.\n            data: String containing the data to be parsed.\n            format: Needed if format can not be inferred from source.\n            kwargs: Additional less used keyword arguments.\n                See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.parse\n        \"\"\"\n        self.graph.parse(\n            source=source,\n            location=location,\n            data=data,\n            format=format,\n            **kwargs,\n        )\n\n    def serialize(\n        self,\n        destination=None,\n        format=\"turtle\",  # pylint: disable=redefined-builtin\n        **kwargs,\n    ) -&gt; \"Union[None, str]\":\n        \"\"\"Serialise to destination.\n\n        Parameters:\n            destination: File name or object to write to. If None, the serialisation is\n                returned.\n            format: Format to serialise as. Supported formats, depends on the backend.\n            kwargs: Passed to the rdflib.Graph.serialize() method.\n                See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.serialize\n\n        Returns:\n            Serialised string if `destination` is None.\n        \"\"\"\n        result = self.graph.serialize(\n            destination=destination, format=format, **kwargs\n        )\n        if destination is None:\n            # Depending on the version of rdflib the return value of\n            # graph.serialize() man either be a string or a bytes object...\n            return result if isinstance(result, str) else result.decode()\n        return None\n\n    def query(\n        self, query_object, **kwargs\n    ) -&gt; \"Union[List[Tuple[str, ...]], bool, Generator[Triple, None, None]]\":\n        \"\"\"SPARQL query.\n\n        Parameters:\n            query_object: String with the SPARQL query.\n            kwargs: Keyword arguments passed to rdflib.Graph.query().\n\n        Returns:\n            The return type depends on type of query:\n              - SELECT: list of tuples of IRIs for each matching row\n              - ASK: bool\n              - CONSTRUCT, DESCRIBE: generator over triples\n\n            For more info, see\n            https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.query.Result\n        \"\"\"\n        result = self.graph.query(query_object=query_object, **kwargs)\n\n        # The type of the result object depends not only on the type of query,\n        # but also on the version of rdflib...  We try to be general here.\n        if hasattr(result, \"type\"):\n            resulttype = result.type\n        elif result.__class__.__name__ == \"ResultRow\":\n            resulttype = \"SELECT\"\n        elif isinstance(result, bool):\n            resulttype = \"ASK\"\n        elif isinstance(result, Generator):\n            resulttype = \"CONSTRUCT\"  # also DESCRIBE\n        else:\n            warnings.warn(\n                \"Unknown return type from rdflib.query(). Return it unprocessed.\"\n            )\n            return result  # type: ignore\n\n        if resulttype == \"SELECT\":\n            return [tuple(str(v) for v in row) for row in result]  # type: ignore\n        if resulttype == \"ASK\":\n            return bool(result)\n        if resulttype in (\"CONSTRUCT\", \"DESCRIBE\"):\n            return _convert_triples_to_tripper(result)\n        assert False, \"should never be reached\"  # nosec\n\n    def update(self, update_object, **kwargs) -&gt; None:\n        \"\"\"Update triplestore with SPARQL.\n\n        Parameters:\n            update_object: String with the SPARQL query.\n            kwargs: Keyword arguments passed to rdflib.Graph.update().\n\n        Note:\n            This method is intended for INSERT and DELETE queries. Use\n            the query() method for SELECT queries.\n\n        \"\"\"\n        return self.graph.update(update_object=update_object, **kwargs)\n\n    def bind(self, prefix: str, namespace: str):\n        \"\"\"Bind prefix to namespace.\n\n        Should only be defined if the backend supports namespaces.\n        Called by triplestore.bind().\n        \"\"\"\n        if namespace:\n            self.graph.bind(prefix, namespace, replace=True)\n        else:\n            warnings.warn(\n                \"rdflib does not support removing namespace prefixes\"\n            )\n\n    def namespaces(self) -&gt; dict:\n        \"\"\"Returns a dict mapping prefixes to namespaces.\n\n        Should only be defined if the backend supports namespaces.\n        Used by triplestore.parse() to get prefixes after reading\n        triples from an external source.\n        \"\"\"\n        return {\n            prefix: str(namespace)\n            for prefix, namespace in self.graph.namespaces()\n        }\n</code></pre>"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.add_triples","title":"<code>add_triples(self, triples)</code>","text":"<p>Add a sequence of triples.</p> Source code in <code>tripper/backends/rdflib.py</code> <pre><code>def add_triples(self, triples: \"Sequence[Triple]\"):\n    \"\"\"Add a sequence of triples.\"\"\"\n    for triple in triples:\n        self.graph.add(astriple(triple))\n</code></pre>"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.bind","title":"<code>bind(self, prefix, namespace)</code>","text":"<p>Bind prefix to namespace.</p> <p>Should only be defined if the backend supports namespaces. Called by triplestore.bind().</p> Source code in <code>tripper/backends/rdflib.py</code> <pre><code>def bind(self, prefix: str, namespace: str):\n    \"\"\"Bind prefix to namespace.\n\n    Should only be defined if the backend supports namespaces.\n    Called by triplestore.bind().\n    \"\"\"\n    if namespace:\n        self.graph.bind(prefix, namespace, replace=True)\n    else:\n        warnings.warn(\n            \"rdflib does not support removing namespace prefixes\"\n        )\n</code></pre>"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.close","title":"<code>close(self)</code>","text":"<p>Close the internal RDFLib graph.</p> Source code in <code>tripper/backends/rdflib.py</code> <pre><code>def close(self):\n    \"\"\"Close the internal RDFLib graph.\"\"\"\n    if self.triplestore_url:\n        self.serialize(\n            destination=self.triplestore_url, format=self.base_format\n        )\n    self.graph.close()\n</code></pre>"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.namespaces","title":"<code>namespaces(self)</code>","text":"<p>Returns a dict mapping prefixes to namespaces.</p> <p>Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source.</p> Source code in <code>tripper/backends/rdflib.py</code> <pre><code>def namespaces(self) -&gt; dict:\n    \"\"\"Returns a dict mapping prefixes to namespaces.\n\n    Should only be defined if the backend supports namespaces.\n    Used by triplestore.parse() to get prefixes after reading\n    triples from an external source.\n    \"\"\"\n    return {\n        prefix: str(namespace)\n        for prefix, namespace in self.graph.namespaces()\n    }\n</code></pre>"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.parse","title":"<code>parse(self, source=None, location=None, data=None, format=None, **kwargs)</code>","text":"<p>Parse source and add the resulting triples to triplestore.</p> <p>The source is specified using one of <code>source</code>, <code>location</code> or <code>data</code>.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <p>File-like object or file name.</p> <code>None</code> <code>location</code> <p>String with relative or absolute URL to source.</p> <code>None</code> <code>data</code> <p>String containing the data to be parsed.</p> <code>None</code> <code>format</code> <p>Needed if format can not be inferred from source.</p> <code>None</code> <code>kwargs</code> <p>Additional less used keyword arguments. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.parse</p> <code>{}</code> Source code in <code>tripper/backends/rdflib.py</code> <pre><code>def parse(\n    self,\n    source=None,\n    location=None,\n    data=None,\n    format=None,  # pylint: disable=redefined-builtin\n    **kwargs,\n):\n    \"\"\"Parse source and add the resulting triples to triplestore.\n\n    The source is specified using one of `source`, `location` or `data`.\n\n    Parameters:\n        source: File-like object or file name.\n        location: String with relative or absolute URL to source.\n        data: String containing the data to be parsed.\n        format: Needed if format can not be inferred from source.\n        kwargs: Additional less used keyword arguments.\n            See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.parse\n    \"\"\"\n    self.graph.parse(\n        source=source,\n        location=location,\n        data=data,\n        format=format,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.query","title":"<code>query(self, query_object, **kwargs)</code>","text":"<p>SPARQL query.</p> <p>Parameters:</p> Name Type Description Default <code>query_object</code> <p>String with the SPARQL query.</p> required <code>kwargs</code> <p>Keyword arguments passed to rdflib.Graph.query().</p> <code>{}</code> <p>Returns:</p> Type Description <code>The return type depends on type of query</code> <ul> <li>SELECT: list of tuples of IRIs for each matching row</li> <li>ASK: bool</li> <li>CONSTRUCT, DESCRIBE: generator over triples</li> </ul> <p>For more info, see https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.query.Result</p> Source code in <code>tripper/backends/rdflib.py</code> <pre><code>def query(\n    self, query_object, **kwargs\n) -&gt; \"Union[List[Tuple[str, ...]], bool, Generator[Triple, None, None]]\":\n    \"\"\"SPARQL query.\n\n    Parameters:\n        query_object: String with the SPARQL query.\n        kwargs: Keyword arguments passed to rdflib.Graph.query().\n\n    Returns:\n        The return type depends on type of query:\n          - SELECT: list of tuples of IRIs for each matching row\n          - ASK: bool\n          - CONSTRUCT, DESCRIBE: generator over triples\n\n        For more info, see\n        https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.query.Result\n    \"\"\"\n    result = self.graph.query(query_object=query_object, **kwargs)\n\n    # The type of the result object depends not only on the type of query,\n    # but also on the version of rdflib...  We try to be general here.\n    if hasattr(result, \"type\"):\n        resulttype = result.type\n    elif result.__class__.__name__ == \"ResultRow\":\n        resulttype = \"SELECT\"\n    elif isinstance(result, bool):\n        resulttype = \"ASK\"\n    elif isinstance(result, Generator):\n        resulttype = \"CONSTRUCT\"  # also DESCRIBE\n    else:\n        warnings.warn(\n            \"Unknown return type from rdflib.query(). Return it unprocessed.\"\n        )\n        return result  # type: ignore\n\n    if resulttype == \"SELECT\":\n        return [tuple(str(v) for v in row) for row in result]  # type: ignore\n    if resulttype == \"ASK\":\n        return bool(result)\n    if resulttype in (\"CONSTRUCT\", \"DESCRIBE\"):\n        return _convert_triples_to_tripper(result)\n    assert False, \"should never be reached\"  # nosec\n</code></pre>"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.remove","title":"<code>remove(self, triple)</code>","text":"<p>Remove all matching triples from the backend.</p> Source code in <code>tripper/backends/rdflib.py</code> <pre><code>def remove(self, triple: \"Triple\"):\n    \"\"\"Remove all matching triples from the backend.\"\"\"\n    self.graph.remove(astriple(triple))\n</code></pre>"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.serialize","title":"<code>serialize(self, destination=None, format='turtle', **kwargs)</code>","text":"<p>Serialise to destination.</p> <p>Parameters:</p> Name Type Description Default <code>destination</code> <p>File name or object to write to. If None, the serialisation is returned.</p> <code>None</code> <code>format</code> <p>Format to serialise as. Supported formats, depends on the backend.</p> <code>'turtle'</code> <code>kwargs</code> <p>Passed to the rdflib.Graph.serialize() method. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.serialize</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[None, str]</code> <p>Serialised string if <code>destination</code> is None.</p> Source code in <code>tripper/backends/rdflib.py</code> <pre><code>def serialize(\n    self,\n    destination=None,\n    format=\"turtle\",  # pylint: disable=redefined-builtin\n    **kwargs,\n) -&gt; \"Union[None, str]\":\n    \"\"\"Serialise to destination.\n\n    Parameters:\n        destination: File name or object to write to. If None, the serialisation is\n            returned.\n        format: Format to serialise as. Supported formats, depends on the backend.\n        kwargs: Passed to the rdflib.Graph.serialize() method.\n            See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.serialize\n\n    Returns:\n        Serialised string if `destination` is None.\n    \"\"\"\n    result = self.graph.serialize(\n        destination=destination, format=format, **kwargs\n    )\n    if destination is None:\n        # Depending on the version of rdflib the return value of\n        # graph.serialize() man either be a string or a bytes object...\n        return result if isinstance(result, str) else result.decode()\n    return None\n</code></pre>"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.triples","title":"<code>triples(self, triple)</code>","text":"<p>Returns a generator over matching triples.</p> Source code in <code>tripper/backends/rdflib.py</code> <pre><code>def triples(self, triple: \"Triple\") -&gt; \"Generator[Triple, None, None]\":\n    \"\"\"Returns a generator over matching triples.\"\"\"\n    return _convert_triples_to_tripper(\n        self.graph.triples(astriple(triple))\n    )\n</code></pre>"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.update","title":"<code>update(self, update_object, **kwargs)</code>","text":"<p>Update triplestore with SPARQL.</p> <p>Parameters:</p> Name Type Description Default <code>update_object</code> <p>String with the SPARQL query.</p> required <code>kwargs</code> <p>Keyword arguments passed to rdflib.Graph.update().</p> <code>{}</code> <p>Note</p> <p>This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries.</p> Source code in <code>tripper/backends/rdflib.py</code> <pre><code>def update(self, update_object, **kwargs) -&gt; None:\n    \"\"\"Update triplestore with SPARQL.\n\n    Parameters:\n        update_object: String with the SPARQL query.\n        kwargs: Keyword arguments passed to rdflib.Graph.update().\n\n    Note:\n        This method is intended for INSERT and DELETE queries. Use\n        the query() method for SELECT queries.\n\n    \"\"\"\n    return self.graph.update(update_object=update_object, **kwargs)\n</code></pre>"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.astriple","title":"<code>astriple(triple)</code>","text":"<p>Help function converting a triple to rdflib triple.</p> Source code in <code>tripper/backends/rdflib.py</code> <pre><code>def astriple(triple: \"Triple\"):\n    \"\"\"Help function converting a triple to rdflib triple.\"\"\"\n    s, p, o = triple\n    return asuri(s), asuri(p), asuri(o)\n</code></pre>"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.asuri","title":"<code>asuri(value)</code>","text":"<p>Help function converting a spo-value to proper rdflib type.</p> Source code in <code>tripper/backends/rdflib.py</code> <pre><code>def asuri(value: \"Union[None, Literal, str]\"):\n    \"\"\"Help function converting a spo-value to proper rdflib type.\"\"\"\n    if value is None:\n        return None\n    if isinstance(value, Literal):\n        return rdflibLiteral(\n            value.value, lang=value.lang, datatype=value.datatype\n        )\n    if value.startswith(\"_:\"):\n        return BNode(value[2:])\n    return URIRef(value)\n</code></pre>"},{"location":"api_reference/backends/sparqlwrapper/","title":"sparqlwrapper","text":"<p>Backend for SPARQLWrapper</p>"},{"location":"api_reference/backends/sparqlwrapper/#tripper.backends.sparqlwrapper.SparqlwrapperStrategy","title":"<code> SparqlwrapperStrategy        </code>","text":"<p>Triplestore strategy for SPARQLWrapper.</p> <p>Parameters:</p> Name Type Description Default <code>base_iri</code> <code>str</code> <p>URI of SPARQL endpoint.</p> required <code>kwargs</code> <p>Additional arguments passed to the SPARQLWrapper constructor.</p> <code>{}</code> Source code in <code>tripper/backends/sparqlwrapper.py</code> <pre><code>class SparqlwrapperStrategy:\n    \"\"\"Triplestore strategy for SPARQLWrapper.\n\n    Arguments:\n        base_iri: URI of SPARQL endpoint.\n        kwargs: Additional arguments passed to the SPARQLWrapper constructor.\n\n    \"\"\"\n\n    def __init__(self, base_iri: str, **kwargs) -&gt; None:\n        kwargs.pop(\n            \"database\", None\n        )  # database is not used in the SPARQLWrapper backend\n        self.sparql = SPARQLWrapper(endpoint=base_iri, **kwargs)\n\n    def triples(self, triple: \"Triple\") -&gt; \"Generator[Triple, None, None]\":\n        \"\"\"Returns a generator over matching triples.\"\"\"\n        variables = [\n            f\"?{triple_name}\"\n            for triple_name, triple_value in zip(\"spo\", triple)\n            if triple_value is None\n        ]\n        where_spec = \" \".join(\n            (\n                f\"?{triple_name}\"\n                if triple_value is None\n                else (\n                    triple_value\n                    if triple_value.startswith(\"&lt;\")\n                    else f\"&lt;{triple_value}&gt;\"\n                )\n            )\n            for triple_name, triple_value in zip(\"spo\", triple)\n        )\n        query = \"\\n\".join(\n            [\n                f\"SELECT {' '.join(variables)} WHERE {{\",\n                f\"  {where_spec} .\",\n                \"}\",\n            ]\n        )\n        self.sparql.setReturnFormat(JSON)\n        self.sparql.setMethod(GET)\n        self.sparql.setQuery(query)\n        ret = self.sparql.queryAndConvert()\n        for binding in ret[\"results\"][\"bindings\"]:\n            yield tuple(\n                (\n                    convert_json_entrydict(binding[name])\n                    if name in binding\n                    else value\n                )\n                for name, value in zip(\"spo\", triple)\n            )\n\n    def add_triples(self, triples: \"Sequence[Triple]\") -&gt; \"QueryResult\":\n        \"\"\"Add a sequence of triples.\"\"\"\n        spec = \"\\n\".join(\n            \"  \"\n            + \" \".join(\n                (\n                    value.n3()\n                    if isinstance(value, Literal)\n                    else value if value.startswith(\"&lt;\") else f\"&lt;{value}&gt;\"\n                )\n                for value in triple\n            )\n            + \" .\"\n            for triple in triples\n        )\n        query = f\"INSERT DATA {{\\n{spec}\\n}}\"\n        self.sparql.setReturnFormat(RDFXML)\n        self.sparql.setMethod(POST)\n        self.sparql.setQuery(query)\n        return self.sparql.query()\n\n    def remove(self, triple: \"Triple\") -&gt; \"QueryResult\":\n        \"\"\"Remove all matching triples from the backend.\"\"\"\n        spec = \" \".join(\n            (\n                f\"?{name}\"\n                if value is None\n                else (\n                    value.n3()\n                    if isinstance(value, Literal)\n                    else value if value.startswith(\"&lt;\") else f\"&lt;{value}&gt;\"\n                )\n            )\n            for name, value in zip(\"spo\", triple)\n        )\n        query = f\"DELETE {{ {spec} }}\"\n        self.sparql.setReturnFormat(RDFXML)\n        self.sparql.setMethod(POST)\n        self.sparql.setQuery(query)\n        return self.sparql.query()\n</code></pre>"},{"location":"api_reference/backends/sparqlwrapper/#tripper.backends.sparqlwrapper.SparqlwrapperStrategy.add_triples","title":"<code>add_triples(self, triples)</code>","text":"<p>Add a sequence of triples.</p> Source code in <code>tripper/backends/sparqlwrapper.py</code> <pre><code>def add_triples(self, triples: \"Sequence[Triple]\") -&gt; \"QueryResult\":\n    \"\"\"Add a sequence of triples.\"\"\"\n    spec = \"\\n\".join(\n        \"  \"\n        + \" \".join(\n            (\n                value.n3()\n                if isinstance(value, Literal)\n                else value if value.startswith(\"&lt;\") else f\"&lt;{value}&gt;\"\n            )\n            for value in triple\n        )\n        + \" .\"\n        for triple in triples\n    )\n    query = f\"INSERT DATA {{\\n{spec}\\n}}\"\n    self.sparql.setReturnFormat(RDFXML)\n    self.sparql.setMethod(POST)\n    self.sparql.setQuery(query)\n    return self.sparql.query()\n</code></pre>"},{"location":"api_reference/backends/sparqlwrapper/#tripper.backends.sparqlwrapper.SparqlwrapperStrategy.remove","title":"<code>remove(self, triple)</code>","text":"<p>Remove all matching triples from the backend.</p> Source code in <code>tripper/backends/sparqlwrapper.py</code> <pre><code>def remove(self, triple: \"Triple\") -&gt; \"QueryResult\":\n    \"\"\"Remove all matching triples from the backend.\"\"\"\n    spec = \" \".join(\n        (\n            f\"?{name}\"\n            if value is None\n            else (\n                value.n3()\n                if isinstance(value, Literal)\n                else value if value.startswith(\"&lt;\") else f\"&lt;{value}&gt;\"\n            )\n        )\n        for name, value in zip(\"spo\", triple)\n    )\n    query = f\"DELETE {{ {spec} }}\"\n    self.sparql.setReturnFormat(RDFXML)\n    self.sparql.setMethod(POST)\n    self.sparql.setQuery(query)\n    return self.sparql.query()\n</code></pre>"},{"location":"api_reference/backends/sparqlwrapper/#tripper.backends.sparqlwrapper.SparqlwrapperStrategy.triples","title":"<code>triples(self, triple)</code>","text":"<p>Returns a generator over matching triples.</p> Source code in <code>tripper/backends/sparqlwrapper.py</code> <pre><code>def triples(self, triple: \"Triple\") -&gt; \"Generator[Triple, None, None]\":\n    \"\"\"Returns a generator over matching triples.\"\"\"\n    variables = [\n        f\"?{triple_name}\"\n        for triple_name, triple_value in zip(\"spo\", triple)\n        if triple_value is None\n    ]\n    where_spec = \" \".join(\n        (\n            f\"?{triple_name}\"\n            if triple_value is None\n            else (\n                triple_value\n                if triple_value.startswith(\"&lt;\")\n                else f\"&lt;{triple_value}&gt;\"\n            )\n        )\n        for triple_name, triple_value in zip(\"spo\", triple)\n    )\n    query = \"\\n\".join(\n        [\n            f\"SELECT {' '.join(variables)} WHERE {{\",\n            f\"  {where_spec} .\",\n            \"}\",\n        ]\n    )\n    self.sparql.setReturnFormat(JSON)\n    self.sparql.setMethod(GET)\n    self.sparql.setQuery(query)\n    ret = self.sparql.queryAndConvert()\n    for binding in ret[\"results\"][\"bindings\"]:\n        yield tuple(\n            (\n                convert_json_entrydict(binding[name])\n                if name in binding\n                else value\n            )\n            for name, value in zip(\"spo\", triple)\n        )\n</code></pre>"},{"location":"api_reference/backends/sparqlwrapper/#tripper.backends.sparqlwrapper.convert_json_entrydict","title":"<code>convert_json_entrydict(entrydict)</code>","text":"<p>Convert SPARQLWrapper json entry dict (representing a single IRI or literal) to a tripper type.</p> Source code in <code>tripper/backends/sparqlwrapper.py</code> <pre><code>def convert_json_entrydict(entrydict: \"Dict[str, str]\") -&gt; str:\n    \"\"\"Convert SPARQLWrapper json entry dict (representing a single IRI or\n    literal) to a tripper type.\"\"\"\n    if entrydict[\"type\"] == \"uri\":\n        return entrydict[\"value\"]\n\n    if entrydict[\"type\"] == \"literal\":\n        return Literal(\n            entrydict[\"value\"],\n            lang=entrydict.get(\"xml:lang\"),\n            datatype=entrydict.get(\"datatype\"),\n        )\n\n    if entrydict[\"type\"] == \"bnode\":\n        return (\n            entrydict[\"value\"]\n            if entrydict[\"value\"].startswith(\"_:\")\n            else f\"_:{entrydict['value']}\"\n        )\n\n    raise ValueError(f\"unexpected type in entrydict: {entrydict}\")\n</code></pre>"},{"location":"api_reference/convert/convert/","title":"convert","text":"<p>Tripper module for converting between RDF and other repetations.</p>"},{"location":"api_reference/convert/convert/#tripper.convert.convert.from_container","title":"<code>from_container(container, iri, lang='en', recognised_keys=None, keep=False)</code>","text":"<p>Serialise a basic Python container type (mapping or sequence) as RDF.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>Union[Mapping[str, Any], Sequence[Any]]</code> <p>The container to be saved.  Should be a mapping or sequence.  The <code>load_container()</code> function will deserialise them as dict and list, respectively.</p> required <code>iri</code> <code>str</code> <p>IRI of individual that stands for the container.</p> required <code>lang</code> <code>str</code> <p>Language to use for mapping keys.</p> <code>'en'</code> <code>recognised_keys</code> <code>Optional[Union[Dict, str]]</code> <p>An optional dict that maps mapping keys that correspond to IRIs of recognised RDF properties. If set to the special string \"basic\", the <code>BASIC_RECOGNISED_KEYS</code> module will be used.</p> <code>None</code> <code>keep</code> <code>bool</code> <p>Whether to keep the key-value pair representation for mapping items serialised with recognised_keys.  Note that this may duplicate potential large literal values.</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>List of RDF triples.</p> <p>Note</p> <p><code>container</code> should not be an empty sequence.  The reason for this is that is represented with rdf:nil, which is a single IRI and not a triple.</p> Source code in <code>tripper/convert/convert.py</code> <pre><code>def from_container(\n    container: \"Union[Mapping[str, Any], Sequence[Any]]\",\n    iri: str,\n    lang: str = \"en\",\n    recognised_keys: \"Optional[Union[Dict, str]]\" = None,\n    keep: bool = False,\n) -&gt; list:\n    \"\"\"Serialise a basic Python container type (mapping or sequence) as RDF.\n\n    Arguments:\n        container: The container to be saved.  Should be a mapping or\n            sequence.  The `load_container()` function will deserialise\n            them as dict and list, respectively.\n        iri: IRI of individual that stands for the container.\n        lang: Language to use for mapping keys.\n        recognised_keys: An optional dict that maps mapping keys that\n            correspond to IRIs of recognised RDF properties.\n            If set to the special string \"basic\", the\n            `BASIC_RECOGNISED_KEYS` module will be used.\n        keep: Whether to keep the key-value pair representation for\n            mapping items serialised with recognised_keys.  Note that this\n            may duplicate potential large literal values.\n\n    Returns:\n        List of RDF triples.\n\n    Note:\n        `container` should not be an empty sequence.  The reason for this\n        is that is represented with rdf:nil, which is a single IRI and not\n        a triple.\n    \"\"\"\n    if recognised_keys == \"basic\":\n        recognised_keys = BASIC_RECOGNISED_KEYS\n\n    rdf = []\n\n    def get_obj_iri(obj, uuid):\n        \"\"\"Return IRI for Python object `obj`.  The `uuid` argument is\n        appended to blank nodes for uniques.\"\"\"\n        if isinstance(obj, Mapping):\n            if not obj:\n                return OTEIO.Dictionary\n            obj_iri = f\"_:{dict}_{uuid}\"\n        elif isinstance(obj, Sequence) and not isinstance(obj, str):\n            if not obj:\n                return RDF.List\n            obj_iri = f\"_:{list}_{uuid}\"\n        elif obj is None:\n            return OWL.Nothing\n        else:\n            return parse_literal(obj)\n\n        rdf.extend(\n            from_container(\n                obj,\n                obj_iri,\n                lang=lang,\n                recognised_keys=recognised_keys,\n                keep=keep,\n            )\n        )\n        return obj_iri\n\n    if isinstance(container, Sequence):\n        assert not isinstance(container, str)  # nosec\n        if not container:\n            raise ValueError(\"empty sequence is not supported\")\n\n        rdf.append((iri, RDF.type, RDF.List))\n\n        for i, element in enumerate(container):\n            uuid = uuid4()\n            first_iri = get_obj_iri(element, uuid)\n            rest_iri = RDF.nil if i &gt;= len(container) - 1 else f\"_:rest_{uuid}\"\n            rdf.append((iri, RDF.first, first_iri))\n            rdf.append((iri, RDF.rest, rest_iri))\n            iri = rest_iri\n\n    elif isinstance(container, Mapping):\n        rdf.append((iri, RDF.type, OTEIO.Dictionary))\n\n        for key, value in container.items():\n            uuid = uuid4()\n            recognised = recognised_keys and key in recognised_keys\n            value_iri = get_obj_iri(value, uuid)\n            if recognised:\n                rdf.append(\n                    (iri, recognised_keys[key], value_iri)  # type: ignore\n                )\n            if not recognised or keep:\n                key_indv = f\"_:key_{uuid}\"\n                value_indv = f\"_:value_{uuid}\"\n                pair = f\"_:pair_{uuid}\"\n                rdf.extend(\n                    [\n                        (key_indv, RDF.type, OTEIO.DictionaryKey),\n                        (\n                            key_indv,\n                            EMMO.hasStringValue,\n                            Literal(key, lang=lang),\n                        ),\n                        (value_indv, RDF.type, OTEIO.DictionaryValue),\n                        (value_indv, EMMO.hasValue, value_iri),\n                        (pair, RDF.type, OTEIO.KeyValuePair),\n                        (pair, OTEIO.hasDictionaryKey, key_indv),\n                        (pair, OTEIO.hasDictionaryValue, value_indv),\n                        (iri, OTEIO.hasKeyValuePair, pair),\n                    ]\n                )\n    else:\n        raise TypeError(\"container must be a mapping or sequence\")\n\n    return rdf\n</code></pre>"},{"location":"api_reference/convert/convert/#tripper.convert.convert.from_dict","title":"<code>from_dict(dct, iri, bases=None, lang='en', recognised_keys=None, keep=False)</code>","text":"<p>Serialise a dict as RDF.</p> <p>Parameters:</p> Name Type Description Default <code>dct</code> <code>dict</code> <p>The dict to be saved.</p> required <code>iri</code> <code>str</code> <p>IRI of individual that stands for the dict.</p> required <code>bases</code> <code>Optional[Sequence]</code> <p>Parent class(es) or the dict.  Unused.</p> <code>None</code> <code>lang</code> <code>str</code> <p>Language to use for keys.</p> <code>'en'</code> <code>recognised_keys</code> <code>Optional[Union[Dict, str]]</code> <p>An optional dict that maps dict keys that correspond to IRIs of recognised RDF properties. If set to the special string \"basic\", the <code>BASIC_RECOGNISED_KEYS</code> module will be used.</p> <code>None</code> <code>keep</code> <code>bool</code> <p>Whether to keep the key-value pair representation for items serialised with recognised_keys.  Note that this will duplicate potential large literal values.</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>List of RDF triples.</p> Source code in <code>tripper/convert/convert.py</code> <pre><code>def from_dict(\n    dct: dict,\n    iri: str,\n    bases: \"Optional[Sequence]\" = None,\n    lang: str = \"en\",\n    recognised_keys: \"Optional[Union[Dict, str]]\" = None,\n    keep: bool = False,\n) -&gt; list:\n    \"\"\"Serialise a dict as RDF.\n\n    Arguments:\n        dct: The dict to be saved.\n        iri: IRI of individual that stands for the dict.\n        bases: Parent class(es) or the dict.  Unused.\n        lang: Language to use for keys.\n        recognised_keys: An optional dict that maps dict keys that\n            correspond to IRIs of recognised RDF properties.\n            If set to the special string \"basic\", the\n            `BASIC_RECOGNISED_KEYS` module will be used.\n        keep: Whether to keep the key-value pair representation for\n            items serialised with recognised_keys.  Note that this\n            will duplicate potential large literal values.\n\n    Returns:\n        List of RDF triples.\n    \"\"\"\n    del bases  # silence pylint about unused variable\n    warnings.warn(\n        \"from_dict() is deprecated.  Use from_container() instead\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    return from_container(\n        dct, iri, lang=lang, recognised_keys=recognised_keys, keep=keep\n    )\n</code></pre>"},{"location":"api_reference/convert/convert/#tripper.convert.convert.load_container","title":"<code>load_container(ts, iri, recognised_keys=None)</code>","text":"<p>Deserialise a Python container object from a triplestore.</p> <p>Parameters:</p> Name Type Description Default <code>ts</code> <code>Triplestore</code> <p>Triplestore from which to fetch the dict.</p> required <code>iri</code> <code>str</code> <p>IRI of individual that stands for the dict to fetch.</p> required <code>recognised_keys</code> <code>Optional[Union[Dict, str]]</code> <p>An optional dict that maps dict keys that correspond to IRIs of recognised RDF properties. If set to the special string \"basic\", the <code>BASIC_RECOGNISED_KEYS</code> module will be used.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[dict, list]</code> <p>A Python container object corresponding to <code>iri</code>.</p> Source code in <code>tripper/convert/convert.py</code> <pre><code>def load_container(\n    ts: \"Triplestore\",\n    iri: str,\n    recognised_keys: \"Optional[Union[Dict, str]]\" = None,\n) -&gt; \"Union[dict, list]\":\n    \"\"\"Deserialise a Python container object from a triplestore.\n\n    Arguments:\n        ts: Triplestore from which to fetch the dict.\n        iri: IRI of individual that stands for the dict to fetch.\n        recognised_keys: An optional dict that maps dict keys that\n            correspond to IRIs of recognised RDF properties.\n            If set to the special string \"basic\", the\n            `BASIC_RECOGNISED_KEYS` module will be used.\n\n    Returns:\n        A Python container object corresponding to `iri`.\n    \"\"\"\n    # pylint: disable=too-many-branches\n    if iri == RDF.nil:\n        return []\n\n    if recognised_keys == \"basic\":\n        recognised_keys = BASIC_RECOGNISED_KEYS\n\n    recognised_iris = (\n        {v: k for k, v in recognised_keys.items()}  # type: ignore\n        if recognised_keys\n        else {}\n    )\n    parents = set(ts.objects(iri, RDF.type))\n\n    def get_obj(value):\n        \"\"\"Return Python object for `value`.\"\"\"\n        value_type = ts.value(value, RDF.type)\n        if value_type == OTEIO.Dictionary:\n            return load_container(ts, value, recognised_keys=recognised_keys)\n        if value_type == RDF.List:\n            return load_container(ts, value, recognised_keys=recognised_keys)\n        if value == OWL.Nothing:\n            return None\n        return value.value if isinstance(value, Literal) else value\n\n    if OTEIO.Dictionary in parents:\n        container = {}\n        for pred, obj in ts.predicate_objects(iri):\n            if pred == OTEIO.hasKeyValuePair:\n                key_iri = ts.value(obj, OTEIO.hasDictionaryKey)\n                key = ts.value(key_iri, EMMO.hasStringValue)\n                value_iri = ts.value(obj, OTEIO.hasDictionaryValue)\n                value = ts.value(value_iri, EMMO.hasValue)\n                container[str(key)] = get_obj(value)\n            elif pred in recognised_iris:\n                container[recognised_iris[pred]] = get_obj(obj)\n            elif pred not in (RDF.type,):\n                raise ValueError(\n                    f\"Unrecognised predicate '{pred}' in dict: {iri}\"\n                )\n\n        # Recognised IRIs\n        if recognised_keys:\n            iris = {v: k for k, v in recognised_keys.items()}  # type: ignore\n            for _, p, o in ts.triples(subject=iri):\n                key = iris.get(p)  # type: ignore\n                if key and p in iris and key not in container:\n                    container[key] = (\n                        o.value\n                        if isinstance(o, Literal)  # type: ignore\n                        else o\n                    )\n\n    elif RDF.List in parents:\n        container = []  # type: ignore\n        while True:\n            first = ts.value(iri, RDF.first)\n            rest = ts.value(iri, RDF.rest)\n            container.append(get_obj(first))  # type: ignore\n            if rest == RDF.nil:\n                break\n            iri = rest\n\n    else:\n        raise TypeError(\n            f\"iri '{iri}' should be either a rdf:List or an oteio:Dictionary\"\n        )\n\n    return container\n</code></pre>"},{"location":"api_reference/convert/convert/#tripper.convert.convert.load_dict","title":"<code>load_dict(ts, iri, recognised_keys=None)</code>","text":"<p>Deserialise a dict from an RDF triplestore.</p> <p>Parameters:</p> Name Type Description Default <code>ts</code> <code>Triplestore</code> <p>Triplestore from which to fetch the dict.</p> required <code>iri</code> <code>str</code> <p>IRI of individual that stands for the dict to fetch.</p> required <code>recognised_keys</code> <code>Optional[Union[Dict, str]]</code> <p>An optional dict that maps dict keys that correspond to IRIs of recognised RDF properties. If set to the special string \"basic\", the <code>BASIC_RECOGNISED_KEYS</code> module will be used.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[dict, list]</code> <p>A dict corresponding to <code>iri</code>.</p> Source code in <code>tripper/convert/convert.py</code> <pre><code>def load_dict(\n    ts: \"Triplestore\",\n    iri: str,\n    recognised_keys: \"Optional[Union[Dict, str]]\" = None,\n) -&gt; \"Union[dict, list]\":\n    \"\"\"Deserialise a dict from an RDF triplestore.\n\n    Arguments:\n        ts: Triplestore from which to fetch the dict.\n        iri: IRI of individual that stands for the dict to fetch.\n        recognised_keys: An optional dict that maps dict keys that\n            correspond to IRIs of recognised RDF properties.\n            If set to the special string \"basic\", the\n            `BASIC_RECOGNISED_KEYS` module will be used.\n\n    Returns:\n        A dict corresponding to `iri`.\n    \"\"\"\n    warnings.warn(\n        \"load_dict() is deprecated.  Use load_container() instead\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    return load_container(ts, iri, recognised_keys=recognised_keys)\n</code></pre>"},{"location":"api_reference/convert/convert/#tripper.convert.convert.save_container","title":"<code>save_container(ts, container, iri, lang='en', recognised_keys=None, keep=False)</code>","text":"<p>Save a basic Python container object to a triplestore.</p> <p>Parameters:</p> Name Type Description Default <code>ts</code> <code>Triplestore</code> <p>Triplestore to which to write the container object.</p> required <code>container</code> <code>Union[Mapping[str, Any], Sequence[Any]]</code> <p>The container object to be saved.</p> required <code>iri</code> <code>str</code> <p>IRI of individual that stands for the container object.</p> required <code>lang</code> <code>str</code> <p>Language to use for keys.</p> <code>'en'</code> <code>recognised_keys</code> <code>Optional[Union[Dict, str]]</code> <p>An optional dict that maps dict mapping that correspond to IRIs of recognised RDF properties. If set to the special string \"basic\", the <code>BASIC_RECOGNISED_KEYS</code> module will be used.</p> <code>None</code> <code>keep</code> <code>bool</code> <p>Whether to keep the key-value pair representation for items serialised with recognised_keys.  Note that this will duplicate potential large literal values.</p> <code>False</code> Source code in <code>tripper/convert/convert.py</code> <pre><code>def save_container(\n    ts: \"Triplestore\",\n    container: \"Union[Mapping[str, Any], Sequence[Any]]\",\n    iri: str,\n    lang: str = \"en\",\n    recognised_keys: \"Optional[Union[Dict, str]]\" = None,\n    keep: bool = False,\n) -&gt; None:\n    \"\"\"Save a basic Python container object to a triplestore.\n\n    Arguments:\n        ts: Triplestore to which to write the container object.\n        container: The container object to be saved.\n        iri: IRI of individual that stands for the container object.\n        lang: Language to use for keys.\n        recognised_keys: An optional dict that maps dict mapping that\n            correspond to IRIs of recognised RDF properties.\n            If set to the special string \"basic\", the\n            `BASIC_RECOGNISED_KEYS` module will be used.\n        keep: Whether to keep the key-value pair representation for\n            items serialised with recognised_keys.  Note that this\n            will duplicate potential large literal values.\n    \"\"\"\n    if \"rdf\" not in ts.namespaces:\n        ts.bind(\"rdf\", RDF)\n    if \"dcat\" not in ts.namespaces:\n        ts.bind(\"dcat\", DCAT)\n    if \"emmo\" not in ts.namespaces:\n        ts.bind(\"emmo\", EMMO)\n    if \"oteio\" not in ts.namespaces:\n        ts.bind(\"oteio\", OTEIO)\n\n    ts.add_triples(\n        from_container(\n            container,\n            iri,\n            lang=lang,\n            recognised_keys=recognised_keys,\n            keep=keep,\n        )\n    )\n</code></pre>"},{"location":"api_reference/convert/convert/#tripper.convert.convert.save_dict","title":"<code>save_dict(ts, dct, iri, bases=None, lang='en', recognised_keys=None, keep=False)</code>","text":"<p>Save a dict to a triplestore.</p> <p>Parameters:</p> Name Type Description Default <code>ts</code> <code>Triplestore</code> <p>Triplestore to which to write the dict.</p> required <code>dct</code> <code>Mapping[str, Any]</code> <p>The dict to be saved.</p> required <code>iri</code> <code>str</code> <p>IRI of individual that stands for the dict.</p> required <code>bases</code> <code>Optional[Sequence]</code> <p>Parent class(es) or the dict.  Unused.</p> <code>None</code> <code>lang</code> <code>str</code> <p>Language to use for keys.</p> <code>'en'</code> <code>recognised_keys</code> <code>Optional[Union[Dict, str]]</code> <p>An optional dict that maps dict keys that correspond to IRIs of recognised RDF properties. If set to the special string \"basic\", the <code>BASIC_RECOGNISED_KEYS</code> module will be used.</p> <code>None</code> <code>keep</code> <code>bool</code> <p>Whether to keep the key-value pair representation for items serialised with recognised_keys.  Note that this will duplicate potential large literal values.</p> <code>False</code> Source code in <code>tripper/convert/convert.py</code> <pre><code>def save_dict(\n    ts: \"Triplestore\",\n    dct: \"Mapping[str, Any]\",\n    iri: str,\n    bases: \"Optional[Sequence]\" = None,\n    lang: str = \"en\",\n    recognised_keys: \"Optional[Union[Dict, str]]\" = None,\n    keep: bool = False,\n) -&gt; None:\n    \"\"\"Save a dict to a triplestore.\n\n    Arguments:\n        ts: Triplestore to which to write the dict.\n        dct: The dict to be saved.\n        iri: IRI of individual that stands for the dict.\n        bases: Parent class(es) or the dict.  Unused.\n        lang: Language to use for keys.\n        recognised_keys: An optional dict that maps dict keys that\n            correspond to IRIs of recognised RDF properties.\n            If set to the special string \"basic\", the\n            `BASIC_RECOGNISED_KEYS` module will be used.\n        keep: Whether to keep the key-value pair representation for\n            items serialised with recognised_keys.  Note that this\n            will duplicate potential large literal values.\n    \"\"\"\n    del bases  # silence pylint about unused variable\n    warnings.warn(\n        \"save_dict() is deprecated.  Use save_container() instead\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    return save_container(\n        ts, dct, iri, lang=lang, recognised_keys=recognised_keys, keep=keep\n    )\n</code></pre>"},{"location":"api_reference/mappings/mappings/","title":"mappings","text":"<p>Implements mappings between entities.</p> <p>Units are currently handled with pint.Quantity.  The benefit of this compared to explicit unit conversions, is that units will be handled transparently by mapping functions, without any need to specify units of input and output parameters.</p> <p>Shapes are automatically handled by expressing non-scalar quantities with numpy.</p>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.AmbiguousMappingError","title":"<code> AmbiguousMappingError            (MappingError)         </code>","text":"<p>A property maps to more than one value.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>class AmbiguousMappingError(MappingError):\n    \"\"\"A property maps to more than one value.\"\"\"\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.InconsistentDimensionError","title":"<code> InconsistentDimensionError            (MappingError)         </code>","text":"<p>The size of a dimension is assigned to more than one value.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>class InconsistentDimensionError(MappingError):\n    \"\"\"The size of a dimension is assigned to more than one value.\"\"\"\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.InconsistentTriplesError","title":"<code> InconsistentTriplesError            (MappingError)         </code>","text":"<p>Inconsistcy in RDF triples.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>class InconsistentTriplesError(MappingError):\n    \"\"\"Inconsistcy in RDF triples.\"\"\"\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.InsufficientMappingError","title":"<code> InsufficientMappingError            (MappingError)         </code>","text":"<p>There are properties or dimensions that are not mapped.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>class InsufficientMappingError(MappingError):\n    \"\"\"There are properties or dimensions that are not mapped.\"\"\"\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingError","title":"<code> MappingError            (Exception)         </code>","text":"<p>Base class for mapping errors.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>class MappingError(Exception):\n    \"\"\"Base class for mapping errors.\"\"\"\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep","title":"<code> MappingStep        </code>","text":"<p>A step in a mapping route from a target to one or more sources.</p> <p>A mapping step corresponds to one or more RDF triples.  In the simple case of a <code>mo:mapsTo</code> or <code>rdfs:isSubclassOf</code> relation, it is only one triple.  For transformations that has several input and output, a set of triples are expected.</p> <p>Parameters:</p> Name Type Description Default <code>output_iri</code> <code>str</code> <p>IRI of the output concept.</p> required <code>steptype</code> <code>'StepType'</code> <p>One of the step types from the StepType enum.</p> <code>&lt;StepType.UNSPECIFIED: 0&gt;</code> <code>function</code> <code>'Optional[Callable]'</code> <p>Callable that evaluates the output from the input.</p> <code>None</code> <code>cost</code> <code>'Union[float, Callable]'</code> <p>The cost related to this mapping step.  Should be either a float or a callable taking three arguments (<code>triplestore</code>, <code>input_iris</code> and <code>output_iri</code>) and return the cost as a float.</p> <code>1.0</code> <code>output_unit</code> <code>'Optional[str]'</code> <p>Output unit.</p> <code>None</code> <code>triplestore</code> <code>'Optional[Triplestore]'</code> <p>Triplestore instance containing the knowledge base that this mapping step was created from.</p> <code>None</code> <p>The arguments can also be assigned as attributes.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>class MappingStep:\n    \"\"\"A step in a mapping route from a target to one or more sources.\n\n    A mapping step corresponds to one or more RDF triples.  In the\n    simple case of a `mo:mapsTo` or `rdfs:isSubclassOf` relation, it is\n    only one triple.  For transformations that has several input and\n    output, a set of triples are expected.\n\n    Arguments:\n        output_iri: IRI of the output concept.\n        steptype: One of the step types from the StepType enum.\n        function: Callable that evaluates the output from the input.\n        cost: The cost related to this mapping step.  Should be either a\n            float or a callable taking three arguments (`triplestore`,\n            `input_iris` and `output_iri`) and return the cost as a float.\n        output_unit: Output unit.\n        triplestore: Triplestore instance containing the knowledge base\n            that this mapping step was created from.\n\n    The arguments can also be assigned as attributes.\n    \"\"\"\n\n    # pylint: disable=too-many-instance-attributes\n\n    def __init__(\n        self,\n        output_iri: str,\n        steptype: \"StepType\" = StepType.UNSPECIFIED,\n        function: \"Optional[Callable]\" = None,\n        cost: \"Union[float, Callable]\" = 1.0,\n        output_unit: \"Optional[str]\" = None,\n        triplestore: \"Optional[Triplestore]\" = None,\n    ) -&gt; None:\n        self.output_iri = output_iri\n        self.steptype = steptype\n        self.function = function\n        self.cost = cost\n        self.triplestore = triplestore\n        self.output_unit = output_unit\n        self.input_routes: \"List[dict]\" = []  # list of inputs dicts\n        self.join_mode = False  # whether to join upcoming input\n        self.joined_input: \"Inputs\" = {}\n\n    def add_inputs(self, inputs: \"Inputs\") -&gt; None:\n        \"\"\"Add input Mapping (e.g., dict) for an input route.\"\"\"\n        assert isinstance(inputs, Mapping)  # nosec B101\n        self.input_routes.append(inputs)\n\n    def add_input(self, input: \"Input\", name: \"Optional[str]\" = None) -&gt; None:\n        \"\"\"Add an input (MappingStep or Value), where `name` is the name\n        assigned to the argument.\n\n        If the `join_mode` attribute is false, a new route is created with\n        only one input.\n\n        If the `join_mode` attribute is true, the input is remembered, but\n        first added when `join_input()` is called.\n\n        Arguments:\n            input: A mapping step or a value.\n            name: Name assigned to the argument.\n        \"\"\"\n        assert isinstance(input, (MappingStep, Value))  # nosec B101\n        argname = name if name else f\"arg{len(self.joined_input)+1}\"\n        if self.join_mode:\n            self.joined_input[argname] = input\n        else:\n            self.add_inputs({argname: input})\n\n    def join_input(self) -&gt; None:\n        \"\"\"Join all input added with add_input() since `join_mode` was set\n        true.  Resets `join_mode` to false.\"\"\"\n        if not self.join_mode:\n            raise MappingError(\"Calling join_input() when join_mode is false.\")\n        self.join_mode = False\n        self.add_inputs(self.joined_input)\n        self.joined_input = {}\n\n    def eval(\n        self,\n        routeno: \"Optional[int]\" = None,\n        unit: \"Optional[str]\" = None,\n        magnitude: bool = False,\n        quantity: \"Optional[Type[Quantity]]\" = None,\n    ) -&gt; \"Any\":\n        \"\"\"Returns the evaluated value of given input route number.\n\n        Arguments:\n            routeno: The route number to evaluate.  If None (default)\n                the route with the lowest cost is evalueated.\n            unit: return the result in the given unit.\n                Implies `magnitude=True`.\n            magnitude: Whether to only return the magnitude of the evaluated\n                value (with no unit).\n            quantity: Quantity class to use for evaluation.  Defaults to pint.\n\n        Returns:\n            Evaluation result.\n        \"\"\"\n        if not self.number_of_routes():\n            raise MissingRelationError(\n                f\"no route to evaluate '{self.output_iri}'\"\n            )\n        if quantity is None:\n            quantity = Quantity\n        if routeno is None:\n            ((_, routeno),) = self.lowest_costs(nresults=1)\n        inputs, idx = self.get_inputs(routeno)\n        values = get_values(inputs, idx, quantity=quantity)\n\n        if self.function:\n            value = self.function(**values)\n        elif len(values) == 1:\n            (value,) = values.values()\n        else:\n            raise TypeError(\n                f\"Expected inputs to be a single argument: {values}\"\n            )\n\n        if isinstance(value, Quantity) and unit:\n            return value.m_as(unit)\n        if isinstance(value, Quantity) and magnitude:\n            return value.m\n        if isinstance(value, Value):\n            return value.get_value(\n                unit=unit, magnitude=magnitude, quantity=quantity\n            )\n        return value\n\n    def get_inputs(self, routeno: int) -&gt; \"Tuple[Inputs, int]\":\n        \"\"\"Returns input and input index `(inputs, idx)` for route number\n        `routeno`.\n\n        Arguments:\n            routeno: The route number to return inputs for.\n\n        Returns:\n            Inputs and difference between route number and number of routes for\n            an input dictioary.\n        \"\"\"\n        n = 0\n        for inputs in self.input_routes:\n            n0 = n\n            n += get_nroutes(inputs)\n            if n &gt; routeno:\n                return inputs, routeno - n0\n        raise ValueError(f\"routeno={routeno} exceeds number of routes\")\n\n    def get_input_iris(self, routeno: int) -&gt; \"Dict[str, Optional[str]]\":\n        \"\"\"Returns a dict mapping input names to iris for the given route\n        number.\n\n        Arguments:\n            routeno: The route number to return a mapping for.\n\n        Returns:\n            Mapping of input names to IRIs.\n\n        \"\"\"\n        inputs, _ = self.get_inputs(routeno)\n        return {\n            k: v.output_iri if isinstance(v, MappingStep) else v.output_iri\n            for k, v in inputs.items()\n        }\n\n    def number_of_routes(self) -&gt; int:\n        \"\"\"Total number of routes to this mapping step.\n\n        Returns:\n            Total number of routes to this mapping step.\n        \"\"\"\n        n = 0\n        for inputs in self.input_routes:\n            n += get_nroutes(inputs)\n        return n\n\n    def lowest_costs(self, nresults: int = 5) -&gt; \"List[Tuple[float, int]]\":\n        \"\"\"Returns a list of `(cost, routeno)` tuples with up to the `nresult`\n        lowest costs and their corresponding route numbers.\n\n        Arguments:\n            nresults: Number of results to return.\n\n        Returns:\n            A list of `(cost, routeno)` tuples.\n        \"\"\"\n        try:\n            import numpy as np  # pylint: disable=import-outside-toplevel\n        except ImportError as exc:\n            raise RuntimeError(\n                \"Mappings.lowest_costs() requires numpy.\\n\"\n                \"Install it with\\n\\n\"\n                \"    pip install numpy\"\n            ) from exc\n\n        result = []\n        n = 0  # total number of routes\n\n        # Loop over all toplevel routes leading into this mapping step\n        for inputs in self.input_routes:\n            # For each route, loop over all input arguments of this step\n            # The number of permutations we must consider is the product\n            # of the total number of routes to each input argument.\n            #\n            # We (potentially drastic) limit the possibilities by only\n            # considering the `nresults` routes with lowest costs into\n            # each argument.  This gives at maximum\n            #\n            #     nresults * number_of_input_arguments\n            #\n            # possibilities. We calculate the costs for all of them and\n            # store them in an array with two columns: `cost` and `routeno`.\n            # The `results` list is extended with the cost array\n            # for each toplevel route leading into this step.\n            base = np.rec.fromrecords(\n                [(0.0, 0)], names=\"cost,routeno\", formats=\"f8,i8\"\n            )\n            m = 1\n            for input in inputs.values():\n                if isinstance(input, MappingStep):\n                    nroutes = input.number_of_routes()\n                    res = np.rec.fromrecords(\n                        sorted(\n                            input.lowest_costs(nresults=nresults),\n                            key=lambda x: x[1],\n                        ),\n                        # [\n                        #     row\n                        #     for row in sorted(\n                        #         input.lowest_costs(nresults=nresults),\n                        #         key=lambda x: x[1],\n                        #     )\n                        # ],\n                        dtype=base.dtype,\n                    )\n                    res1 = res.repeat(len(base))\n                    base = np.tile(base, len(res))\n                    base.cost += res1.cost\n                    base.routeno += res1.routeno * m\n                    m *= nroutes\n                else:\n                    base.cost += input.cost\n\n            # Reduce the length of base (makes probably only sense in\n            # the case self.cost is a callable, but it doesn't hurt...)\n            base.sort()\n            base = base[:nresults]\n            base.routeno += n\n            n += m\n\n            # Add the cost for this step to `res`.  If `self.cost` is\n            # a callable, we call it with the input for each routeno\n            # as arguments.  Otherwise `self.cost` is the cost of this\n            # mapping step.\n            if callable(self.cost):\n                for i, rno in enumerate(base.routeno):\n                    inputs, _ = self.get_inputs(rno)\n                    input_iris = [\n                        input.output_iri for input in inputs.values()\n                    ]\n                    owncost = self.cost(\n                        self.triplestore, input_iris, self.output_iri\n                    )\n                    base.cost[i] += owncost\n            else:\n                owncost = self.cost\n                base.cost += owncost\n\n            result.extend(base.tolist())\n\n        # Finally sort the results according to cost and return the\n        # `nresults` rows with lowest cost.\n        return sorted(result)[:nresults]\n\n    def show(\n        self,\n        routeno: \"Optional[int]\" = None,\n        name: \"Optional[str]\" = None,\n        indent: int = 0,\n    ) -&gt; str:\n        \"\"\"Returns a string representation of the mapping routes to this step.\n\n        Arguments:\n            routeno: show given route.  The default is to show all routes.\n            name: Name of the last mapping step (mainly for internal use).\n            indent: How of blanks to prepend each line with (mainly for\n                internal use).\n\n        Returns:\n            String representation of the mapping routes.\n        \"\"\"\n        strings = []\n        ind = \" \" * indent\n        strings.append(ind + f'{name if name else \"Step\"}:')\n        strings.append(\n            ind + f\"  steptype: \"\n            f\"{self.steptype.name if self.steptype else None}\"\n        )\n        strings.append(ind + f\"  output_iri: {self.output_iri}\")\n        strings.append(ind + f\"  output_unit: {self.output_unit}\")\n        strings.append(ind + f\"  cost: {self.cost}\")\n        if routeno is None:\n            strings.append(ind + \"  routes:\")\n            for inputs in self.input_routes:\n                t = \"\\n\".join(\n                    [\n                        input_.show(name=name_, indent=indent + 6)\n                        for name_, input_ in inputs.items()\n                    ]\n                )\n                strings.append(ind + \"    - \" + t[indent + 6 :])\n        else:\n            strings.append(ind + \"  inputs:\")\n            inputs, idx = self.get_inputs(routeno)\n            t = \"\\n\".join(\n                [\n                    input_.show(routeno=idx, name=name_, indent=indent + 6)\n                    for name_, input_ in inputs.items()\n                ]\n            )\n            strings.append(ind + \"    - \" + t[indent + 6 :])\n        return \"\\n\".join(strings)\n\n    def _iri(self, iri: str) -&gt; str:\n        \"\"\"Help method that returns prefixed iri if possible, otherwise\n        `iri`.\"\"\"\n        return self.triplestore.prefix_iri(iri) if self.triplestore else iri\n\n    def _visualise(\n        self, routeno: int, next_iri: str, next_steptype: StepType\n    ) -&gt; str:\n        \"\"\"Help function for visualise().\n\n        Arguments:\n            routeno: Route number to visualise.\n            next_iri: IRI of the next mapping step (i.e. the previous mapping\n                when starting from the target).\n            next_steptype: Step type from this to next iri.\n\n        Returns:\n            Mapping route in dot (graphviz) notation.\n        \"\"\"\n        hasOutput = EMMO.EMMO_c4bace1d_4db0_4cd3_87e9_18122bae2840\n\n        # Edge labels. We invert the steptypes, since we want to visualise\n        # the workflow in forward direction, while the steptypes refer to\n        # backward direction\n        labeldict = {\n            StepType.UNSPECIFIED: \"\",\n            StepType.MAPSTO: \"inverse(mapsTo)\",\n            StepType.INV_MAPSTO: \"mapsTo\",\n            StepType.INSTANCEOF: \"instanceOf\",\n            StepType.INV_INSTANCEOF: \"inverse(instanceOf)\",\n            StepType.SUBCLASSOF: \"subClassOf\",\n            StepType.INV_SUBCLASSOF: \"inverse(subClassOf)\",\n            StepType.FUNCTION: \"function\",\n        }\n        inputs, idx = self.get_inputs(routeno)\n        strings = []\n        for _, input in inputs.items():\n            if isinstance(input, Value):\n                strings.append(\n                    f'  \"{self._iri(input.output_iri)}\" -&gt; '\n                    f'\"{self._iri(self.output_iri)}\" '\n                    f'[label=\"{labeldict[self.steptype]}\"];'\n                )\n            elif isinstance(input, MappingStep):\n                strings.append(\n                    input._visualise(  # pylint: disable=protected-access\n                        routeno=idx,\n                        next_iri=self.output_iri,\n                        next_steptype=self.steptype,\n                    )\n                )\n            else:\n                raise TypeError(\"input should be Value or MappingStep\")\n        if next_iri:\n            label = labeldict[next_steptype]\n            if next_steptype == StepType.FUNCTION and self.triplestore:\n                model_iri = self.triplestore.value(\n                    predicate=hasOutput,  # Assuming EMMO\n                    object=next_iri,\n                    default=\"function\",\n                    any=True,\n                )\n                if model_iri:\n                    label = self.triplestore.value(\n                        subject=model_iri,\n                        predicate=RDFS.label,\n                        default=self._iri(model_iri),\n                        any=True,\n                    )\n            else:\n                label = labeldict[next_steptype]\n            strings.append(\n                f'  \"{self._iri(self.output_iri)}\" -&gt; '\n                f'\"{self._iri(next_iri)}\" [label=\"{label}\"];'\n            )\n        return \"\\n\".join(strings)\n\n    def visualise(\n        self,\n        routeno: int,\n        output: \"Optional[str]\" = None,\n        format: \"Optional[str]\" = \"png\",\n        dot: str = \"dot\",\n    ) -&gt; str:\n        \"\"\"Greate a Graphviz visualisation of a given mapping route.\n\n        Arguments:\n            routeno: Number of mapping route to visualise.\n            output: If given, write the graph to this file.\n            format: File format to use with `output`.\n            dot: Path to Graphviz dot executable.\n\n        Returns:\n            String representation of the graph in dot format.\n        \"\"\"\n        strings = []\n        strings.append(\"digraph G {\")\n        strings.append(self._visualise(routeno, \"\", StepType.UNSPECIFIED))\n        strings.append(\"}\")\n        graph = \"\\n\".join(strings) + \"\\n\"\n        if output:\n            subprocess.run(\n                args=[dot, f\"-T{format}\", \"-o\", output],\n                shell=False,  # nosec: B603\n                check=True,\n                input=graph.encode(),\n            )\n        return graph\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep.add_input","title":"<code>add_input(self, input, name=None)</code>","text":"<p>Add an input (MappingStep or Value), where <code>name</code> is the name assigned to the argument.</p> <p>If the <code>join_mode</code> attribute is false, a new route is created with only one input.</p> <p>If the <code>join_mode</code> attribute is true, the input is remembered, but first added when <code>join_input()</code> is called.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>'Input'</code> <p>A mapping step or a value.</p> required <code>name</code> <code>'Optional[str]'</code> <p>Name assigned to the argument.</p> <code>None</code> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def add_input(self, input: \"Input\", name: \"Optional[str]\" = None) -&gt; None:\n    \"\"\"Add an input (MappingStep or Value), where `name` is the name\n    assigned to the argument.\n\n    If the `join_mode` attribute is false, a new route is created with\n    only one input.\n\n    If the `join_mode` attribute is true, the input is remembered, but\n    first added when `join_input()` is called.\n\n    Arguments:\n        input: A mapping step or a value.\n        name: Name assigned to the argument.\n    \"\"\"\n    assert isinstance(input, (MappingStep, Value))  # nosec B101\n    argname = name if name else f\"arg{len(self.joined_input)+1}\"\n    if self.join_mode:\n        self.joined_input[argname] = input\n    else:\n        self.add_inputs({argname: input})\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep.add_inputs","title":"<code>add_inputs(self, inputs)</code>","text":"<p>Add input Mapping (e.g., dict) for an input route.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def add_inputs(self, inputs: \"Inputs\") -&gt; None:\n    \"\"\"Add input Mapping (e.g., dict) for an input route.\"\"\"\n    assert isinstance(inputs, Mapping)  # nosec B101\n    self.input_routes.append(inputs)\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep.eval","title":"<code>eval(self, routeno=None, unit=None, magnitude=False, quantity=None)</code>","text":"<p>Returns the evaluated value of given input route number.</p> <p>Parameters:</p> Name Type Description Default <code>routeno</code> <code>'Optional[int]'</code> <p>The route number to evaluate.  If None (default) the route with the lowest cost is evalueated.</p> <code>None</code> <code>unit</code> <code>'Optional[str]'</code> <p>return the result in the given unit. Implies <code>magnitude=True</code>.</p> <code>None</code> <code>magnitude</code> <code>bool</code> <p>Whether to only return the magnitude of the evaluated value (with no unit).</p> <code>False</code> <code>quantity</code> <code>'Optional[Type[Quantity]]'</code> <p>Quantity class to use for evaluation.  Defaults to pint.</p> <code>None</code> <p>Returns:</p> Type Description <code>'Any'</code> <p>Evaluation result.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def eval(\n    self,\n    routeno: \"Optional[int]\" = None,\n    unit: \"Optional[str]\" = None,\n    magnitude: bool = False,\n    quantity: \"Optional[Type[Quantity]]\" = None,\n) -&gt; \"Any\":\n    \"\"\"Returns the evaluated value of given input route number.\n\n    Arguments:\n        routeno: The route number to evaluate.  If None (default)\n            the route with the lowest cost is evalueated.\n        unit: return the result in the given unit.\n            Implies `magnitude=True`.\n        magnitude: Whether to only return the magnitude of the evaluated\n            value (with no unit).\n        quantity: Quantity class to use for evaluation.  Defaults to pint.\n\n    Returns:\n        Evaluation result.\n    \"\"\"\n    if not self.number_of_routes():\n        raise MissingRelationError(\n            f\"no route to evaluate '{self.output_iri}'\"\n        )\n    if quantity is None:\n        quantity = Quantity\n    if routeno is None:\n        ((_, routeno),) = self.lowest_costs(nresults=1)\n    inputs, idx = self.get_inputs(routeno)\n    values = get_values(inputs, idx, quantity=quantity)\n\n    if self.function:\n        value = self.function(**values)\n    elif len(values) == 1:\n        (value,) = values.values()\n    else:\n        raise TypeError(\n            f\"Expected inputs to be a single argument: {values}\"\n        )\n\n    if isinstance(value, Quantity) and unit:\n        return value.m_as(unit)\n    if isinstance(value, Quantity) and magnitude:\n        return value.m\n    if isinstance(value, Value):\n        return value.get_value(\n            unit=unit, magnitude=magnitude, quantity=quantity\n        )\n    return value\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep.get_input_iris","title":"<code>get_input_iris(self, routeno)</code>","text":"<p>Returns a dict mapping input names to iris for the given route number.</p> <p>Parameters:</p> Name Type Description Default <code>routeno</code> <code>int</code> <p>The route number to return a mapping for.</p> required <p>Returns:</p> Type Description <code>'Dict[str, Optional[str]]'</code> <p>Mapping of input names to IRIs.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def get_input_iris(self, routeno: int) -&gt; \"Dict[str, Optional[str]]\":\n    \"\"\"Returns a dict mapping input names to iris for the given route\n    number.\n\n    Arguments:\n        routeno: The route number to return a mapping for.\n\n    Returns:\n        Mapping of input names to IRIs.\n\n    \"\"\"\n    inputs, _ = self.get_inputs(routeno)\n    return {\n        k: v.output_iri if isinstance(v, MappingStep) else v.output_iri\n        for k, v in inputs.items()\n    }\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep.get_inputs","title":"<code>get_inputs(self, routeno)</code>","text":"<p>Returns input and input index <code>(inputs, idx)</code> for route number <code>routeno</code>.</p> <p>Parameters:</p> Name Type Description Default <code>routeno</code> <code>int</code> <p>The route number to return inputs for.</p> required <p>Returns:</p> Type Description <code>'Tuple[Inputs, int]'</code> <p>Inputs and difference between route number and number of routes for an input dictioary.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def get_inputs(self, routeno: int) -&gt; \"Tuple[Inputs, int]\":\n    \"\"\"Returns input and input index `(inputs, idx)` for route number\n    `routeno`.\n\n    Arguments:\n        routeno: The route number to return inputs for.\n\n    Returns:\n        Inputs and difference between route number and number of routes for\n        an input dictioary.\n    \"\"\"\n    n = 0\n    for inputs in self.input_routes:\n        n0 = n\n        n += get_nroutes(inputs)\n        if n &gt; routeno:\n            return inputs, routeno - n0\n    raise ValueError(f\"routeno={routeno} exceeds number of routes\")\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep.join_input","title":"<code>join_input(self)</code>","text":"<p>Join all input added with add_input() since <code>join_mode</code> was set true.  Resets <code>join_mode</code> to false.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def join_input(self) -&gt; None:\n    \"\"\"Join all input added with add_input() since `join_mode` was set\n    true.  Resets `join_mode` to false.\"\"\"\n    if not self.join_mode:\n        raise MappingError(\"Calling join_input() when join_mode is false.\")\n    self.join_mode = False\n    self.add_inputs(self.joined_input)\n    self.joined_input = {}\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep.lowest_costs","title":"<code>lowest_costs(self, nresults=5)</code>","text":"<p>Returns a list of <code>(cost, routeno)</code> tuples with up to the <code>nresult</code> lowest costs and their corresponding route numbers.</p> <p>Parameters:</p> Name Type Description Default <code>nresults</code> <code>int</code> <p>Number of results to return.</p> <code>5</code> <p>Returns:</p> Type Description <code>'List[Tuple[float, int]]'</code> <p>A list of <code>(cost, routeno)</code> tuples.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def lowest_costs(self, nresults: int = 5) -&gt; \"List[Tuple[float, int]]\":\n    \"\"\"Returns a list of `(cost, routeno)` tuples with up to the `nresult`\n    lowest costs and their corresponding route numbers.\n\n    Arguments:\n        nresults: Number of results to return.\n\n    Returns:\n        A list of `(cost, routeno)` tuples.\n    \"\"\"\n    try:\n        import numpy as np  # pylint: disable=import-outside-toplevel\n    except ImportError as exc:\n        raise RuntimeError(\n            \"Mappings.lowest_costs() requires numpy.\\n\"\n            \"Install it with\\n\\n\"\n            \"    pip install numpy\"\n        ) from exc\n\n    result = []\n    n = 0  # total number of routes\n\n    # Loop over all toplevel routes leading into this mapping step\n    for inputs in self.input_routes:\n        # For each route, loop over all input arguments of this step\n        # The number of permutations we must consider is the product\n        # of the total number of routes to each input argument.\n        #\n        # We (potentially drastic) limit the possibilities by only\n        # considering the `nresults` routes with lowest costs into\n        # each argument.  This gives at maximum\n        #\n        #     nresults * number_of_input_arguments\n        #\n        # possibilities. We calculate the costs for all of them and\n        # store them in an array with two columns: `cost` and `routeno`.\n        # The `results` list is extended with the cost array\n        # for each toplevel route leading into this step.\n        base = np.rec.fromrecords(\n            [(0.0, 0)], names=\"cost,routeno\", formats=\"f8,i8\"\n        )\n        m = 1\n        for input in inputs.values():\n            if isinstance(input, MappingStep):\n                nroutes = input.number_of_routes()\n                res = np.rec.fromrecords(\n                    sorted(\n                        input.lowest_costs(nresults=nresults),\n                        key=lambda x: x[1],\n                    ),\n                    # [\n                    #     row\n                    #     for row in sorted(\n                    #         input.lowest_costs(nresults=nresults),\n                    #         key=lambda x: x[1],\n                    #     )\n                    # ],\n                    dtype=base.dtype,\n                )\n                res1 = res.repeat(len(base))\n                base = np.tile(base, len(res))\n                base.cost += res1.cost\n                base.routeno += res1.routeno * m\n                m *= nroutes\n            else:\n                base.cost += input.cost\n\n        # Reduce the length of base (makes probably only sense in\n        # the case self.cost is a callable, but it doesn't hurt...)\n        base.sort()\n        base = base[:nresults]\n        base.routeno += n\n        n += m\n\n        # Add the cost for this step to `res`.  If `self.cost` is\n        # a callable, we call it with the input for each routeno\n        # as arguments.  Otherwise `self.cost` is the cost of this\n        # mapping step.\n        if callable(self.cost):\n            for i, rno in enumerate(base.routeno):\n                inputs, _ = self.get_inputs(rno)\n                input_iris = [\n                    input.output_iri for input in inputs.values()\n                ]\n                owncost = self.cost(\n                    self.triplestore, input_iris, self.output_iri\n                )\n                base.cost[i] += owncost\n        else:\n            owncost = self.cost\n            base.cost += owncost\n\n        result.extend(base.tolist())\n\n    # Finally sort the results according to cost and return the\n    # `nresults` rows with lowest cost.\n    return sorted(result)[:nresults]\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep.number_of_routes","title":"<code>number_of_routes(self)</code>","text":"<p>Total number of routes to this mapping step.</p> <p>Returns:</p> Type Description <code>int</code> <p>Total number of routes to this mapping step.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def number_of_routes(self) -&gt; int:\n    \"\"\"Total number of routes to this mapping step.\n\n    Returns:\n        Total number of routes to this mapping step.\n    \"\"\"\n    n = 0\n    for inputs in self.input_routes:\n        n += get_nroutes(inputs)\n    return n\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep.show","title":"<code>show(self, routeno=None, name=None, indent=0)</code>","text":"<p>Returns a string representation of the mapping routes to this step.</p> <p>Parameters:</p> Name Type Description Default <code>routeno</code> <code>'Optional[int]'</code> <p>show given route.  The default is to show all routes.</p> <code>None</code> <code>name</code> <code>'Optional[str]'</code> <p>Name of the last mapping step (mainly for internal use).</p> <code>None</code> <code>indent</code> <code>int</code> <p>How of blanks to prepend each line with (mainly for internal use).</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the mapping routes.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def show(\n    self,\n    routeno: \"Optional[int]\" = None,\n    name: \"Optional[str]\" = None,\n    indent: int = 0,\n) -&gt; str:\n    \"\"\"Returns a string representation of the mapping routes to this step.\n\n    Arguments:\n        routeno: show given route.  The default is to show all routes.\n        name: Name of the last mapping step (mainly for internal use).\n        indent: How of blanks to prepend each line with (mainly for\n            internal use).\n\n    Returns:\n        String representation of the mapping routes.\n    \"\"\"\n    strings = []\n    ind = \" \" * indent\n    strings.append(ind + f'{name if name else \"Step\"}:')\n    strings.append(\n        ind + f\"  steptype: \"\n        f\"{self.steptype.name if self.steptype else None}\"\n    )\n    strings.append(ind + f\"  output_iri: {self.output_iri}\")\n    strings.append(ind + f\"  output_unit: {self.output_unit}\")\n    strings.append(ind + f\"  cost: {self.cost}\")\n    if routeno is None:\n        strings.append(ind + \"  routes:\")\n        for inputs in self.input_routes:\n            t = \"\\n\".join(\n                [\n                    input_.show(name=name_, indent=indent + 6)\n                    for name_, input_ in inputs.items()\n                ]\n            )\n            strings.append(ind + \"    - \" + t[indent + 6 :])\n    else:\n        strings.append(ind + \"  inputs:\")\n        inputs, idx = self.get_inputs(routeno)\n        t = \"\\n\".join(\n            [\n                input_.show(routeno=idx, name=name_, indent=indent + 6)\n                for name_, input_ in inputs.items()\n            ]\n        )\n        strings.append(ind + \"    - \" + t[indent + 6 :])\n    return \"\\n\".join(strings)\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep.visualise","title":"<code>visualise(self, routeno, output=None, format='png', dot='dot')</code>","text":"<p>Greate a Graphviz visualisation of a given mapping route.</p> <p>Parameters:</p> Name Type Description Default <code>routeno</code> <code>int</code> <p>Number of mapping route to visualise.</p> required <code>output</code> <code>'Optional[str]'</code> <p>If given, write the graph to this file.</p> <code>None</code> <code>format</code> <code>'Optional[str]'</code> <p>File format to use with <code>output</code>.</p> <code>'png'</code> <code>dot</code> <code>str</code> <p>Path to Graphviz dot executable.</p> <code>'dot'</code> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the graph in dot format.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def visualise(\n    self,\n    routeno: int,\n    output: \"Optional[str]\" = None,\n    format: \"Optional[str]\" = \"png\",\n    dot: str = \"dot\",\n) -&gt; str:\n    \"\"\"Greate a Graphviz visualisation of a given mapping route.\n\n    Arguments:\n        routeno: Number of mapping route to visualise.\n        output: If given, write the graph to this file.\n        format: File format to use with `output`.\n        dot: Path to Graphviz dot executable.\n\n    Returns:\n        String representation of the graph in dot format.\n    \"\"\"\n    strings = []\n    strings.append(\"digraph G {\")\n    strings.append(self._visualise(routeno, \"\", StepType.UNSPECIFIED))\n    strings.append(\"}\")\n    graph = \"\\n\".join(strings) + \"\\n\"\n    if output:\n        subprocess.run(\n            args=[dot, f\"-T{format}\", \"-o\", output],\n            shell=False,  # nosec: B603\n            check=True,\n            input=graph.encode(),\n        )\n    return graph\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MissingRelationError","title":"<code> MissingRelationError            (MappingError)         </code>","text":"<p>There are missing relations in RDF triples.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>class MissingRelationError(MappingError):\n    \"\"\"There are missing relations in RDF triples.\"\"\"\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.StepType","title":"<code> StepType            (Enum)         </code>","text":"<p>Type of mapping step when going from the output to the inputs.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>class StepType(Enum):\n    \"\"\"Type of mapping step when going from the output to the inputs.\"\"\"\n\n    UNSPECIFIED = 0\n    MAPSTO = 1\n    INV_MAPSTO = -1\n    INSTANCEOF = 2\n    INV_INSTANCEOF = -2\n    SUBCLASSOF = 3\n    INV_SUBCLASSOF = -3\n    FUNCTION = 4\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.UnknownUnitError","title":"<code> UnknownUnitError            (MappingError)         </code>","text":"<p>A unit does not exists in the pint unit registry.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>class UnknownUnitError(MappingError):\n    \"\"\"A unit does not exists in the pint unit registry.\"\"\"\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.Value","title":"<code> Value        </code>","text":"<p>Represents the value of an instance property.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>'Any'</code> <p>Property value.</p> <code>None</code> <code>unit</code> <code>'Optional[str]'</code> <p>Property unit.</p> <code>None</code> <code>iri</code> <code>'Optional[str]'</code> <p>IRI of ontological concept that this value is an instance of.</p> <code>None</code> <code>property_iri</code> <code>'Optional[str]'</code> <p>IRI of datamodel property that this value is an instance of.</p> <code>None</code> <code>cost</code> <code>'Union[float, Callable]'</code> <p>Cost of accessing this value.</p> <code>0.0</code> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>class Value:\n    \"\"\"Represents the value of an instance property.\n\n    Arguments:\n        value: Property value.\n        unit: Property unit.\n        iri: IRI of ontological concept that this value is an instance of.\n        property_iri: IRI of datamodel property that this value is an\n            instance of.\n        cost: Cost of accessing this value.\n    \"\"\"\n\n    # pylint: disable=too-few-public-methods\n\n    def __init__(\n        self,\n        value: \"Any\" = None,\n        unit: \"Optional[str]\" = None,\n        iri: \"Optional[str]\" = None,\n        property_iri: \"Optional[str]\" = None,\n        cost: \"Union[float, Callable]\" = 0.0,\n    ):\n        self._value = value\n        self.unit = unit\n        if iri:\n            self.output_iri = iri\n        elif hasattr(value, __name__):\n            self.output_iri = value.__name__\n        else:\n            self.output_iri = f\"_:value_{id(value)}\"\n        self.property_iri = property_iri\n        self.cost = cost\n\n    value = property(\n        lambda self: self._value() if callable(self._value) else self._value,\n        doc=\"Value of property.\",\n    )\n\n    def __repr__(self):\n        args = []\n        if self.unit:\n            args.append(f\", unit={self.unit}\")\n        if self.output_iri:\n            args.append(f\", iri={self.output_iri}\")\n        if self.property_iri:\n            args.append(f\", property_iri={self.property_iri}\")\n        if self.cost:\n            args.append(f\", cost={self.cost}\")\n        return f\"Value({self._value!r}{''.join(args)})\"\n\n    def get_value(self, unit=None, magnitude=False, quantity=None) -&gt; \"Any\":\n        \"\"\"Returns the evaluated value of given input route number.\n\n        Arguments:\n            unit: return the result in the given unit.\n                Implies `magnitude=True`.\n            magnitude: Whether to only return the magnitude of the evaluated\n                value (with no unit).\n            quantity: Quantity class to use for evaluation.  Defaults to pint.\n\n        Returns:\n            Value.\n        \"\"\"\n        if quantity is None:\n            quantity = Quantity\n        value = self._value() if callable(self._value) else self._value\n        if not isinstance(value, Quantity) and not self.unit:\n            return value\n        q = quantity(value, self.unit)\n        if unit:\n            return q.m_as(unit)\n        if magnitude:\n            return q.m\n        return q\n\n    def show(\n        self,\n        routeno: \"Optional[int]\" = None,\n        name: \"Optional[str]\" = None,\n        indent: int = 0,\n    ) -&gt; str:\n        # pylint: disable=unused-argument\n        \"\"\"Returns a string representation of the Value.\n\n        Arguments:\n            routeno: Unused.  The argument exists for consistency with\n                the corresponding method in Step.\n            name: Name of value.\n            indent: Indentation level.\n\n        Returns:\n            String representation of the value.\n        \"\"\"\n        strings = []\n        ind = \" \" * indent\n        strings.append(ind + f'{name if name else \"Value\"}:')\n        strings.append(ind + f\"  iri: {self.output_iri}\")\n        strings.append(ind + f\"  property_iri: {self.property_iri}\")\n        strings.append(ind + f\"  unit: {self.unit}\")\n        strings.append(ind + f\"  cost: {self.cost}\")\n        strings.append(ind + f\"  value: {self.value}\")\n        return \"\\n\".join(strings)\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.Value.value","title":"<code>value</code>  <code>property</code> <code>readonly</code>","text":"<p>Value of property.</p>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.Value.get_value","title":"<code>get_value(self, unit=None, magnitude=False, quantity=None)</code>","text":"<p>Returns the evaluated value of given input route number.</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <p>return the result in the given unit. Implies <code>magnitude=True</code>.</p> <code>None</code> <code>magnitude</code> <p>Whether to only return the magnitude of the evaluated value (with no unit).</p> <code>False</code> <code>quantity</code> <p>Quantity class to use for evaluation.  Defaults to pint.</p> <code>None</code> <p>Returns:</p> Type Description <code>'Any'</code> <p>Value.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def get_value(self, unit=None, magnitude=False, quantity=None) -&gt; \"Any\":\n    \"\"\"Returns the evaluated value of given input route number.\n\n    Arguments:\n        unit: return the result in the given unit.\n            Implies `magnitude=True`.\n        magnitude: Whether to only return the magnitude of the evaluated\n            value (with no unit).\n        quantity: Quantity class to use for evaluation.  Defaults to pint.\n\n    Returns:\n        Value.\n    \"\"\"\n    if quantity is None:\n        quantity = Quantity\n    value = self._value() if callable(self._value) else self._value\n    if not isinstance(value, Quantity) and not self.unit:\n        return value\n    q = quantity(value, self.unit)\n    if unit:\n        return q.m_as(unit)\n    if magnitude:\n        return q.m\n    return q\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.Value.show","title":"<code>show(self, routeno=None, name=None, indent=0)</code>","text":"<p>Returns a string representation of the Value.</p> <p>Parameters:</p> Name Type Description Default <code>routeno</code> <code>'Optional[int]'</code> <p>Unused.  The argument exists for consistency with the corresponding method in Step.</p> <code>None</code> <code>name</code> <code>'Optional[str]'</code> <p>Name of value.</p> <code>None</code> <code>indent</code> <code>int</code> <p>Indentation level.</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the value.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def show(\n    self,\n    routeno: \"Optional[int]\" = None,\n    name: \"Optional[str]\" = None,\n    indent: int = 0,\n) -&gt; str:\n    # pylint: disable=unused-argument\n    \"\"\"Returns a string representation of the Value.\n\n    Arguments:\n        routeno: Unused.  The argument exists for consistency with\n            the corresponding method in Step.\n        name: Name of value.\n        indent: Indentation level.\n\n    Returns:\n        String representation of the value.\n    \"\"\"\n    strings = []\n    ind = \" \" * indent\n    strings.append(ind + f'{name if name else \"Value\"}:')\n    strings.append(ind + f\"  iri: {self.output_iri}\")\n    strings.append(ind + f\"  property_iri: {self.property_iri}\")\n    strings.append(ind + f\"  unit: {self.unit}\")\n    strings.append(ind + f\"  cost: {self.cost}\")\n    strings.append(ind + f\"  value: {self.value}\")\n    return \"\\n\".join(strings)\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.emmo_mapper","title":"<code>emmo_mapper(triplestore)</code>","text":"<p>Finds all function definitions in <code>triplestore</code> based on EMMO.</p> <p>Return a dict mapping output IRIs to a list of</p> <pre><code>(function_iri, [input_iris, ...])\n</code></pre> <p>tuples.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def emmo_mapper(triplestore: \"Triplestore\") -&gt; \"Dict[str, list]\":\n    \"\"\"Finds all function definitions in `triplestore` based on EMMO.\n\n    Return a dict mapping output IRIs to a list of\n\n        (function_iri, [input_iris, ...])\n\n    tuples.\n    \"\"\"\n    Task = EMMO.EMMO_4299e344_a321_4ef2_a744_bacfcce80afc\n    hasInput = EMMO.EMMO_36e69413_8c59_4799_946c_10b05d266e22\n    hasOutput = EMMO.EMMO_c4bace1d_4db0_4cd3_87e9_18122bae2840\n\n    d = defaultdict(list)\n    for task in triplestore.subjects(RDF.type, Task):\n        inputs = list(triplestore.objects(task, hasInput))\n        for output in triplestore.objects(task, hasOutput):\n            d[output].append((task, inputs))\n\n    return d\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.fno_mapper","title":"<code>fno_mapper(triplestore)</code>","text":"<p>Finds all function definitions in <code>triplestore</code> based on the function ontololy (FNO).</p> <p>Parameters:</p> Name Type Description Default <code>triplestore</code> <code>'Triplestore'</code> <p>The triplestore to investigate.</p> required <p>Returns:</p> Type Description <code>'Dict[str, list]'</code> <p>A mapping of output IRIs to a list of</p> <pre><code>(function_iri, [input_iris, ...])\n</code></pre> <p>tuples.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def fno_mapper(triplestore: \"Triplestore\") -&gt; \"Dict[str, list]\":\n    \"\"\"Finds all function definitions in `triplestore` based on the function\n    ontololy (FNO).\n\n    Arguments:\n        triplestore: The triplestore to investigate.\n\n    Returns:\n        A mapping of output IRIs to a list of\n\n            (function_iri, [input_iris, ...])\n\n        tuples.\n    \"\"\"\n    # pylint: disable=too-many-branches\n\n    # Temporary dicts for fast lookup\n    Dfirst = dict(triplestore.subject_objects(RDF.first))\n    Drest = dict(triplestore.subject_objects(RDF.rest))\n    Dexpects = defaultdict(list)\n    Dreturns = defaultdict(list)\n    for s, o in triplestore.subject_objects(FNO.expects):\n        Dexpects[s].append(o)\n    for s, o in triplestore.subject_objects(FNO.returns):\n        Dreturns[s].append(o)\n\n    d = defaultdict(list)\n    for func, lst in Dreturns.items():\n        input_iris = []\n        for exp in Dexpects.get(func, ()):\n            if exp in Dfirst:\n                while exp in Dfirst:\n                    input_iris.append(Dfirst[exp])\n                    if exp not in Drest:\n                        break\n                    exp = Drest[exp]\n            else:\n                # Support also misuse of FNO, where fno:expects refers\n                # directly to input individuals\n                input_iris.append(exp)\n\n        for ret in lst:\n            if ret in Dfirst:\n                while ret in Dfirst:\n                    d[Dfirst[ret]].append((func, input_iris))\n                    if ret not in Drest:\n                        break\n                    ret = Drest[ret]\n            else:\n                # Support also misuse of FNO, where fno:returns refers\n                # directly to the returned individual\n                d[ret].append((func, input_iris))\n\n    return d\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.get_nroutes","title":"<code>get_nroutes(inputs)</code>","text":"<p>Help function returning the number of routes for an input dict.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>'Inputs'</code> <p>Input dictionary.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of routes in the <code>inputs</code> input dictionary.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def get_nroutes(inputs: \"Inputs\") -&gt; int:\n    \"\"\"Help function returning the number of routes for an input dict.\n\n    Arguments:\n        inputs: Input dictionary.\n\n    Returns:\n        Number of routes in the `inputs` input dictionary.\n    \"\"\"\n    nroutes = 1\n    for input in inputs.values():\n        if isinstance(input, MappingStep):\n            nroutes *= input.number_of_routes()\n    return nroutes\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.get_values","title":"<code>get_values(inputs, routeno, quantity=&lt;class 'pint.registry.Quantity'&gt;, magnitudes=False)</code>","text":"<p>Help function returning a dict mapping the input names to actual value of expected input unit.</p> <p>There exists <code>get_nroutes(inputs)</code> routes to populate <code>inputs</code>. <code>routeno</code> is the index of the specific route we will use to obtain the values.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>'dict[str, Any]'</code> <p>Input dictionary.</p> required <code>routeno</code> <code>int</code> <p>Route number index.</p> required <code>quantity</code> <code>'Type[Quantity]'</code> <p>A unit quantity class.</p> <code>&lt;class 'pint.registry.Quantity'&gt;</code> <code>magnitudes</code> <code>bool</code> <p>Whether to only return the magnitude of the evaluated value (with no unit).</p> <code>False</code> <p>Returns:</p> Type Description <code>'dict[str, Any]'</code> <p>A mapping between input names and values of expected input unit.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def get_values(\n    inputs: \"dict[str, Any]\",\n    routeno: int,\n    quantity: \"Type[Quantity]\" = Quantity,\n    magnitudes: bool = False,\n) -&gt; \"dict[str, Any]\":\n    \"\"\"Help function returning a dict mapping the input names to actual value\n    of expected input unit.\n\n    There exists `get_nroutes(inputs)` routes to populate `inputs`.\n    `routeno` is the index of the specific route we will use to obtain the\n    values.\n\n    Arguments:\n        inputs: Input dictionary.\n        routeno: Route number index.\n        quantity: A unit quantity class.\n        magnitudes: Whether to only return the magnitude of the evaluated\n            value (with no unit).\n\n    Returns:\n        A mapping between input names and values of expected input unit.\n    \"\"\"\n    values = {}\n\n    for k, v in inputs.items():\n        if isinstance(v, MappingStep):\n            value = v.eval(routeno=routeno, quantity=quantity)\n            values[k] = (\n                value.to(v.output_unit)\n                if v.output_unit and isinstance(v, quantity)\n                else value\n            )\n        elif isinstance(v, Value):\n            values[k] = v.value if not v.unit else quantity(v.value, v.unit)\n        else:\n            raise TypeError(\n                \"Expected values in inputs to be either `MappingStep` or \"\n                \"`Value` objects.\"\n            )\n\n        if magnitudes:\n            values = {\n                k: v.m if isinstance(v, quantity) else v\n                for k, v in values.items()\n            }\n\n    return values\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.mapping_routes","title":"<code>mapping_routes(target, sources, triplestore, function_repo=None, function_mappers=(&lt;function emmo_mapper at 0x7f0104fff790&gt;, &lt;function fno_mapper at 0x7f0104fff820&gt;), default_costs=(('function', 10.0), ('mapsTo', 2.0), ('instanceOf', 1.0), ('subClassOf', 1.0), ('value', 0.0)), value_class=None, mappingstep_class=None, mapsTo='https://w3id.org/emmo/domain/mappings#mapsTo', instanceOf='https://w3id.org/emmo/domain/datamodel#instanceOf', subClassOf='http://www.w3.org/2000/01/rdf-schema#subClassOf', label='http://www.w3.org/2000/01/rdf-schema#label', hasUnit='https://w3id.org/emmo/domain/datamodel#hasUnit', hasCost='https://w3id.org/emmo/domain/datamodel#hasCost', hasAccessFunction='https://w3id.org/emmo#hasAccessFunction', hasDataValue='http://www.w3.org/1999/02/22-rdf-syntax-ns#value')</code>","text":"<p>Find routes of mappings from any source in <code>sources</code> to <code>target</code>.</p> <p>This implementation supports functions (using FnO) and subclass relations.  It also correctly handles transitivity of <code>mapsTo</code> and <code>subClassOf</code> relations.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>IRI of the target in <code>triplestore</code>.</p> required <code>sources</code> <code>'Union[Dict[str, Union[Value, None]], Sequence[str]]'</code> <p>Dict mapping source IRIs to source values or a sequence of source IRIs (with no explicit values).</p> required <code>triplestore</code> <code>'Triplestore'</code> <p>Triplestore instance for the knowledge graph to traverse.</p> required <p>Additional arguments for fine-grained tuning:     !!! function_repo \"Dict mapping function IRIs to corresponding Python\"         function.  Default is to use <code>triplestore.function_repo</code>.     !!! function_mappers \"Name of mapping standard: \"emmo\" or \"fno\".\"         Alternatively, a sequence of mapping functions that takes         <code>triplestore</code> as argument and return a dict mapping output IRIs         to a list of <code>(function_iri, [input_iris, ...])</code> tuples.     !!! default_costs \"A dict providing default costs of different types\"         of mapping steps (\"function\", \"mapsTo\", \"instanceOf\",         \"subclassOf\", and \"value\").  These costs can be overridden with         'hasCost' relations in the ontology.     !!! value_class \"Optional <code>Value</code> subclass to use instead of <code>Value</code> when\"         creating the returned mapping route.     !!! mappingstep_class \"Optional <code>MappingStep</code> subclass to use instead of\"         <code>MappingStep</code> when creating the returned mapping route.     mapsTo: IRI of 'mapsTo' in <code>triplestore</code>.     instanceOf: IRI of 'instanceOf' in <code>triplestore</code>.     !!! subclassof \"IRI of 'subClassOf' in <code>triples</code>.  Set it to None if\"         subclasses should not be considered.     !!! label \"IRI of 'label' in <code>triplestore</code>.  Used for naming function\"         input parameters.  The default is to use rdfs:label.     !!! hasunit \"IRI of 'hasUnit' in <code>triplestore</code>.  Can be used to explicit\"         specify the unit of a quantity.     !!! hascost \"IRI of 'hasCost' in <code>triplestore</code>.  Used for associating a\"         user-defined cost or cost function with instantiation of a         property.     !!! hasaccessfunction \"IRI of 'hasAccessFunction'.  Used to associate a\"         data source to a function that retrieves the data.     !!! hasdatavalue \"IRI of 'hasDataValue'.  Used to associate a data source\"         with its literal value.</p> <p>Returns:</p> Type Description <code>Input</code> <p>A MappingStep instance.  This is a root of a nested tree of MappingStep instances providing an (efficient) internal description of all possible mapping routes from <code>sources</code> to <code>target</code>.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def mapping_routes(\n    target: str,\n    sources: \"Union[Dict[str, Union[Value, None]], Sequence[str]]\",\n    triplestore: \"Triplestore\",\n    function_repo: \"Optional[dict]\" = None,\n    function_mappers: \"Union[str, Sequence[Callable]]\" = (\n        emmo_mapper,\n        fno_mapper,\n    ),\n    default_costs: \"Tuple\" = (\n        (\"function\", 10.0),\n        (\"mapsTo\", 2.0),\n        (\"instanceOf\", 1.0),\n        (\"subClassOf\", 1.0),\n        (\"value\", 0.0),\n    ),\n    value_class: \"Optional[Type[Value]]\" = None,\n    mappingstep_class: \"Optional[Type[MappingStep]]\" = None,\n    mapsTo: str = MAP.mapsTo,\n    instanceOf: str = DM.instanceOf,\n    subClassOf: str = RDFS.subClassOf,\n    # description: str = DCTERMS.description,\n    label: str = RDFS.label,\n    hasUnit: str = DM.hasUnit,\n    hasCost: str = DM.hasCost,  # TODO - add hasCost to the DM ontology\n    hasAccessFunction: str = hasAccessFunction,  # pylint: disable=redefined-outer-name\n    hasDataValue: str = hasDataValue,  # pylint: disable=redefined-outer-name\n) -&gt; Input:\n    \"\"\"Find routes of mappings from any source in `sources` to `target`.\n\n    This implementation supports functions (using FnO) and subclass\n    relations.  It also correctly handles transitivity of `mapsTo` and\n    `subClassOf` relations.\n\n    Arguments:\n        target: IRI of the target in `triplestore`.\n        sources: Dict mapping source IRIs to source values or a sequence\n            of source IRIs (with no explicit values).\n        triplestore: Triplestore instance for the knowledge graph to traverse.\n\n    Additional arguments for fine-grained tuning:\n        function_repo: Dict mapping function IRIs to corresponding Python\n            function.  Default is to use `triplestore.function_repo`.\n        function_mappers: Name of mapping standard: \"emmo\" or \"fno\".\n            Alternatively, a sequence of mapping functions that takes\n            `triplestore` as argument and return a dict mapping output IRIs\n            to a list of `(function_iri, [input_iris, ...])` tuples.\n        default_costs: A dict providing default costs of different types\n            of mapping steps (\"function\", \"mapsTo\", \"instanceOf\",\n            \"subclassOf\", and \"value\").  These costs can be overridden with\n            'hasCost' relations in the ontology.\n        value_class: Optional `Value` subclass to use instead of `Value` when\n            creating the returned mapping route.\n        mappingstep_class: Optional `MappingStep` subclass to use instead of\n            `MappingStep` when creating the returned mapping route.\n        mapsTo: IRI of 'mapsTo' in `triplestore`.\n        instanceOf: IRI of 'instanceOf' in `triplestore`.\n        subClassOf: IRI of 'subClassOf' in `triples`.  Set it to None if\n            subclasses should not be considered.\n        label: IRI of 'label' in `triplestore`.  Used for naming function\n            input parameters.  The default is to use rdfs:label.\n        hasUnit: IRI of 'hasUnit' in `triplestore`.  Can be used to explicit\n            specify the unit of a quantity.\n        hasCost: IRI of 'hasCost' in `triplestore`.  Used for associating a\n            user-defined cost or cost function with instantiation of a\n            property.\n        hasAccessFunction: IRI of 'hasAccessFunction'.  Used to associate a\n            data source to a function that retrieves the data.\n        hasDataValue: IRI of 'hasDataValue'.  Used to associate a data source\n            with its literal value.\n\n    Returns:\n        A MappingStep instance.  This is a root of a nested tree of\n        MappingStep instances providing an (efficient) internal description\n        of all possible mapping routes from `sources` to `target`.\n    \"\"\"\n    # pylint: disable=too-many-arguments,too-many-locals,too-many-statements\n\n    if target in sources:\n        return Value(iri=target)\n\n    if isinstance(sources, Sequence):\n        sources = {iri: None for iri in sources}\n\n    if function_repo is None:\n        function_repo = triplestore.function_repo\n\n    if isinstance(function_mappers, str):\n        fmd = {\"emmo\": emmo_mapper, \"fno\": fno_mapper}\n        function_mappers = [fmd[name] for name in function_mappers.split(\",\")]\n\n    default_costs = dict(default_costs)\n\n    if value_class is None:\n        value_class = Value\n\n    if mappingstep_class is None:\n        mappingstep_class = MappingStep\n\n    # Create lookup tables for fast access to triplestore content\n    soMaps = defaultdict(list)  # (s, mapsTo, o)     ==&gt; soMaps[s]  -&gt; [o, ..]\n    osMaps = defaultdict(\n        list\n    )  # (o, inv(mapsTo), s)     ==&gt; osMaps[o]  -&gt; [s, ..]\n    osSubcl = defaultdict(\n        list\n    )  # (o, inv(subClassOf), s) ==&gt; osSubcl[o] -&gt; [s, ..]\n    soInst = {}  # (s, instanceOf, o) ==&gt; soInst[s]  -&gt; o\n    osInst = defaultdict(\n        list\n    )  # (o, inv(instanceOf), s) ==&gt; osInst[o]  -&gt; [s, ..]\n    for s, o in triplestore.subject_objects(mapsTo):\n        soMaps[s].append(o)\n        osMaps[o].append(s)\n    for s, o in triplestore.subject_objects(subClassOf):\n        osSubcl[o].append(s)\n    for s, o in triplestore.subject_objects(instanceOf):\n        if s in soInst:\n            raise InconsistentTriplesError(\n                f\"The same individual can only relate to one datamodel \"\n                f\"property via {instanceOf} relations.\"\n            )\n        soInst[s] = o\n        osInst[o].append(s)\n    soName = dict(triplestore.subject_objects(label))\n    soUnit = dict(triplestore.subject_objects(hasUnit))\n    soCost = dict(triplestore.subject_objects(hasCost))\n    soAFun = dict(triplestore.subject_objects(hasAccessFunction))\n    soDVal = dict(triplestore.subject_objects(hasDataValue))\n\n    def getfunc(func_iri, default=None):\n        \"\"\"Returns callable function corresponding to `func_iri`.\n        Raises CannotGetFunctionError if func_iri cannot be found.\"\"\"\n        if func_iri is None:\n            return None\n        if func_iri in function_repo and function_repo[func_iri]:\n            return function_repo[func_iri]\n        try:\n            return (\n                triplestore._get_function(  # pylint: disable=protected-access\n                    func_iri\n                )\n            )\n        except CannotGetFunctionError:\n            return default\n\n    def getcost(target, stepname):\n        \"\"\"Returns the cost assigned to IRI `target` for a mapping step\n        of type `stepname`.\"\"\"\n        cost = soCost.get(target, default_costs[stepname])\n        if cost is None or callable(cost) or isinstance(cost, float):\n            return cost\n        return getfunc(cost, float(parse_literal(cost)))\n\n    def walk(target, visited, step):\n        \"\"\"Walk backward in rdf graph from `node` to sources.\"\"\"\n        if target in visited:\n            return\n        visited.add(target)\n\n        def addnode(node, steptype, stepname):\n            if node in visited:\n                return\n            step.steptype = steptype\n            step.cost = getcost(target, stepname)\n            if node in soAFun:\n                value = value_class(\n                    value=getfunc(soAFun[node]),\n                    unit=soUnit.get(node),\n                    iri=node,\n                    property_iri=soInst.get(node),\n                    cost=getcost(node, \"value\"),\n                )\n                step.add_input(value, name=soName.get(node))\n            elif node in soDVal:\n                literal = parse_literal(soDVal[node])\n                value = value_class(\n                    value=literal.to_python(),\n                    unit=soUnit.get(node),\n                    iri=node,\n                    property_iri=soInst.get(node),\n                    cost=getcost(node, \"value\"),\n                )\n                step.add_input(value, name=soName.get(node))\n            elif node in sources:\n                value = value_class(\n                    value=sources[node],\n                    unit=soUnit.get(node),\n                    iri=node,\n                    property_iri=soInst.get(node),\n                    cost=getcost(node, \"value\"),\n                )\n                step.add_input(value, name=soName.get(node))\n            else:\n                prevstep = mappingstep_class(\n                    output_iri=node,\n                    output_unit=soUnit.get(node),\n                    triplestore=triplestore,\n                )\n                step.add_input(prevstep, name=soName.get(node))\n                walk(node, visited, prevstep)\n\n        for node in osInst[target]:\n            addnode(node, StepType.INV_INSTANCEOF, \"instanceOf\")\n\n        for node in soMaps[target]:\n            addnode(node, StepType.MAPSTO, \"mapsTo\")\n\n        for node in osMaps[target]:\n            addnode(node, StepType.INV_MAPSTO, \"mapsTo\")\n\n        for node in osSubcl[target]:\n            addnode(node, StepType.INV_SUBCLASSOF, \"subClassOf\")\n\n        for fmap in function_mappers:\n            for func_iri, input_iris in fmap(triplestore)[target]:\n                step.steptype = StepType.FUNCTION\n                step.cost = getcost(func_iri, \"function\")\n                step.function = getfunc(func_iri)\n                step.join_mode = True\n                for input_iri in input_iris:\n                    step0 = mappingstep_class(\n                        output_iri=input_iri,\n                        output_unit=soUnit.get(input_iri),\n                        triplestore=triplestore,\n                    )\n                    step.add_input(step0, name=soName.get(input_iri))\n                    walk(input_iri, visited, step0)\n                step.join_input()\n\n    visited = set()\n    step = mappingstep_class(\n        output_iri=target,\n        output_unit=soUnit.get(target),\n        triplestore=triplestore,\n    )\n    if target in soInst:\n        # It is only initially we want to follow instanceOf in forward\n        # direction.  Later on we will only follow mapsTo and instanceOf in\n        # backward direction.\n        visited.add(target)  # do we really wan't this?  Yes, I think so...\n        source = soInst[target]\n        step.steptype = StepType.INSTANCEOF\n        step.cost = getcost(source, \"instanceOf\")\n        step0 = mappingstep_class(\n            output_iri=source,\n            output_unit=soUnit.get(source),\n            triplestore=triplestore,\n        )\n        step.add_input(step0, name=soName.get(target))\n        step = step0\n        target = source\n\n    if target not in soMaps:\n        raise MissingRelationError(f'Missing \"mapsTo\" relation on: {target}')\n    walk(target, visited, step)\n\n    return step\n</code></pre>"}]}