{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tripper","text":"<p>Triplestore wrapper for Python providing a simple and consistent interface to a range of triplestore backends - the best ride when handling any triplestore.</p> <p> </p>"},{"location":"#basic-concepts","title":"Basic concepts","text":"<p>Tripper provides a simple and consistent interface to a range of triplestore backends. It strives for simplicity and is modelled after rdflib (with a few simplifications).</p> <p>In Tripper:</p> <ul> <li> <p>All IRIs are represented by Python strings.   Example: <code>\"http://emmo.info/emmo#Atom\"</code></p> </li> <li> <p>Blank nodes are strings starting with \"_:\".   Example: <code>\"_:bnode1\"</code></p> </li> <li> <p>Literals are constructed with <code>tripper.Literal</code>.   Example: <code>tripper.Literal(3.14, datatype=XSD.float)</code></p> </li> </ul> <p>To make it easy to work with IRIs, provide Tripper a set of pre-defined namespaces, like <code>XSD.float</code>. New namespaces can be defined with the <code>tripper.Namespace</code> class.</p> <p>A triplestore wrapper is created with the <code>tripper.Triplestore</code> class.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Getting started: See the tutorial</li> <li>Discovery of custom backends</li> <li>Reference manual</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Tripper has by itself no dependencies outside the standard library, but the triplestore backends may have specific dependencies.</p> <p>The package can be installed from PyPI using <code>pip</code>:</p> <pre><code>pip install tripper\n</code></pre>"},{"location":"#license-and-copyright","title":"License and copyright","text":"<p>All files in this repository are licensed under the MIT license. If not stated otherwise in the top of the files, they have copyright \u00a9 2022 SINTEF.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#unreleased-2023-03-25","title":"Unreleased (2023-03-25)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Add entrypoint system to link external backend implementation #63</li> </ul> <p>Closed issues:</p> <ul> <li>Transformations based on data sources #90</li> <li>Add workflow example  #79</li> </ul> <p>Merged pull requests:</p> <ul> <li>Added add_data(), get_value() and add_interpolation_source() methods to Triplestore #91 (jesper-friis)</li> <li>[Auto-generated] Update dependencies #88 (TEAM4-0)</li> <li>Added tests for Python 3.11 and 3.6 #84 (jesper-friis)</li> <li>Remove some deprecation warnings #83 (jesper-friis)</li> <li>Workflow example #81 (jesper-friis)</li> <li>Support external backends #80 (jesper-friis)</li> </ul>"},{"location":"CHANGELOG/#v023-2023-02-05","title":"v0.2.3 (2023-02-05)","text":"<p>Full Changelog</p> <p>Closed issues:</p> <ul> <li>Add a to_yaml() method to MappingStep #66</li> </ul> <p>Merged pull requests:</p> <ul> <li>Add official support for Python 3.11 #82 (jesper-friis)</li> <li>[Auto-generated] Update dependencies #78 (TEAM4-0)</li> <li>added PR template #77 (alfredoisg)</li> </ul>"},{"location":"CHANGELOG/#v022-2023-01-30","title":"v0.2.2 (2023-01-30)","text":"<p>Full Changelog</p> <p>Fixed bugs:</p> <ul> <li>pre-commit failing hook installation #75</li> <li>ontopy backend failing tests #7</li> </ul> <p>Closed issues:</p> <ul> <li>Describe functions with EMMO instead of FnO #65</li> </ul> <p>Merged pull requests:</p> <ul> <li>Using isort 5.12.0 for pre-commit #76 (CasperWA)</li> <li>Visualise #74 (jesper-friis)</li> <li>Generate mapping routes from subclasses of Value and MappingStep #73 (jesper-friis)</li> <li>Fix deprecated calls syntax to Triplestore.triples() #71 (jesper-friis)</li> <li>Made the value optional + added some cleanup #70 (jesper-friis)</li> <li>Add map() method to Triplestore #69 (jesper-friis)</li> <li>Proper cost function #68 (jesper-friis)</li> <li>Updated Triplestore.add_function() to also support EMMO. #67 (jesper-friis)</li> <li>Added mappings #62 (jesper-friis)</li> <li>[Auto-generated] Update dependencies #60 (TEAM4-0)</li> </ul>"},{"location":"CHANGELOG/#v021-2022-12-18","title":"v0.2.1 (2022-12-18)","text":"<p>Full Changelog</p> <p>Closed issues:</p> <ul> <li>Simplify use of the Triplestore triples() and remove() methods #50</li> </ul> <p>Merged pull requests:</p> <ul> <li>Commented out __hash__() and __eq__() methods from Literal. #55 (jesper-friis)</li> <li>Simplify use of the Triplestore triples() and remove() methods #51 (jesper-friis)</li> <li>Separated <code>base_iri</code> argument from <code>triplestore_url</code> in rdflib backend #49 (jesper-friis)</li> </ul>"},{"location":"CHANGELOG/#v020-2022-12-13","title":"v0.2.0 (2022-12-13)","text":"<p>Full Changelog</p> <p>Fixed bugs:</p> <ul> <li>Deploy docs failing due to wrong dependency installation #53</li> </ul> <p>Closed issues:</p> <ul> <li>Remove backend packages from requirements #48</li> <li>Fix utils.parse_object()  #45</li> </ul> <p>Merged pull requests:</p> <ul> <li>Update <code>docs</code> extra #54 (CasperWA)</li> <li>Remove backend packages from requirements #52 (jesper-friis)</li> <li>Fix utils.parse_object() #46 (jesper-friis)</li> </ul>"},{"location":"CHANGELOG/#v012-2022-12-11","title":"v0.1.2 (2022-12-11)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>The return value of <code>query()</code> depends on the query #42</li> <li>Add DLite collection backend #41</li> <li>Implement create_database() and remove_database() methods #34</li> <li>SPARQLWrapper backend #10</li> <li>Refactor triplestore.py (triplestore module API) #3</li> </ul> <p>Closed issues:</p> <ul> <li>Revert to using the proper general version for SINTEF/ci-cd #35</li> <li>Write in type annotations #33</li> <li>Improve README file #18</li> <li>Add support for simple persistent storage in the rdflib backend #14</li> </ul> <p>Merged pull requests:</p> <ul> <li>Added collection backend #44 (jesper-friis)</li> <li>Fix return types #43 (CasperWA)</li> <li>Updated import statements in the tutorial #40 (jesper-friis)</li> <li>Added create_database() and remove_database() methods. #39 (jesper-friis)</li> <li>Use the proper version of SINTEF/ci-cd #36 (CasperWA)</li> <li>bumped ci-cd version to remove --strict mkdocs command #32 (daniel-sintef)</li> <li>3 refactor triplestorepy triplestore module api #31 (daniel-sintef)</li> <li>[Auto-generated] Update dependencies #28 (TEAM4-0)</li> <li>3 refactor triplestore #27 (jesper-friis)</li> <li>Corrected copyright #21 (jesper-friis)</li> <li>Add a useful description to README file. #19 (jesper-friis)</li> <li>Added support for simple persistent storage in the rdflib backend #15 (jesper-friis)</li> <li>sparqlwrapper backend #11 (jesper-friis)</li> <li>Documented return value of the Triplestore.query() and added a test for it #9 (jesper-friis)</li> </ul>"},{"location":"CHANGELOG/#v011-2022-10-13","title":"v0.1.1 (2022-10-13)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Change package name to <code>tripper</code> on PyPI #13</li> <li>Clean up newly initialized Python API #1</li> </ul> <p>Fixed bugs:</p> <ul> <li>Enable proper release workflow #8</li> <li>Fix workflows so they succeed #2</li> </ul> <p>Merged pull requests:</p> <ul> <li>[Auto-generated] Update dependencies #17 (TEAM4-0)</li> <li>Use the package name <code>tripper</code> (not <code>tripperpy</code>) #16 (CasperWA)</li> <li>Clean up repository &amp; fix workflows #5 (CasperWA)</li> <li>Added version number in __init__ to enable local pip install #4 (quaat)</li> </ul> <p>* This Changelog was automatically generated by github_changelog_generator</p>"},{"location":"LICENSE/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2022 SINTEF</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"backend_discovery/","title":"Discovery of custom backends","text":"<p>A tripper backend is a normal importable Python module that defines the class <code>{Name}Strategy</code>, where <code>{Name}</code> is the name of the backend with the first letter capitalized (as it would be with the <code>str.title()</code> method). The methods they are supposed to define are documented in tripper/interface.py.</p> <p>Tripper support several use cases for discovery of custom backends.</p>"},{"location":"backend_discovery/#installed-backend-package","title":"Installed backend package","text":"<p>It is possible to create a pip installable Python package that provides new tripper backends that will be automatically discovered.</p> <p>The backend package should add the following to its <code>pyproject.toml</code> file:</p> <pre><code>[project.entry-points.\"tripper.backends\"]\nmybackend1 = \"subpackage.mybackend1\"\nmybackend2 = \"subpackage.mybackend2\"\n</code></pre> <p>When your package is installed, this would make <code>mybackend1</code> and <code>mybackend2</code> automatically discovarable by tripper, such that you can write</p> <pre><code>&gt;&gt;&gt; from tripper import Triplestore\n&gt;&gt;&gt; ts = Triplestore(backend=\"mybackend1\")\n</code></pre>"},{"location":"backend_discovery/#backend-module","title":"Backend module","text":"<p>If you have a tripper backend that is specific to your application, or that you for some other reason don't want or feel the need to publish as a separate Python package, you can keep the backend as a module within your application.</p> <p>In this case you have two options, either specify explicitly backend module when you instantiate your triplestore or append your package to the <code>tripper.backend_packages</code> module variable:</p>"},{"location":"backend_discovery/#instantiate-triplestore-with-explicit-module-path","title":"Instantiate triplestore with explicit module path","text":"<p>An explicit module path can either be absolute or relative as shown in the example below:</p> <pre><code># Absolute\n&gt;&gt;&gt; ts = Triplestore(backend=\"mypackage.backends.mybackend\")\n\n# Relative to the `package` argument\n&gt;&gt;&gt; ts = Triplestore(backend=\"backends.mybackend\", package=\"mypackage\")\n</code></pre> <p>A backend is considered to be specified explicitly if the <code>backend</code> argument contain a dot (.) or if the <code>package</code> argument is provided.</p>"},{"location":"backend_discovery/#append-to-tripperbackend_packages","title":"Append to <code>tripper.backend_packages</code>","text":"<p>Finally you can insert/append the sub-package with your backend to the <code>tripper.backend_packages</code> list module variable:</p> <pre><code>import tripper\ntripper.backend_packages.append(\"mypackage.backends\")\nts = Triplestore(backend=\"mybackend\")\n</code></pre>"},{"location":"backend_discovery/#search-order-for-backends","title":"Search order for backends","text":"<p>Tripper backends are looked up in the following order: 1. explicit specified backend modules 2. backend packages 3. checking <code>tripper.backend_packages</code></p> <p>By default the built-in backends are looked up as the first element in <code>tripper.backend_packages</code> (but it is possible for the insert a custom backend sub-package before it). This means that backend packages are looked up before the built-in backends. Hence it is possible for a backend package to overwrite or extend a built-in backend.</p>"},{"location":"planned-backends/","title":"Planned backends","text":"<p>In addition to the currently existing backends, the following additional backends may be supported in upcoming versions:</p> <ul> <li>Redland librdf</li> <li>Apache Jena Fuseki</li> <li>Allegrograph</li> <li>Wikidata</li> </ul>"},{"location":"tutorial/","title":"Tutorial","text":"<p>Create a triplestore instance using the <code>rdflib</code> backend:</p> <pre><code>from tripper import Triplestore\nts = Triplestore(backend=\"rdflib\")\n</code></pre> <p>The module already provides a set of pre-defined namespaces that simplifies writing IRIs. For example:</p> <pre><code>from tripper import RDFS, OWL\nRDFS.subClassOf\n# -&gt; 'http://www.w3.org/2000/01/rdf-schema#subClassOf'\n</code></pre> <p>New namespaces can be created using the Namespace class, but are usually added with the <code>bind()</code> method:</p> <pre><code>ONTO = ts.bind(\"onto\", \"http://example.com/onto#\")\nONTO.MyConcept\n# -&gt; 'http://example.com/onto#MyConcept'\n</code></pre> <p>Namespace also supports access by label and IRI checking. Both of these features requires loading an ontology. The following example shows how to create an EMMO namespace with IRI checking. The keyword argument <code>label_annotations=True</code> enables access by <code>skos:prefLabel</code>, <code>rdfs:label</code> or <code>skos:altLabel</code>. The <code>check=True</code> enables checking for existing IRIs. The <code>triplestore_url=...</code> is a resolvable URL that can be read by the 'rdflib' backend. It is needed, because the 'rdflib' backend is currently not able to load EMMO from the <code>http://emmo.info/emmo#</code> namespace.</p> <pre><code>EMMO = ts.bind(\n    \"emmo\", \"http://emmo.info/emmo#\",\n    label_annotations=True,\n    check=True,\n    triplestore_url=\"https://emmo-repo.github.io/versions/1.0.0-beta4/emmo-inferred.ttl\",\n)\nEMMO.Atom\n# -&gt; 'http://emmo.info/emmo#EMMO_eb77076b_a104_42ac_a065_798b2d2809ad'\nEMMO.invalid_name\n# -&gt; NoSuchIRIError: http://emmo.info/emmo#invalid_name\n</code></pre> <p>New triples can be added either with the <code>parse()</code> method (for backends that support it) or the <code>add()</code> and <code>add_triples()</code> methods:</p> <pre><code># en(msg) is a convenient function for adding english literals.\n# It is equivalent to ``tripper.Literal(msg, lang=\"en\")``.\nfrom tripper.utils import en\nts.parse(\"onto.ttl\", format=\"turtle\")\nts.add_triples([\n    (ONTO.MyConcept, RDFS.subClassOf, OWL.Thing),\n    (ONTO.MyConcept, RDFS.label, en(\"My briliant ontological concept.\")),\n])\n</code></pre> <p>For backends that support it the triplestore can be serialised using <code>serialize()</code>:</p> <pre><code>ts.serialize(\"onto2.ttl\")\n</code></pre> <p>A set of convenient functions exists for simple queries, including <code>triples()</code>, <code>subjects()</code>, <code>predicates()</code>, <code>objects()</code>, <code>subject_predicates()</code>, <code>subject_objects()</code>, <code>predicate_objects()</code> and <code>value()</code>. Except for <code>value()</code>, they return the result as generators. For example:</p> <pre><code>ts.objects(subject=ONTO.MyConcept, predicate=RDFS.subClassOf)\n# -&gt; &lt;generator object Triplestore.objects at 0x7fa502590200&gt;\nlist(ts.objects(subject=ONTO.MyConcept, predicate=RDFS.subClassOf))\n# -&gt; ['http://www.w3.org/2002/07/owl#Thing']\n</code></pre> <p>The <code>query()</code> and <code>update()</code> methods can be used to query and update the triplestore using SPARQL.</p> <p>Finally Triplestore has two specialised methods <code>add_mapsTo()</code> and <code>add_function()</code> that simplify working with mappings. <code>add_mapsTo()</code> is convinient for defining new mappings:</p> <pre><code>from tripper import Namespace\nMETA = Namespace(\"http://onto-ns.com/meta/0.1/MyEntity#\")\nts.add_mapsTo(ONTO.MyConcept, META.my_property)\n</code></pre> <p>It can also be used with DLite and SOFT7 data models. Here we repeat the above with DLite:</p> <pre><code>import dlite\nmeta = dlite.get_instance(\"http://onto-ns.com/meta/0.1/MyEntity\")\nts.add_mapsTo(ONTO.MyConcept, meta, \"my_property\")\n</code></pre> <p>The <code>add_function()</code> describes a function and adds mappings for its arguments and return value(s). Currently it only supports the Function Ontology (FnO).</p> <pre><code>def mean(x, y):\n\"\"\"Returns the mean value of `x` and `y`.\"\"\"\n    return (x + y)/2\n\nts.add_function(\n    mean,\n    expects=(ONTO.RightArmLength, ONTO.LeftArmLength),\n    returns=ONTO.AverageArmLength,\n)\n</code></pre>"},{"location":"api_reference/errors/","title":"errors","text":"<p>Exceptions for the triplestore package.</p>"},{"location":"api_reference/errors/#tripper.errors.NamespaceError","title":"<code> NamespaceError            (TriplestoreError)         </code>","text":"<p>Namespace error.</p> Source code in <code>tripper/errors.py</code> <pre><code>class NamespaceError(TriplestoreError):\n\"\"\"Namespace error.\"\"\"\n</code></pre>"},{"location":"api_reference/errors/#tripper.errors.NoSuchIRIError","title":"<code> NoSuchIRIError            (NamespaceError)         </code>","text":"<p>Namespace has no such IRI.</p> Source code in <code>tripper/errors.py</code> <pre><code>class NoSuchIRIError(NamespaceError):\n\"\"\"Namespace has no such IRI.\"\"\"\n</code></pre>"},{"location":"api_reference/errors/#tripper.errors.TriplestoreError","title":"<code> TriplestoreError            (Exception)         </code>","text":"<p>Base exception for triplestore errors.</p> Source code in <code>tripper/errors.py</code> <pre><code>class TriplestoreError(Exception):\n\"\"\"Base exception for triplestore errors.\"\"\"\n</code></pre>"},{"location":"api_reference/errors/#tripper.errors.UniquenessError","title":"<code> UniquenessError            (TriplestoreError)         </code>","text":"<p>More than one matching triple.</p> Source code in <code>tripper/errors.py</code> <pre><code>class UniquenessError(TriplestoreError):\n\"\"\"More than one matching triple.\"\"\"\n</code></pre>"},{"location":"api_reference/interface/","title":"interface","text":"<p>Provides the ITriplestore protocol class, that documents the interface of the triplestore backends.</p>"},{"location":"api_reference/interface/#tripper.interface.ITriplestore","title":"<code> ITriplestore            (Protocol)         </code>","text":"<p>Interface for triplestore backends.</p> <p>In addition to the methods specified by this interface, a backend may also implement the following optional methods:</p> <pre><code>def __init__(self, base_iri: str = None, **kwargs):\n\"\"\"Initialise triplestore.\n\n    Arguments:\n        base_iri: Optional base IRI to initiate the triplestore from.\n        kwargs: Additional keyword arguments passed to the backend.\n    \"\"\"\n\ndef parse(\n        self,\n        source: Union[str, Path, IO] = None,\n        location: str = None,\n        data: str = None,\n        format: str = None,\n        **kwargs\n    ):\n\"\"\"Parse source and add the resulting triples to triplestore.\n\n    The source is specified using one of `source`, `location` or `data`.\n\n    Arguments:\n        source: File-like object or file name.\n        location: String with relative or absolute URL to source.\n        data: String containing the data to be parsed.\n        format: Needed if format can not be inferred from source.\n        kwargs: Additional backend-specific parameters controlling\n            the parsing.\n    \"\"\"\n\ndef serialize(\n        self,\n        destination: Union[str, Path, IO] = None,\n        format: str ='xml',\n        **kwargs\n    ):\n\"\"\"Serialise to destination.\n\n    Arguments:\n        destination: File name or object to write to.  If None, the\n            serialisation is returned.\n        format: Format to serialise as.  Supported formats, depends on\n            the backend.\n        kwargs: Additional backend-specific parameters controlling\n            the serialisation.\n\n    Returns:\n        Serialised string if `destination` is None.\n    \"\"\"\n\ndef query(self, query_object: str, **kwargs) -&gt; List[Tuple[str, ...]]:\n\"\"\"SPARQL query.\n\n    Arguments:\n        query_object: String with the SPARQL query.\n        kwargs: Additional backend-specific keyword arguments.\n\n    Returns:\n        List of tuples of IRIs for each matching row.\n    \"\"\"\n\ndef update(self, update_object: str, **kwargs):\n\"\"\"Update triplestore with SPARQL.\n\n    Arguments:\n        query_object: String with the SPARQL query.\n        kwargs: Additional backend-specific keyword arguments.\n\n    Note:\n        This method is intended for INSERT and DELETE queries.  Use\n        the query() method for SELECT queries.\n    \"\"\"\n\ndef bind(self, prefix: str, namespace: str) -&gt; Namespace:\n\"\"\"Bind prefix to namespace.\n\n    Should only be defined if the backend supports namespaces.\n    \"\"\"\n\ndef namespaces(self) -&gt; dict:\n\"\"\"Returns a dict mapping prefixes to namespaces.\n\n    Should only be defined if the backend supports namespaces.\n    Used by triplestore.parse() to get prefixes after reading\n    triples from an external source.\n    \"\"\"\n\n@classmethod\ndef create_database(cls, database: str, **kwargs):\n\"\"\"Create a new database in backend.\n\n    Parameters:\n        database: Name of the new database.\n        kwargs: Keyword arguments passed to the backend\n            create_database() method.\n\n    Note:\n        This is a class method, which operates on the backend\n        triplestore without connecting to it.\n    \"\"\"\n\n@classmethod\ndef remove_database(cls, database: str, **kwargs):\n\"\"\"Remove a database in backend.\n\n    Parameters:\n        database: Name of the database to be removed.\n        kwargs: Keyword arguments passed to the backend\n            remove_database() method.\n\n    Note:\n        This is a class method, which operates on the backend\n        triplestore without connecting to it.\n    \"\"\"\n\n@classmethod\ndef list_databases(cls, **kwargs):\n\"\"\"For backends that supports multiple databases, list of all\n    databases.\n\n    Parameters:\n        kwargs: Keyword arguments passed to the backend\n            list_database() method.\n\n    Note:\n        This is a class method, which operates on the backend\n        triplestore without connecting to it.\n    \"\"\"\n</code></pre> Source code in <code>tripper/interface.py</code> <pre><code>class ITriplestore(Protocol):\n'''Interface for triplestore backends.\n\n    In addition to the methods specified by this interface, a backend\n    may also implement the following optional methods:\n\n    ```python\n\n    def __init__(self, base_iri: str = None, **kwargs):\n        \"\"\"Initialise triplestore.\n\n        Arguments:\n            base_iri: Optional base IRI to initiate the triplestore from.\n            kwargs: Additional keyword arguments passed to the backend.\n        \"\"\"\n\n    def parse(\n            self,\n            source: Union[str, Path, IO] = None,\n            location: str = None,\n            data: str = None,\n            format: str = None,\n            **kwargs\n        ):\n        \"\"\"Parse source and add the resulting triples to triplestore.\n\n        The source is specified using one of `source`, `location` or `data`.\n\n        Arguments:\n            source: File-like object or file name.\n            location: String with relative or absolute URL to source.\n            data: String containing the data to be parsed.\n            format: Needed if format can not be inferred from source.\n            kwargs: Additional backend-specific parameters controlling\n                the parsing.\n        \"\"\"\n\n    def serialize(\n            self,\n            destination: Union[str, Path, IO] = None,\n            format: str ='xml',\n            **kwargs\n        ):\n        \"\"\"Serialise to destination.\n\n        Arguments:\n            destination: File name or object to write to.  If None, the\n                serialisation is returned.\n            format: Format to serialise as.  Supported formats, depends on\n                the backend.\n            kwargs: Additional backend-specific parameters controlling\n                the serialisation.\n\n        Returns:\n            Serialised string if `destination` is None.\n        \"\"\"\n\n    def query(self, query_object: str, **kwargs) -&gt; List[Tuple[str, ...]]:\n        \"\"\"SPARQL query.\n\n        Arguments:\n            query_object: String with the SPARQL query.\n            kwargs: Additional backend-specific keyword arguments.\n\n        Returns:\n            List of tuples of IRIs for each matching row.\n        \"\"\"\n\n    def update(self, update_object: str, **kwargs):\n        \"\"\"Update triplestore with SPARQL.\n\n        Arguments:\n            query_object: String with the SPARQL query.\n            kwargs: Additional backend-specific keyword arguments.\n\n        Note:\n            This method is intended for INSERT and DELETE queries.  Use\n            the query() method for SELECT queries.\n        \"\"\"\n\n    def bind(self, prefix: str, namespace: str) -&gt; Namespace:\n        \"\"\"Bind prefix to namespace.\n\n        Should only be defined if the backend supports namespaces.\n        \"\"\"\n\n    def namespaces(self) -&gt; dict:\n        \"\"\"Returns a dict mapping prefixes to namespaces.\n\n        Should only be defined if the backend supports namespaces.\n        Used by triplestore.parse() to get prefixes after reading\n        triples from an external source.\n        \"\"\"\n\n    @classmethod\n    def create_database(cls, database: str, **kwargs):\n        \"\"\"Create a new database in backend.\n\n        Parameters:\n            database: Name of the new database.\n            kwargs: Keyword arguments passed to the backend\n                create_database() method.\n\n        Note:\n            This is a class method, which operates on the backend\n            triplestore without connecting to it.\n        \"\"\"\n\n    @classmethod\n    def remove_database(cls, database: str, **kwargs):\n        \"\"\"Remove a database in backend.\n\n        Parameters:\n            database: Name of the database to be removed.\n            kwargs: Keyword arguments passed to the backend\n                remove_database() method.\n\n        Note:\n            This is a class method, which operates on the backend\n            triplestore without connecting to it.\n        \"\"\"\n\n    @classmethod\n    def list_databases(cls, **kwargs):\n        \"\"\"For backends that supports multiple databases, list of all\n        databases.\n\n        Parameters:\n            kwargs: Keyword arguments passed to the backend\n                list_database() method.\n\n        Note:\n            This is a class method, which operates on the backend\n            triplestore without connecting to it.\n        \"\"\"\n\n    ```\n    '''\n\n    def triples(self, triple: \"Triple\") -&gt; \"Generator\":\n\"\"\"Returns a generator over matching triples.\n\n        Arguments:\n            triple: A `(s, p, o)` tuple where `s`, `p` and `o` should\n                either be None (matching anything) or an exact IRI to\n                match.\n        \"\"\"\n\n    def add_triples(self, triples: \"Sequence[Triple]\"):\n\"\"\"Add a sequence of triples.\n\n        Arguments:\n            triples: A sequence of `(s, p, o)` tuples to add to the\n                triplestore.\n        \"\"\"\n\n    def remove(self, triple: \"Triple\"):\n\"\"\"Remove all matching triples from the backend.\"\"\"\n</code></pre>"},{"location":"api_reference/interface/#tripper.interface.ITriplestore.add_triples","title":"<code>add_triples(self, triples)</code>","text":"<p>Add a sequence of triples.</p> <p>Parameters:</p> Name Type Description Default <code>triples</code> <code>Sequence[Triple]</code> <p>A sequence of <code>(s, p, o)</code> tuples to add to the triplestore.</p> required Source code in <code>tripper/interface.py</code> <pre><code>def add_triples(self, triples: \"Sequence[Triple]\"):\n\"\"\"Add a sequence of triples.\n\n    Arguments:\n        triples: A sequence of `(s, p, o)` tuples to add to the\n            triplestore.\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interface/#tripper.interface.ITriplestore.remove","title":"<code>remove(self, triple)</code>","text":"<p>Remove all matching triples from the backend.</p> Source code in <code>tripper/interface.py</code> <pre><code>def remove(self, triple: \"Triple\"):\n\"\"\"Remove all matching triples from the backend.\"\"\"\n</code></pre>"},{"location":"api_reference/interface/#tripper.interface.ITriplestore.triples","title":"<code>triples(self, triple)</code>","text":"<p>Returns a generator over matching triples.</p> <p>Parameters:</p> Name Type Description Default <code>triple</code> <code>Triple</code> <p>A <code>(s, p, o)</code> tuple where <code>s</code>, <code>p</code> and <code>o</code> should either be None (matching anything) or an exact IRI to match.</p> required Source code in <code>tripper/interface.py</code> <pre><code>def triples(self, triple: \"Triple\") -&gt; \"Generator\":\n\"\"\"Returns a generator over matching triples.\n\n    Arguments:\n        triple: A `(s, p, o)` tuple where `s`, `p` and `o` should\n            either be None (matching anything) or an exact IRI to\n            match.\n    \"\"\"\n</code></pre>"},{"location":"api_reference/literal/","title":"literal","text":"<p>Literal rdf values.</p>"},{"location":"api_reference/literal/#tripper.literal.Literal","title":"<code> Literal            (str)         </code>","text":"<p>A literal RDF value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[datetime, bytes, bytearray, bool, int, float, str]</code> <p>The literal value. See the <code>datatypes</code> class attribute for valid supported data types.  A localised string is provided as a string with <code>lang</code> set to a language code.</p> required <code>lang</code> <code>Optional[str]</code> <p>A standard language code, like \"en\", \"no\", etc. Implies that the <code>value</code> is a localised string.</p> required <code>datatype</code> <code>Any</code> <p>Explicit specification of the type of <code>value</code>. Should not be combined with <code>lang</code>.</p> required Source code in <code>tripper/literal.py</code> <pre><code>class Literal(str):\n\"\"\"A literal RDF value.\n\n    Arguments:\n        value (Union[datetime, bytes, bytearray, bool, int, float, str]):\n            The literal value. See the `datatypes` class attribute for valid\n            supported data types.  A localised string is provided as a string\n            with `lang` set to a language code.\n        lang (Optional[str]): A standard language code, like \"en\", \"no\", etc.\n            Implies that the `value` is a localised string.\n        datatype (Any): Explicit specification of the type of `value`. Should\n            not be combined with `lang`.\n    \"\"\"\n\n    lang: \"Union[str, None]\"\n    datatype: \"Any\"\n\n    # Note that the order of datatypes matters - it is used by\n    # utils.parse_literal() when inferring the datatype of a literal.\n    datatypes = {\n        datetime: (XSD.dateTime,),\n        bytes: (XSD.hexBinary,),\n        bytearray: (XSD.hexBinary,),\n        bool: (XSD.boolean,),\n        int: (\n            XSD.integer,\n            XSD.int,\n            XSD.short,\n            XSD.long,\n            XSD.nonPositiveInteger,\n            XSD.negativeInteger,\n            XSD.unsignedInt,\n            XSD.unsignedShort,\n            XSD.unsignedLong,\n            XSD.byte,\n            XSD.unsignedByte,\n        ),\n        float: (XSD.double, XSD.decimal, XSD.dateTimeStamp, XSD.real, XSD.rational),\n        str: (\n            XSD.string,\n            RDF.PlainLiteral,\n            RDF.XMLLiteral,\n            RDFS.Literal,\n            XSD.anyURI,\n            XSD.language,\n            XSD.Name,\n            XSD.NMName,\n            XSD.normalizedString,\n            XSD.token,\n            XSD.NMTOKEN,\n        ),\n    }\n\n    def __new__(\n        cls,\n        value: \"Union[datetime, bytes, bytearray, bool, int, float, str]\",\n        lang: \"Optional[str]\" = None,\n        datatype: \"Optional[Any]\" = None,\n    ):\n        string = super().__new__(cls, value)\n        if lang:\n            if datatype:\n                raise TypeError(\"A literal can only have one of `lang` or `datatype`.\")\n            string.lang = str(lang)\n            string.datatype = None\n        else:\n            string.lang = None\n            if datatype:\n                string.datatype = cls.datatypes.get(datatype, (datatype,))[0]\n            elif isinstance(value, str):\n                string.datatype = None\n            elif isinstance(value, bool):\n                string.datatype = XSD.boolean\n            elif isinstance(value, int):\n                string.datatype = XSD.integer\n            elif isinstance(value, float):\n                string.datatype = XSD.double\n            elif isinstance(value, (bytes, bytearray)):\n                # Re-initialize the value anew, similarly to what is done in the first\n                # line of this method.\n                string = super().__new__(cls, value.hex())\n                string.lang = None\n                string.datatype = XSD.hexBinary\n            elif isinstance(value, datetime):\n                string.datatype = XSD.dateTime\n                # TODO:\n                #   - XSD.base64Binary\n                #   - XSD.byte, XSD.unsignedByte\n            else:\n                string.datatype = None\n        return string\n\n    # These two methods are commeted out for now because they cause\n    # the DLite example/mapping/mappingfunc.py example to fail.\n    #\n    # It seems that these methods cause the datatype be changed to\n    # an \"h\" in some relations added by the add_function() method.\n\n    # def __hash__(self):\n    #     return hash((str(self), self.lang, self.datatype))\n\n    # def __eq__(self, other):\n    #     if isinstance(other, Literal):\n    #         return (\n    #             str(self) == str(other)\n    #             and self.lang == other.lang\n    #             and self.datatype == other.datatype\n    #         )\n    #     return str(self) == str(other)\n\n    def __repr__(self) -&gt; str:\n        lang = f\", lang='{self.lang}'\" if self.lang else \"\"\n        datatype = f\", datatype='{self.datatype}'\" if self.datatype else \"\"\n        return f\"Literal('{self}'{lang}{datatype})\"\n\n    value = property(\n        fget=lambda self: self.to_python(),\n        doc=\"Appropriate python datatype derived from this RDF literal.\",\n    )\n\n    def to_python(self):\n\"\"\"Returns an appropriate python datatype derived from this RDF\n        literal.\"\"\"\n        value = str(self)\n\n        if self.datatype == XSD.boolean:\n            value = False if self == \"False\" else bool(self)\n        elif self.datatype in self.datatypes[int]:\n            value = int(self)\n        elif self.datatype in self.datatypes[float]:\n            value = float(self)\n        elif self.datatype == XSD.hexBinary:\n            value = self.encode()\n        elif self.datatype == XSD.dateTime:\n            value = datetime.fromisoformat(self)\n        elif self.datatype and self.datatype not in self.datatypes[str]:\n            warnings.warn(f\"unknown datatype: {self.datatype} - assuming string\")\n\n        return value\n\n    def n3(self) -&gt; str:  # pylint: disable=invalid-name\n\"\"\"Returns a representation in n3 format.\"\"\"\n        if self.lang:\n            return f'\"{self}\"@{self.lang}'\n        if self.datatype:\n            return f'\"{self}\"^^{self.datatype}'\n        return f'\"{self}\"'\n</code></pre>"},{"location":"api_reference/literal/#tripper.literal.Literal.value","title":"<code>value</code>  <code>property</code> <code>readonly</code>","text":"<p>Appropriate python datatype derived from this RDF literal.</p>"},{"location":"api_reference/literal/#tripper.literal.Literal.__new__","title":"<code>__new__(cls, value, lang=None, datatype=None)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>Create and return a new object.  See help(type) for accurate signature.</p> Source code in <code>tripper/literal.py</code> <pre><code>def __new__(\n    cls,\n    value: \"Union[datetime, bytes, bytearray, bool, int, float, str]\",\n    lang: \"Optional[str]\" = None,\n    datatype: \"Optional[Any]\" = None,\n):\n    string = super().__new__(cls, value)\n    if lang:\n        if datatype:\n            raise TypeError(\"A literal can only have one of `lang` or `datatype`.\")\n        string.lang = str(lang)\n        string.datatype = None\n    else:\n        string.lang = None\n        if datatype:\n            string.datatype = cls.datatypes.get(datatype, (datatype,))[0]\n        elif isinstance(value, str):\n            string.datatype = None\n        elif isinstance(value, bool):\n            string.datatype = XSD.boolean\n        elif isinstance(value, int):\n            string.datatype = XSD.integer\n        elif isinstance(value, float):\n            string.datatype = XSD.double\n        elif isinstance(value, (bytes, bytearray)):\n            # Re-initialize the value anew, similarly to what is done in the first\n            # line of this method.\n            string = super().__new__(cls, value.hex())\n            string.lang = None\n            string.datatype = XSD.hexBinary\n        elif isinstance(value, datetime):\n            string.datatype = XSD.dateTime\n            # TODO:\n            #   - XSD.base64Binary\n            #   - XSD.byte, XSD.unsignedByte\n        else:\n            string.datatype = None\n    return string\n</code></pre>"},{"location":"api_reference/literal/#tripper.literal.Literal.n3","title":"<code>n3(self)</code>","text":"<p>Returns a representation in n3 format.</p> Source code in <code>tripper/literal.py</code> <pre><code>def n3(self) -&gt; str:  # pylint: disable=invalid-name\n\"\"\"Returns a representation in n3 format.\"\"\"\n    if self.lang:\n        return f'\"{self}\"@{self.lang}'\n    if self.datatype:\n        return f'\"{self}\"^^{self.datatype}'\n    return f'\"{self}\"'\n</code></pre>"},{"location":"api_reference/literal/#tripper.literal.Literal.to_python","title":"<code>to_python(self)</code>","text":"<p>Returns an appropriate python datatype derived from this RDF literal.</p> Source code in <code>tripper/literal.py</code> <pre><code>def to_python(self):\n\"\"\"Returns an appropriate python datatype derived from this RDF\n    literal.\"\"\"\n    value = str(self)\n\n    if self.datatype == XSD.boolean:\n        value = False if self == \"False\" else bool(self)\n    elif self.datatype in self.datatypes[int]:\n        value = int(self)\n    elif self.datatype in self.datatypes[float]:\n        value = float(self)\n    elif self.datatype == XSD.hexBinary:\n        value = self.encode()\n    elif self.datatype == XSD.dateTime:\n        value = datetime.fromisoformat(self)\n    elif self.datatype and self.datatype not in self.datatypes[str]:\n        warnings.warn(f\"unknown datatype: {self.datatype} - assuming string\")\n\n    return value\n</code></pre>"},{"location":"api_reference/namespace/","title":"namespace","text":"<p>Provides a simple representation of namespaces.</p>"},{"location":"api_reference/namespace/#tripper.namespace.Namespace","title":"<code> Namespace        </code>","text":"<p>Represent a namespace.</p> <p>Parameters:</p> Name Type Description Default <code>iri</code> <p>IRI of namespace to represent.</p> required <code>label_annotations</code> <p>Sequence of label annotations. If given, check the underlying ontology during attribute access if the name correspond to a label. The label annotations should be ordered from highest to lowest precedense. If True is provided, <code>label_annotations</code> is set to <code>(SKOS.prefLabel, RDF.label, SKOS.altLabel)</code>.</p> <code>()</code> <code>check</code> <p>Whether to check underlying ontology if the IRI exists during attribute access.  If true, NoSuchIRIError will be raised if the IRI does not exist in this namespace.</p> <code>False</code> <code>cachemode</code> <p>Should be one of:   - Namespace.NO_CACHE: Turn off caching.   - Namespace.USE_CACHE: Cache attributes as they are looked up.   - Namespace.ONLY_CACHE: Cache all names at initialisation time.     Do not access the triplestore after that. Default is <code>NO_CACHE</code> if neither <code>label_annotations</code> or <code>check</code> is given, otherwise <code>USE_CACHE</code>.</p> <code>-1</code> <code>triplestore</code> <p>Use this triplestore for label lookup and checking. If not given, and either <code>label_annotations</code> or <code>check</code> are enabled, a new rdflib triplestore will be created.</p> <code>None</code> <code>triplestore_url</code> <p>Alternative URL to use for loading the underlying ontology if <code>triplestore</code> is not given.  Defaults to <code>iri</code>.</p> <code>None</code> Source code in <code>tripper/namespace.py</code> <pre><code>class Namespace:\n\"\"\"Represent a namespace.\n\n    Arguments:\n        iri: IRI of namespace to represent.\n        label_annotations: Sequence of label annotations. If given, check\n            the underlying ontology during attribute access if the name\n            correspond to a label. The label annotations should be ordered\n            from highest to lowest precedense.\n            If True is provided, `label_annotations` is set to\n            ``(SKOS.prefLabel, RDF.label, SKOS.altLabel)``.\n        check: Whether to check underlying ontology if the IRI exists during\n            attribute access.  If true, NoSuchIRIError will be raised if the\n            IRI does not exist in this namespace.\n        cachemode: Should be one of:\n              - Namespace.NO_CACHE: Turn off caching.\n              - Namespace.USE_CACHE: Cache attributes as they are looked up.\n              - Namespace.ONLY_CACHE: Cache all names at initialisation time.\n                Do not access the triplestore after that.\n            Default is `NO_CACHE` if neither `label_annotations` or `check`\n            is given, otherwise `USE_CACHE`.\n        triplestore: Use this triplestore for label lookup and checking.\n            If not given, and either `label_annotations` or `check` are\n            enabled, a new rdflib triplestore will be created.\n        triplestore_url: Alternative URL to use for loading the underlying\n            ontology if `triplestore` is not given.  Defaults to `iri`.\n    \"\"\"\n\n    NO_CACHE = 0\n    USE_CACHE = 1\n    ONLY_CACHE = 2\n\n    __slots__ = (\n        \"_iri\",\n        \"_label_annotations\",\n        \"_check\",\n        \"_cache\",\n        \"_triplestore\",\n    )\n\n    def __init__(\n        self,\n        iri,\n        label_annotations=(),\n        check=False,\n        cachemode=-1,\n        triplestore=None,\n        triplestore_url=None,\n    ):\n        if label_annotations is True:\n            label_annotations = (SKOS.prefLabel, RDF.label, SKOS.altLabel)\n\n        self._iri = str(iri)\n        self._label_annotations = tuple(label_annotations)\n        self._check = bool(check)\n\n        need_triplestore = bool(check or label_annotations)\n        if cachemode == -1:\n            cachemode = Namespace.ONLY_CACHE if need_triplestore else Namespace.NO_CACHE\n\n        if need_triplestore and triplestore is None:\n            # Import Triplestore here to break cyclic-import\n            from .triplestore import (  # pylint: disable=import-outside-toplevel,cyclic-import\n                Triplestore,\n            )\n\n            triplestore = Triplestore(\n                \"rdflib\", base_iri=iri, triplestore_url=triplestore_url\n            )\n\n        self._cache = {} if cachemode != Namespace.NO_CACHE else None\n        #\n        # FIXME:\n        # Change this to only assigning the triplestore if cachemode is\n        # ONLY_CACHE when we figure out a good way to pre-populate the\n        # cache with IRIs from the triplestore.\n        #\n        # self._triplestore = (\n        #    triplestore if cachemode != Namespace.ONLY_CACHE else None\n        # )\n        self._triplestore = triplestore if need_triplestore else None\n\n        if cachemode != Namespace.NO_CACHE:\n            self._update_cache(triplestore)\n\n    def _update_cache(self, triplestore=None):\n\"\"\"Update the internal cache from `triplestore`.\"\"\"\n        if not triplestore:\n            triplestore = self._triplestore\n        if not triplestore:\n            raise NamespaceError(\"`triplestore` argument needed for updating the cache\")\n        if self._cache is None:\n            self._cache = {}\n\n        # Add (label, full_iri) pairs to cache\n        for label in reversed(self._label_annotations):\n            self._cache.update(\n                (o, s)\n                for s, o in triplestore.subject_objects(label)\n                if s.startswith(self._iri)\n            )\n\n        # Add (name, full_iri) pairs to cache\n        # Currently we only check concepts that defines RDFS.isDefinedBy\n        # relations.\n        # Is there an efficient way to loop over all IRIs in this namespace?\n        self._cache.update(\n            (s[len(self._iri) :], s)\n            for s in triplestore.subjects(RDFS.isDefinedBy, self._iri)\n            if s.startswith(self._iri)\n        )\n\n    def __getattr__(self, name):\n        if self._cache and name in self._cache:\n            return self._cache[name]\n\n        if self._triplestore:\n            # Check if ``iri = self._iri + name`` is in the triplestore.\n            # If so, add it to the cache.\n            # We only need to check that generator returned by\n            # `self._triplestore.predicate_objects(iri)` is non-empty.\n            iri = self._iri + name\n            predicate_object = self._triplestore.predicate_objects(iri)\n            try:\n                predicate_object.__next__()\n            except StopIteration:\n                pass\n            else:\n                if self._cache is not None:\n                    self._cache[name] = iri\n                return iri\n\n            # Check for label annotations matching `name`.\n            for label in self._label_annotations:\n                for s, o in self._triplestore.subject_objects(label):\n                    if o == name and s.startswith(self._iri):\n                        if self._cache is not None:\n                            self._cache[name] = s\n                        return s\n\n        if self._check:\n            raise NoSuchIRIError(self._iri + name)\n        return self._iri + name\n\n    def __getitem__(self, key):\n        return self.__getattr__(key)\n\n    def __repr__(self):\n        return f\"Namespace({self._iri})\"\n\n    def __str__(self):\n        return self._iri\n\n    def __add__(self, other):\n        return self._iri + str(other)\n\n    def __hash__(self):\n        return hash(self._iri)\n\n    def __eq__(self, other):\n        return self._iri == str(other)\n</code></pre>"},{"location":"api_reference/triplestore/","title":"triplestore","text":"<p>A module encapsulating different triplestores using the strategy design pattern.</p> <p>See https://raw.githubusercontent.com/EMMC-ASBL/tripper/master/README.md for an introduction.</p> <p>This module has no dependencies outside the standard library, but the triplestore backends may have.</p> <p>For developers: The usage of <code>s</code>, <code>p</code>, and <code>o</code> represent the different parts of an RDF Triple: subject, predicate, and object.</p>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore","title":"<code> Triplestore        </code>","text":"<p>Provides a common frontend to a range of triplestore backends.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>class Triplestore:\n\"\"\"Provides a common frontend to a range of triplestore backends.\"\"\"\n\n    default_namespaces = {\n        \"xml\": XML,\n        \"rdf\": RDF,\n        \"rdfs\": RDFS,\n        \"xsd\": XSD,\n        \"owl\": OWL,\n        # \"skos\": SKOS,\n        # \"dc\": DC,\n        # \"dcterms\": DCTERMS,\n        # \"foaf\": FOAF,\n        # \"doap\": DOAP,\n        # \"fno\": FNO,\n        # \"emmo\": EMMO,\n        # \"map\": MAP,\n        # \"dm\": DM,\n    }\n\n    def __init__(\n        self,\n        backend: str,\n        base_iri: \"Optional[str]\" = None,\n        database: \"Optional[str]\" = None,\n        package: \"Optional[str]\" = None,\n        **kwargs,\n    ) -&gt; None:\n\"\"\"Initialise triplestore using the backend with the given name.\n\n        Parameters:\n            backend: Name of the backend module.\n\n                For built-in backends or backends provided via a\n                backend package (using entrypoints), this should just\n                be the name of the backend with no dots (ex: \"rdflib\").\n\n                For a custom backend, you can provide the full module name,\n                including the dots (ex:\"mypackage.mybackend\").  If `package`\n                is given, `backend` is interpreted relative to `package`\n                (ex: ..mybackend).\n            base_iri: Base IRI used by the add_function() method when adding\n                new triples. May also be used by the backend.\n            database: Name of database to connect to (for backends that\n                supports it).\n            package: Required when `backend` is a relative module.  In that\n                case, it is relative to `package`.\n            kwargs: Keyword arguments passed to the backend's __init__()\n                method.\n\n        \"\"\"\n        module = self._load_backend(backend, package)\n        cls = getattr(module, f\"{backend.title()}Strategy\")\n        self.base_iri = base_iri\n        self.namespaces: \"Dict[str, Namespace]\" = {}\n        self.closed = False\n        self.backend_name = backend\n        self.backend = cls(base_iri=base_iri, database=database, **kwargs)\n\n        # Keep functions in the triplestore for convienence even though\n        # they usually do not belong to the triplestore per se.\n        self.function_repo: \"Dict[str, Union[float, Callable, None]]\" = {}\n        for prefix, namespace in self.default_namespaces.items():\n            self.bind(prefix, namespace)\n\n    @classmethod\n    def _load_backend(cls, backend: str, package: \"Optional[str]\" = None):\n\"\"\"Load and return backend module.  The arguments has the same meaning\n        as corresponding arguments to __init__().\n\n        If `backend` contains a dot or `package` is given, import `backend` using\n        `package` for relative imports.\n\n        Otherwise, if there in the \"tripper.backends\" entry point group exists\n        an entry point who's name matches `backend`, then the corresponding module\n        is loaded.\n\n        Otherwise, look for the `backend` in any of the (sub)packages listed\n        `backend_packages` module variable.\n        \"\"\"\n        # Explicitly specified backend\n        if \".\" in backend or package:\n            return importlib.import_module(backend, package)\n\n        # Installed backend package\n        if (3, 8) &lt;= sys.version_info &lt; (3, 10):\n            # Fallback for Python 3.8 and 3.9\n            eps = entry_points().get(\"tripper.backends\", ())\n        else:\n            # New entry_point interface from Python 3.10+, which is also\n            # implemented in the importlib_metadata backport for Python 3.6\n            # and 3.7.\n            eps = entry_points(group=\"tripper.backends\")\n        for entry_point in eps:\n            if entry_point.name == backend:\n                return importlib.import_module(entry_point.module)\n\n        # Backend module\n        for pack in backend_packages:\n            try:\n                return importlib.import_module(f\"{pack}.{backend}\")\n            except ModuleNotFoundError:\n                pass\n\n        raise ModuleNotFoundError(\n            \"No tripper backend named '{backend}'\",\n            name=backend,\n        )\n\n    # Methods implemented by backend\n    # ------------------------------\n    def triples(  # pylint: disable=redefined-builtin\n        self,\n        subject: \"Optional[Union[str, Triple]]\" = None,\n        predicate: \"Optional[str]\" = None,\n        object: \"Optional[Union[str, Literal]]\" = None,\n        triple: \"Optional[Triple]\" = None,\n    ) -&gt; \"Generator[Triple, None, None]\":\n\"\"\"Returns a generator over matching triples.\n\n        Arguments:\n            subject: If given, match triples with this subject.\n            predicate: If given, match triples with this predicate.\n            object: If given, match triples with this object.\n            triple: Deprecated. A `(s, p, o)` tuple where `s`, `p` and `o`\n                should either be None (matching anything) or an exact IRI\n                to match.\n\n        Returns:\n            Generator over all matching triples.\n        \"\"\"\n        # __TODO__: Remove these lines when deprecated\n        if triple or (subject and not isinstance(subject, str)):\n            warnings.warn(\n                \"The `triple` argument is deprecated.  Use `subject`, \"\n                \"`predicate` and `object` arguments instead.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n        if subject and not isinstance(subject, str):\n            subject, predicate, object = subject\n        elif triple:\n            subject, predicate, object = triple\n\n        return self.backend.triples((subject, predicate, object))\n\n    def add_triples(self, triples: \"Sequence[Triple]\"):\n\"\"\"Add a sequence of triples.\n\n        Arguments:\n            triples: A sequence of `(s, p, o)` tuples to add to the\n                triplestore.\n        \"\"\"\n        self.backend.add_triples(triples)\n\n    def remove(  # pylint: disable=redefined-builtin\n        self,\n        subject: \"Optional[Union[str, Triple]]\" = None,\n        predicate: \"Optional[str]\" = None,\n        object: \"Optional[Union[str, Literal]]\" = None,\n        triple: \"Optional[Triple]\" = None,\n    ) -&gt; None:\n\"\"\"Remove all matching triples from the backend.\n\n        Arguments:\n            subject: If given, match triples with this subject.\n            predicate: If given, match triples with this predicate.\n            object: If given, match triples with this object.\n            triple: Deprecated. A `(s, p, o)` tuple where `s`, `p` and `o`\n                should either be None (matching anything) or an exact IRI\n                to match.\n        \"\"\"\n        # __TODO__: Remove these lines when deprecated\n        if triple or (subject and not isinstance(subject, str)):\n            warnings.warn(\n                \"The `triple` argument is deprecated.  Use `subject`, \"\n                \"`predicate` and `object` arguments instead.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n        if subject and not isinstance(subject, str):\n            subject, predicate, object = subject\n        elif triple:\n            subject, predicate, object = triple\n\n        return self.backend.remove((subject, predicate, object))\n\n    # Methods optionally implemented by backend\n    # -----------------------------------------\n    def close(self):\n\"\"\"Calls the backend close() method if it is implemented.\n        Otherwise, this method has no effect.\n        \"\"\"\n        # It should be ok to call close() regardless of whether the backend\n        # implements this method or not.  Hence, don't call _check_method().\n        if not self.closed and hasattr(self.backend, \"close\"):\n            self.backend.close()\n        self.closed = True\n\n    def parse(\n        self, source=None, format=None, **kwargs  # pylint: disable=redefined-builtin\n    ) -&gt; None:\n\"\"\"Parse source and add the resulting triples to triplestore.\n\n        Parameters:\n            source: File-like object or file name.\n            format: Needed if format can not be inferred from source.\n            kwargs: Keyword arguments passed to the backend.\n                The rdflib backend supports e.g. `location` (absolute\n                or relative URL) and `data` (string containing the\n                data to be parsed) arguments.\n        \"\"\"\n        self._check_method(\"parse\")\n        self.backend.parse(source=source, format=format, **kwargs)\n\n        if hasattr(self.backend, \"namespaces\"):\n            for prefix, namespace in self.backend.namespaces().items():\n                if prefix and prefix not in self.namespaces:\n                    self.namespaces[prefix] = Namespace(namespace)\n\n    def serialize(\n        self,\n        destination=None,\n        format=\"turtle\",  # pylint: disable=redefined-builtin\n        **kwargs,\n    ) -&gt; \"Union[None, str]\":\n\"\"\"Serialise triplestore.\n\n        Parameters:\n            destination: File name or object to write to.  If None, the\n                serialisation is returned.\n            format: Format to serialise as.  Supported formats, depends on\n                the backend.\n            kwargs: Passed to the backend serialize() method.\n\n        Returns:\n            Serialized string if `destination` is None.\n        \"\"\"\n        self._check_method(\"serialize\")\n        return self.backend.serialize(destination=destination, format=format, **kwargs)\n\n    def query(self, query_object, **kwargs) -&gt; \"List[Tuple[str, ...]]\":\n\"\"\"SPARQL query.\n\n        Parameters:\n            query_object: String with the SPARQL query.\n            kwargs: Keyword arguments passed to the backend query() method.\n\n        Returns:\n            List of tuples of IRIs for each matching row.\n\n        Note:\n            This method is intended for SELECT queries. Use\n            the update() method for INSERT and DELETE queries.\n\n        \"\"\"\n        self._check_method(\"query\")\n        return self.backend.query(query_object=query_object, **kwargs)\n\n    def update(self, update_object, **kwargs) -&gt; None:\n\"\"\"Update triplestore with SPARQL.\n\n        Parameters:\n            update_object: String with the SPARQL query.\n            kwargs: Keyword arguments passed to the backend update() method.\n\n        Note:\n            This method is intended for INSERT and DELETE queries. Use\n            the query() method for SELECT queries.\n\n        \"\"\"\n        self._check_method(\"update\")\n        return self.backend.update(update_object=update_object, **kwargs)\n\n    def bind(\n        self, prefix: str, namespace: \"Union[str, Namespace]\", **kwargs\n    ) -&gt; Namespace:\n\"\"\"Bind prefix to namespace and return the new Namespace object.\n\n        The new Namespace is created with `namespace` as IRI.\n        Keyword arguments are passed to the Namespace() constructor.\n\n        If `namespace` is None, the corresponding prefix is removed.\n        \"\"\"\n        if hasattr(self.backend, \"bind\"):\n            self.backend.bind(prefix, namespace)\n\n        if namespace is None:\n            del self.namespaces[prefix]\n            return None\n\n        self.namespaces[prefix] = (\n            namespace\n            if isinstance(namespace, Namespace)\n            else Namespace(namespace, **kwargs)\n        )\n        return self.namespaces[prefix]\n\n    @classmethod\n    def create_database(cls, backend: str, database: str, **kwargs):\n\"\"\"Create a new database in backend.\n\n        Parameters:\n            backend: Name of backend.\n            database: Name of the new database.\n            kwargs: Keyword arguments passed to the backend\n                create_database() method.\n\n        Note:\n            This is a class method, which operates on the backend\n            triplestore without connecting to it.\n        \"\"\"\n        cls._check_backend_method(backend, \"create_database\")\n        backend_class = cls._get_backend(backend)\n        return backend_class.create_database(database=database, **kwargs)\n\n    @classmethod\n    def remove_database(cls, backend: str, database: str, **kwargs):\n\"\"\"Remove a database in backend.\n\n        Parameters:\n            backend: Name of backend.\n            database: Name of the database to be removed.\n            kwargs: Keyword arguments passed to the backend\n                remove_database() method.\n\n        Note:\n            This is a class method, which operates on the backend\n            triplestore without connecting to it.\n        \"\"\"\n        cls._check_backend_method(backend, \"remove_database\")\n        backend_class = cls._get_backend(backend)\n        return backend_class.remove_database(database=database, **kwargs)\n\n    @classmethod\n    def list_databases(cls, backend: str, **kwargs):\n\"\"\"For backends that supports multiple databases, list of all\n        databases.\n\n        Parameters:\n            backend: Name of backend.\n            kwargs: Keyword arguments passed to the backend\n                list_databases() method.\n\n        Note:\n            This is a class method, which operates on the backend\n            triplestore without connecting to it.\n        \"\"\"\n        cls._check_backend_method(backend, \"list_databases\")\n        backend_class = cls._get_backend(backend)\n        return backend_class.list_databases(**kwargs)\n\n    # Convenient methods\n    # ------------------\n    # These methods are modelled after rdflib and provide some convinient\n    # interfaces to the triples(), add_triples() and remove() methods\n    # implemented by all backends.\n\n    @classmethod\n    def _get_backend(cls, backend: str, package: \"Optional[str]\" = None):\n\"\"\"Returns the class implementing the given backend.\"\"\"\n        module = cls._load_backend(backend, package=package)\n        return getattr(module, f\"{backend.title()}Strategy\")\n\n    @classmethod\n    def _check_backend_method(cls, backend: str, name: str):\n\"\"\"Checks that `backend` has a method called `name`.\n\n        Raises NotImplementedError if it hasn't.\n        \"\"\"\n        backend_class = cls._get_backend(backend)\n        if not hasattr(backend_class, name):\n            raise NotImplementedError(\n                f'Triplestore backend {backend!r} do not implement a \"{name}()\" method.'\n            )\n\n    def _check_method(self, name):\n\"\"\"Check that backend implements the given method.\"\"\"\n        self._check_backend_method(self.backend_name, name)\n\n    def add(self, triple: \"Triple\"):\n\"\"\"Add `triple` to triplestore.\"\"\"\n        self.add_triples([triple])\n\n    def value(  # pylint: disable=redefined-builtin\n        self, subject=None, predicate=None, object=None, default=None, any=False\n    ):\n\"\"\"Return the value for a pair of two criteria.\n\n        Useful if one knows that there may only be one value.\n\n        Parameters:\n            subject, predicate, object: Triple to match.\n            default: Value to return if no matches are found.\n            any: If true, return any matching value, otherwise raise\n                UniquenessError.\n        \"\"\"\n        spo = (subject, predicate, object)\n        if sum(iri is None for iri in spo) != 1:\n            raise ValueError(\n                \"Exactly one of `subject`, `predicate` or `object` must be None.\"\n            )\n\n        triple = self.triples(subject, predicate, object)\n        try:\n            value = next(triple)\n        except StopIteration:\n            return default\n\n        # Index of subject-predicate-object argument that is None\n        (idx,) = [i for i, v in enumerate(spo) if v is None]\n\n        try:\n            next(triple)\n        except StopIteration:\n            return value[idx]\n\n        if any:\n            return value[idx]\n        raise UniquenessError(\"More than one match\")\n\n    def subjects(\n        self, predicate=None, object=None  # pylint: disable=redefined-builtin\n    ):\n\"\"\"Returns a generator of subjects for given predicate and object.\"\"\"\n        for s, _, _ in self.triples(predicate=predicate, object=object):\n            yield s\n\n    def predicates(\n        self, subject=None, object=None  # pylint: disable=redefined-builtin\n    ):\n\"\"\"Returns a generator of predicates for given subject and object.\"\"\"\n        for _, p, _ in self.triples(subject=subject, object=object):\n            yield p\n\n    def objects(self, subject=None, predicate=None):\n\"\"\"Returns a generator of objects for given subject and predicate.\"\"\"\n        for _, _, o in self.triples(subject=subject, predicate=predicate):\n            yield o\n\n    def subject_predicates(self, object=None):  # pylint: disable=redefined-builtin\n\"\"\"Returns a generator of (subject, predicate) tuples for given\n        object.\"\"\"\n        for s, p, _ in self.triples(object=object):\n            yield s, p\n\n    def subject_objects(self, predicate=None):\n\"\"\"Returns a generator of (subject, object) tuples for given\n        predicate.\"\"\"\n        for s, _, o in self.triples(predicate=predicate):\n            yield s, o\n\n    def predicate_objects(self, subject=None):\n\"\"\"Returns a generator of (predicate, object) tuples for given\n        subject.\"\"\"\n        for _, p, o in self.triples(subject=subject):\n            yield p, o\n\n    def set(self, triple):\n\"\"\"Convenience method to update the value of object.\n\n        Removes any existing triples for subject and predicate before adding\n        the given `triple`.\n        \"\"\"\n        s, p, _ = triple\n        self.remove(s, p)\n        self.add(triple)\n\n    def has(\n        self, subject=None, predicate=None, object=None\n    ):  # pylint: disable=redefined-builtin\n\"\"\"Returns true if the triplestore has any triple matching\n        the give subject, predicate and/or object.\"\"\"\n        triple = self.triples(subject=subject, predicate=predicate, object=object)\n        try:\n            next(triple)\n        except StopIteration:\n            return False\n        return True\n\n    # Methods providing additional functionality\n    # ------------------------------------------\n    def expand_iri(self, iri: str):\n\"\"\"Return the full IRI if `iri` is prefixed.  Otherwise `iri` is\n        returned.\"\"\"\n        match = re.match(_MATCH_PREFIXED_IRI, iri)\n        if match:\n            prefix, name = match.groups()\n            if prefix not in self.namespaces:\n                raise NamespaceError(f\"unknown namespace: {prefix}\")\n            return f\"{self.namespaces[prefix]}{name}\"\n        return iri\n\n    def prefix_iri(self, iri: str, require_prefixed: bool = False):\n\"\"\"Return prefixed IRI.\n\n        This is the reverse of expand_iri().\n\n        If `require_prefixed` is true, a NamespaceError exception is raised\n        if no prefix can be found.\n        \"\"\"\n        if not re.match(_MATCH_PREFIXED_IRI, iri):\n            for prefix, namespace in self.namespaces.items():\n                if iri.startswith(str(namespace)):\n                    return f\"{prefix}:{iri[len(str(namespace)):]}\"\n            if require_prefixed:\n                raise NamespaceError(f\"No prefix defined for IRI: {iri}\")\n        return iri\n\n    def map(\n        self,\n        source: str,\n        target: str,\n        cost: \"Optional[Union[float, Callable]]\" = None,\n        target_cost: bool = True,\n    ):\n\"\"\"Add 'mapsTo' relation to the triplestore.\n\n        Parameters:\n            source: Source IRI.\n            target: IRI of target ontological concept.\n            cost: User-defined cost of following this mapping relation\n                represented as a float.  It may be given either as a\n                float or as a callable taking the value of the mapped\n                quantity as input and returning the cost as a float.\n            target_cost: Whether the cost is assigned to mapping steps\n                that have `target` as output.\n        \"\"\"\n        return self.add_mapsTo(\n            target=target,\n            source=source,\n            cost=cost,\n            target_cost=target_cost,\n        )\n\n    def add_mapsTo(\n        self,\n        target: str,\n        source: str,\n        property_name: \"Optional[str]\" = None,\n        cost: \"Optional[Union[float, Callable]]\" = None,\n        target_cost: bool = True,\n    ):\n\"\"\"Add 'mapsTo' relation to triplestore.\n\n        Parameters:\n            target: IRI of target ontological concept.\n            source: Source IRI (or entity object).\n            property_name: Name of property if `source` is an entity or\n                an entity IRI.\n            cost: User-defined cost of following this mapping relation\n                represented as a float.  It may be given either as a\n                float or as a callable taking the value of the mapped\n                quantity as input and returning the cost as a float.\n            target_cost: Whether the cost is assigned to mapping steps\n                that have `target` as output.\n\n        Note:\n            This is equivalent to the `map()` method, but reverts the\n            two first arguments and adds the `property_name` argument.\n        \"\"\"\n        self.bind(\"map\", MAP)\n\n        if not property_name and not isinstance(source, str):\n            raise TriplestoreError(\n                \"`property_name` is required when `target` is not a string.\"\n            )\n\n        target = self.expand_iri(target)\n        source = self.expand_iri(infer_iri(source))\n        if property_name:\n            self.add((f\"{source}#{property_name}\", MAP.mapsTo, target))\n        else:\n            self.add((source, MAP.mapsTo, target))\n        if cost is not None:\n            dest = target if target_cost else source\n            self._add_cost(cost, dest)\n\n    def add_function(\n        self,\n        func: \"Union[Callable, str]\",\n        expects: \"Union[str, Sequence, Mapping]\" = (),\n        returns: \"Union[str, Sequence]\" = (),\n        base_iri: \"Optional[str]\" = None,\n        standard: str = \"emmo\",\n        cost: \"Optional[Union[float, Callable]]\" = None,\n    ):\n\"\"\"Inspect function and add triples describing it to the triplestore.\n\n        Parameters:\n            func: Function to describe.  Should either be a callable or a\n                string with a unique function IRI.\n            expects: Sequence of IRIs to ontological concepts corresponding\n                to positional arguments of `func`.  May also be given as a\n                dict mapping argument names to corresponding ontological IRIs.\n            returns: IRI of return value.  May also be given as a sequence\n                of IRIs, if multiple values are returned.\n            base_iri: Base of the IRI representing the function in the\n                knowledge base.  Defaults to the base IRI of the triplestore.\n            standard: Name of ontology to use when describing the function.\n                Valid values are:\n                - \"emmo\": Elementary Multiperspective Material Ontology (EMMO)\n                - \"fno\": Function Ontology (FnO)\n            cost: User-defined cost of following this mapping relation\n                represented as a float.  It may be given either as a\n                float or as a callable taking the same arguments as `func`\n                returning the cost as a float.\n\n        Returns:\n            func_iri: IRI of the added function.\n        \"\"\"\n        if isinstance(expects, str):\n            expects = [expects]\n        if isinstance(returns, str):\n            returns = [returns]\n\n        method = getattr(self, f\"_add_function_{standard}\")\n        func_iri = method(func, expects, returns, base_iri)\n        self.function_repo[func_iri] = func if callable(func) else None\n        if cost is not None:\n            self._add_cost(cost, func_iri)\n\n        return func_iri\n\n    def _add_cost(self, cost: \"Union[float, Callable[[], float]]\", dest_iri):\n\"\"\"Help function that adds `cost` to destination IRI `dest_iri`.\n\n        `cost` should be either a float or a Callable returning a float.\n\n        If `cost` is a callable it is just referred to with a literal\n        id and is not ontologically described as a function.  The\n        expected input arguments depends on the context, which is why\n        this function is not part of the public API.  Use the add_mapsTo()\n        and add_function() methods instead.\n        \"\"\"\n        if self.has(dest_iri, DM.hasCost):\n            warnings.warn(f\"A cost is already assigned to IRI: {dest_iri}\")\n        elif callable(cost):\n            cost_id = f\"cost_function{function_id(cost)}\"\n            self.add((dest_iri, DM.hasCost, Literal(cost_id)))\n            self.function_repo[cost_id] = cost\n        else:\n            self.add((dest_iri, DM.hasCost, Literal(cost)))\n\n    def _add_function_fno(self, func, expects, returns, base_iri):\n\"\"\"Implementing add_function() for FnO.\"\"\"\n        # pylint: disable=too-many-locals,too-many-statements\n        self.bind(\"fno\", FNO)\n        self.bind(\"dcterms\", DCTERMS)\n        self.bind(\"map\", MAP)\n\n        if base_iri is None:\n            base_iri = self.base_iri if self.base_iri else \":\"\n\n        if callable(func):\n            fid = function_id(func)  # Function id\n            func_iri = f\"{base_iri}{func.__name__}_{fid}\"\n            name = func.__name__\n            doc_string = inspect.getdoc(func)\n            parlist = f\"_:{func.__name__}{fid}_parlist\"\n            outlist = f\"_:{func.__name__}{fid}_outlist\"\n            if isinstance(expects, Sequence):\n                pars = list(zip(expects, inspect.signature(func).parameters))\n            else:\n                pars = [\n                    (expects[par], par) for par in inspect.signature(func).parameters\n                ]\n        elif isinstance(func, str):\n            func_iri = func\n            name = split_iri(func)[1]\n            doc_string = \"\"\n            parlist = f\"_:{func_iri}_parlist\"\n            outlist = f\"_:{func_iri}_outlist\"\n            pariris = expects if isinstance(expects, Sequence) else expects.values()\n            parnames = [split_iri(pariri)[1] for pariri in pariris]\n            pars = list(zip(pariris, parnames))\n        else:\n            raise TypeError(\"`func` should be either a callable or an IRI\")\n\n        self.add((func_iri, RDF.type, FNO.Function))\n        self.add((func_iri, RDFS.label, en(name)))\n        self.add((func_iri, FNO.expects, parlist))\n        self.add((func_iri, FNO.returns, outlist))\n        if doc_string:\n            self.add((func_iri, DCTERMS.description, en(doc_string)))\n\n        lst = parlist\n        for i, (iri, parname) in enumerate(pars):\n            lst_next = f\"{parlist}{i+2}\" if i &lt; len(pars) - 1 else RDF.nil\n            par = f\"{func_iri}_parameter{i+1}_{parname}\"\n            self.add((par, RDF.type, FNO.Parameter))\n            self.add((par, RDFS.label, en(parname)))\n            self.add((par, MAP.mapsTo, iri))\n            self.add((lst, RDF.first, par))\n            self.add((lst, RDF.rest, lst_next))\n            lst = lst_next\n\n        lst = outlist\n        for i, iri in enumerate(returns):\n            lst_next = f\"{outlist}{i+2}\" if i &lt; len(returns) - 1 else RDF.nil\n            val = f\"{func_iri}_output{i+1}\"\n            self.add((val, RDF.type, FNO.Output))\n            self.add((val, MAP.mapsTo, iri))\n            self.add((lst, RDF.first, val))\n            self.add((lst, RDF.rest, lst_next))\n            lst = lst_next\n\n        return func_iri\n\n    def _add_function_emmo(self, func, expects, returns, base_iri):\n\"\"\"Implementing add_function() method for the \"emmo\" standard.\"\"\"\n        # pylint: disable=too-many-locals\n        self.bind(\"emmo\", EMMO)\n        self.bind(\"dcterms\", DCTERMS)\n        self.bind(\"map\", MAP)\n\n        # Hardcode EMMO IRIs to avoid slow lookup\n        Task = EMMO.EMMO_4299e344_a321_4ef2_a744_bacfcce80afc\n        DataSet = EMMO.EMMO_194e367c_9783_4bf5_96d0_9ad597d48d9a\n        hasInput = EMMO.EMMO_36e69413_8c59_4799_946c_10b05d266e22\n        hasOutput = EMMO.EMMO_c4bace1d_4db0_4cd3_87e9_18122bae2840\n        # Software = EMMO.EMMO_8681074a_e225_4e38_b586_e85b0f43ce38\n        # hasSoftware = EMMO.Software  # TODO: fix when EMMO has hasSoftware\n\n        if base_iri is None:\n            base_iri = self.base_iri if self.base_iri else \":\"\n\n        if callable(func):\n            fid = function_id(func)  # Function id\n            func_iri = f\"{base_iri}{func.__name__}_{fid}\"\n            name = func.__name__\n            doc_string = inspect.getdoc(func)\n            if isinstance(expects, Sequence):\n                pars = list(zip(inspect.signature(func).parameters, expects))\n            else:\n                pars = expects.items()\n        elif isinstance(func, str):\n            func_iri = func\n            name = split_iri(func)[1]\n            doc_string = \"\"\n            pariris = expects if isinstance(expects, Sequence) else expects.values()\n            parnames = [split_iri(pariri)[1] for pariri in pariris]\n            pars = list(zip(parnames, pariris))\n        else:\n            raise TypeError(\"`func` should be either a callable or an IRI\")\n\n        self.add((func_iri, RDF.type, Task))\n        self.add((func_iri, RDFS.label, en(name)))\n        for parname, iri in pars:\n            self.add((iri, RDF.type, DataSet))\n            self.add((iri, RDFS.label, en(parname)))\n            self.add((func_iri, hasInput, iri))\n        for iri in returns:\n            self.add((iri, RDF.type, DataSet))\n            self.add((func_iri, hasOutput, iri))\n        if doc_string:\n            self.add((func_iri, DCTERMS.description, en(doc_string)))\n\n        return func_iri\n\n    def add_interpolation_source(  # pylint: disable=too-many-arguments\n        self,\n        xcoord: str,\n        ycoord: str,\n        input_iri: str,\n        output_iri: str,\n        base_iri: \"Optional[str]\" = None,\n        standard: str = \"emmo\",\n        cost: \"Optional[Union[float, Callable]]\" = None,\n        left: \"Optional[float]\" = None,\n        right: \"Optional[float]\" = None,\n        period: \"Optional[float]\" = None,\n    ) -&gt; str:\n\"\"\"Add data source to triplestore, such that it can be used to\n        transparently transform other data.\n\n        No data will be fetch before it is actually needed.\n\n        Parameters:\n            xcoord: IRI of data source with x-coordinates `xp`.  Must be\n                increasing if argument `period` is not specified. Otherwise,\n                `xp` is internally sorted after normalising the periodic\n                boundaries with ``xp = xp % period``.\n            ycoord: IRI of data source with y-coordinates `yp`.  Must have\n                the same length as `xp`.\n            input_iri: IRI of ontological concept that interpolation input-\n                data should be mapped to.\n            output_iri: IRI of ontological concept that interpolation output-\n                data should be mapped to.\n            base_iri: Base of the IRI representing the transformation in the\n                knowledge base.  Defaults to the base IRI of the triplestore.\n            standard: Name of ontology to use when describing the\n                transformation.  Valid values are:\n                - \"emmo\": Elementary Multiperspective Material Ontology (EMMO)\n                - \"fno\": Function Ontology (FnO)\n            cost: User-defined cost of following this mapping relation\n                represented as a float.  It may be given either as a\n                float or as a callable taking the same arguments as `func`\n                returning the cost as a float.\n            left: Value to return for `x &lt; xp[0]`, default is `fp[0]`.\n            right: Value to return for `x &gt; xp[-1]`, default is `fp[-1]`.\n            period: A period for the x-coordinates. This parameter allows the\n                proper interpolation of angular x-coordinates. Parameters\n                `left` and `right` are ignored if `period` is specified.\n\n        Returns:\n            transformation_iri: IRI of the added transformation.\n\n        Example:\n            Assume we have a data source that relates water temperature\n            (mapped to EX.Temp) to the amount of blue-green algae (mapped to\n            EX.AlgaeConc). By registering it with\n\n            &gt;&gt;&gt; temp = ts.add_data(...)  # Data source with temperatures\n            &gt;&gt;&gt; conc = ts.add_data(...)  # Data source with algae conc.\n            &gt;&gt;&gt; ts.add_interpolation_source(temp, conc, EX.Temp, EX.AlgaeConc)\n\n            we can now ask for the blue-green algae concentration in a fjord,\n            given we have a data source with the water temperature field in\n            the same fjord.\n\n            &gt;&gt;&gt; ts.add_data(..., EX.Temp)  # temperature field\n            &gt;&gt;&gt; ts.map(EX.indv, EX.AlgaeConc)\n            &gt;&gt;&gt; ts.get_data(EX.indv)  # should return the algae conc. field\n        \"\"\"\n        try:\n            import numpy as np  # pylint: disable=import-outside-toplevel\n        except ImportError as exc:\n            raise RuntimeError(\n                \"Triplestore.add_interpolation_source() requires numpy.\\n\"\n                \"Install it with\\n\\n\"\n                \"    pip install numpy\"\n            ) from exc\n\n        def func(x):\n            xp = self.get_value(xcoord)\n            fp = self.get_value(ycoord)\n            return np.interp(\n                x,\n                xp=xp,\n                fp=fp,\n                left=left,\n                right=right,\n                period=period,\n            )\n\n        return self.add_function(\n            func,\n            expects=input_iri,\n            returns=output_iri,\n            base_iri=base_iri,\n            standard=standard,\n            cost=cost,\n        )\n\n    def add_data(\n        self,\n        func: \"Union[Callable, Literal]\",\n        iri: \"Optional[Union[str, Sequence]]\" = None,\n        configurations: \"Optional[dict]\" = None,\n        base_iri: \"Optional[str]\" = None,\n        standard: str = \"emmo\",\n        cost: \"Optional[Union[float, Callable]]\" = None,\n    ) -&gt; str:\n\"\"\"Register a data source to the triplestore.\n\n        Parameters:\n            func: A callable that should return the value of the registered\n                data source.  It is called with following protopype:\n\n                    func(returns, configurations, triplestore)\n\n                The returned value may in principle be of any type, but for\n                values with unit, it is recommended to return a\n                tripper.mappings.Value object.\n                Alternatively, `func` may also be a literal value.\n            iri: IRI of ontological concept or individual that the data\n                returned by `func` should be mapped to.  If `func` is a\n                callable and multiple values are returned, it may also be\n                given as a sequenceof IRIs.\n                If not given, it will default to a new blank node.\n            configurations: Configurations passed on to `func`.\n            base_iri: Base of the IRI representing the function in the\n                knowledge base.  Defaults to the base IRI of the triplestore.\n            standard: Name of ontological standard to use when describing the\n                function.  Valid values are:\n                - \"emmo\": Elementary Multiperspective Material Ontology (EMMO)\n                - \"fno\": Function Ontology (FnO)\n            cost: User-defined cost of following this mapping relation\n                represented as a float.  It may be given either as a\n                float or as a callable taking the same arguments as `func`\n                returning the cost as a float.\n\n        Returns:\n            IRI of data source.\n        \"\"\"\n        if iri is None:\n            # pylint complains about uuid being unused if we make this an\n            # f-string\n            iri = \"_bnode_\" + str(uuid.uuid4())\n        data_source = \"_data_source_\" + random_string(8)\n        self.add((data_source, RDF.type, DataSource))\n\n        if isinstance(func, Literal):\n            self.add((data_source, hasDataValue, func))\n            if cost is not None:\n                self._add_cost(cost, data_source)\n            if isinstance(iri, str):\n                self.map(data_source, iri)\n            else:\n                raise TypeError(\"literal data can only have a single `iri`\")\n\n        elif callable(func):\n\n            def fn():\n                return func(iri, configurations, self)\n\n            # Include data source IRI in documentation to ensure that the\n            # function_id of `fn()` will differ for different data sources...\n            fn.__doc__ = f\"Function for data source: {data_source}.\\n\\n{func.__doc__}\"\n            fn.__name__ = func.__name__\n\n            func_iri = self.add_function(\n                fn,\n                expects=(),\n                returns=iri,\n                base_iri=base_iri,\n                standard=standard,\n                cost=cost,\n            )\n            self.add((data_source, hasAccessFunction, func_iri))\n        else:\n            raise TypeError(f\"`func` must be a callable or literal, got {type(func)}\")\n\n        return data_source\n\n    def get_value(\n        self,\n        iri,\n        routeno=0,\n        unit: \"Optional[str]\" = None,\n        magnitude: bool = False,\n        quantity: \"Optional[Any]\" = None,\n        **kwargs,\n    ) -&gt; \"Value\":\n\"\"\"Return the value of an individual.\n\n        Parameters:\n            iri: IRI of individual who's value we want to return.  IRI may\n                either refer to a data source or an individual mapped to\n                an ontological concept.\n            routeno: Number identifying the mapping route to apply for\n                retrieving the individual value in case IRI does not refer\n                to a data source.\n            unit: return the result in the given unit.\n                Implies `magnitude=True`.\n            magnitude: Whether to only return the magnitude of the evaluated\n                value (with no unit).\n            quantity: Quantity class to use for evaluation.  Defaults to pint.\n            kwargs: Additional arguments passed on to `mapping_routes()`.\n\n        Returns:\n            The value of the individual.\n        \"\"\"\n        from tripper.mappings import (  # pylint: disable=import-outside-toplevel\n            Value,\n            mapping_routes,\n        )\n\n        if self.has(iri, RDF.type, DataSource):\n            # `iri` refer to a DataSource\n            if self.has(iri, hasDataValue):  # literal value\n                return Value(\n                    value=parse_literal(self.value(iri, hasDataValue)).to_python(),\n                    unit=parse_literal(self.value(iri, hasUnit)).to_python()\n                    if self.has(iri, hasUnit)\n                    else None,\n                    iri=self.value(iri, MAP.mapsTo),\n                    cost=parse_literal(self.value(iri, hasCost)).to_python()\n                    if self.has(iri, hasCost)\n                    else 0.0,\n                ).get_value(unit=unit, magnitude=magnitude, quantity=quantity)\n\n            if self.has(iri, hasAccessFunction):  # callable\n                func_iri = self.value(iri, hasAccessFunction)\n                func = self.function_repo[func_iri]\n                assert callable(func)  # nosec\n                retval = func()\n                if isinstance(retval, Value):\n                    return retval.get_value(\n                        unit=unit, magnitude=magnitude, quantity=quantity\n                    )\n                return retval\n\n            raise TriplestoreError(\n                f\"data source {iri} has neither a 'hasDataValue' or a \"\n                f\"'hasAccessFunction' property\"\n            )\n\n        # `iri` correspond to an individual mapped to an ontological concept.\n        # In this case we check if there exists a mapping route.\n        routes = mapping_routes(\n            target=iri,\n            sources=list(self.subjects(RDF.type, DataSource)),\n            triplestore=self,\n            **kwargs,\n        )\n        if isinstance(routes, Value):\n            return routes.get_value(unit=unit, magnitude=magnitude, quantity=quantity)\n        return routes.eval(\n            routeno=routeno,\n            unit=unit,\n            magnitude=magnitude,\n            quantity=quantity,\n        )\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.__init__","title":"<code>__init__(self, backend, base_iri=None, database=None, package=None, **kwargs)</code>  <code>special</code>","text":"<p>Initialise triplestore using the backend with the given name.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>str</code> <p>Name of the backend module.</p> <p>For built-in backends or backends provided via a backend package (using entrypoints), this should just be the name of the backend with no dots (ex: \"rdflib\").</p> <p>For a custom backend, you can provide the full module name, including the dots (ex:\"mypackage.mybackend\").  If <code>package</code> is given, <code>backend</code> is interpreted relative to <code>package</code> (ex: ..mybackend).</p> required <code>base_iri</code> <code>'Optional[str]'</code> <p>Base IRI used by the add_function() method when adding new triples. May also be used by the backend.</p> <code>None</code> <code>database</code> <code>'Optional[str]'</code> <p>Name of database to connect to (for backends that supports it).</p> <code>None</code> <code>package</code> <code>'Optional[str]'</code> <p>Required when <code>backend</code> is a relative module.  In that case, it is relative to <code>package</code>.</p> <code>None</code> <code>kwargs</code> <p>Keyword arguments passed to the backend's init() method.</p> <code>{}</code> Source code in <code>tripper/triplestore.py</code> <pre><code>def __init__(\n    self,\n    backend: str,\n    base_iri: \"Optional[str]\" = None,\n    database: \"Optional[str]\" = None,\n    package: \"Optional[str]\" = None,\n    **kwargs,\n) -&gt; None:\n\"\"\"Initialise triplestore using the backend with the given name.\n\n    Parameters:\n        backend: Name of the backend module.\n\n            For built-in backends or backends provided via a\n            backend package (using entrypoints), this should just\n            be the name of the backend with no dots (ex: \"rdflib\").\n\n            For a custom backend, you can provide the full module name,\n            including the dots (ex:\"mypackage.mybackend\").  If `package`\n            is given, `backend` is interpreted relative to `package`\n            (ex: ..mybackend).\n        base_iri: Base IRI used by the add_function() method when adding\n            new triples. May also be used by the backend.\n        database: Name of database to connect to (for backends that\n            supports it).\n        package: Required when `backend` is a relative module.  In that\n            case, it is relative to `package`.\n        kwargs: Keyword arguments passed to the backend's __init__()\n            method.\n\n    \"\"\"\n    module = self._load_backend(backend, package)\n    cls = getattr(module, f\"{backend.title()}Strategy\")\n    self.base_iri = base_iri\n    self.namespaces: \"Dict[str, Namespace]\" = {}\n    self.closed = False\n    self.backend_name = backend\n    self.backend = cls(base_iri=base_iri, database=database, **kwargs)\n\n    # Keep functions in the triplestore for convienence even though\n    # they usually do not belong to the triplestore per se.\n    self.function_repo: \"Dict[str, Union[float, Callable, None]]\" = {}\n    for prefix, namespace in self.default_namespaces.items():\n        self.bind(prefix, namespace)\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.add","title":"<code>add(self, triple)</code>","text":"<p>Add <code>triple</code> to triplestore.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def add(self, triple: \"Triple\"):\n\"\"\"Add `triple` to triplestore.\"\"\"\n    self.add_triples([triple])\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.add_data","title":"<code>add_data(self, func, iri=None, configurations=None, base_iri=None, standard='emmo', cost=None)</code>","text":"<p>Register a data source to the triplestore.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>'Union[Callable, Literal]'</code> <p>A callable that should return the value of the registered data source.  It is called with following protopype:</p> <pre><code>func(returns, configurations, triplestore)\n</code></pre> <p>The returned value may in principle be of any type, but for values with unit, it is recommended to return a tripper.mappings.Value object. Alternatively, <code>func</code> may also be a literal value.</p> required <code>iri</code> <code>'Optional[Union[str, Sequence]]'</code> <p>IRI of ontological concept or individual that the data returned by <code>func</code> should be mapped to.  If <code>func</code> is a callable and multiple values are returned, it may also be given as a sequenceof IRIs. If not given, it will default to a new blank node.</p> <code>None</code> <code>configurations</code> <code>'Optional[dict]'</code> <p>Configurations passed on to <code>func</code>.</p> <code>None</code> <code>base_iri</code> <code>'Optional[str]'</code> <p>Base of the IRI representing the function in the knowledge base.  Defaults to the base IRI of the triplestore.</p> <code>None</code> <code>standard</code> <code>str</code> <p>Name of ontological standard to use when describing the function.  Valid values are: - \"emmo\": Elementary Multiperspective Material Ontology (EMMO) - \"fno\": Function Ontology (FnO)</p> <code>'emmo'</code> <code>cost</code> <code>'Optional[Union[float, Callable]]'</code> <p>User-defined cost of following this mapping relation represented as a float.  It may be given either as a float or as a callable taking the same arguments as <code>func</code> returning the cost as a float.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>IRI of data source.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def add_data(\n    self,\n    func: \"Union[Callable, Literal]\",\n    iri: \"Optional[Union[str, Sequence]]\" = None,\n    configurations: \"Optional[dict]\" = None,\n    base_iri: \"Optional[str]\" = None,\n    standard: str = \"emmo\",\n    cost: \"Optional[Union[float, Callable]]\" = None,\n) -&gt; str:\n\"\"\"Register a data source to the triplestore.\n\n    Parameters:\n        func: A callable that should return the value of the registered\n            data source.  It is called with following protopype:\n\n                func(returns, configurations, triplestore)\n\n            The returned value may in principle be of any type, but for\n            values with unit, it is recommended to return a\n            tripper.mappings.Value object.\n            Alternatively, `func` may also be a literal value.\n        iri: IRI of ontological concept or individual that the data\n            returned by `func` should be mapped to.  If `func` is a\n            callable and multiple values are returned, it may also be\n            given as a sequenceof IRIs.\n            If not given, it will default to a new blank node.\n        configurations: Configurations passed on to `func`.\n        base_iri: Base of the IRI representing the function in the\n            knowledge base.  Defaults to the base IRI of the triplestore.\n        standard: Name of ontological standard to use when describing the\n            function.  Valid values are:\n            - \"emmo\": Elementary Multiperspective Material Ontology (EMMO)\n            - \"fno\": Function Ontology (FnO)\n        cost: User-defined cost of following this mapping relation\n            represented as a float.  It may be given either as a\n            float or as a callable taking the same arguments as `func`\n            returning the cost as a float.\n\n    Returns:\n        IRI of data source.\n    \"\"\"\n    if iri is None:\n        # pylint complains about uuid being unused if we make this an\n        # f-string\n        iri = \"_bnode_\" + str(uuid.uuid4())\n    data_source = \"_data_source_\" + random_string(8)\n    self.add((data_source, RDF.type, DataSource))\n\n    if isinstance(func, Literal):\n        self.add((data_source, hasDataValue, func))\n        if cost is not None:\n            self._add_cost(cost, data_source)\n        if isinstance(iri, str):\n            self.map(data_source, iri)\n        else:\n            raise TypeError(\"literal data can only have a single `iri`\")\n\n    elif callable(func):\n\n        def fn():\n            return func(iri, configurations, self)\n\n        # Include data source IRI in documentation to ensure that the\n        # function_id of `fn()` will differ for different data sources...\n        fn.__doc__ = f\"Function for data source: {data_source}.\\n\\n{func.__doc__}\"\n        fn.__name__ = func.__name__\n\n        func_iri = self.add_function(\n            fn,\n            expects=(),\n            returns=iri,\n            base_iri=base_iri,\n            standard=standard,\n            cost=cost,\n        )\n        self.add((data_source, hasAccessFunction, func_iri))\n    else:\n        raise TypeError(f\"`func` must be a callable or literal, got {type(func)}\")\n\n    return data_source\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.add_function","title":"<code>add_function(self, func, expects=(), returns=(), base_iri=None, standard='emmo', cost=None)</code>","text":"<p>Inspect function and add triples describing it to the triplestore.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>'Union[Callable, str]'</code> <p>Function to describe.  Should either be a callable or a string with a unique function IRI.</p> required <code>expects</code> <code>'Union[str, Sequence, Mapping]'</code> <p>Sequence of IRIs to ontological concepts corresponding to positional arguments of <code>func</code>.  May also be given as a dict mapping argument names to corresponding ontological IRIs.</p> <code>()</code> <code>returns</code> <code>'Union[str, Sequence]'</code> <p>IRI of return value.  May also be given as a sequence of IRIs, if multiple values are returned.</p> <code>()</code> <code>base_iri</code> <code>'Optional[str]'</code> <p>Base of the IRI representing the function in the knowledge base.  Defaults to the base IRI of the triplestore.</p> <code>None</code> <code>standard</code> <code>str</code> <p>Name of ontology to use when describing the function. Valid values are: - \"emmo\": Elementary Multiperspective Material Ontology (EMMO) - \"fno\": Function Ontology (FnO)</p> <code>'emmo'</code> <code>cost</code> <code>'Optional[Union[float, Callable]]'</code> <p>User-defined cost of following this mapping relation represented as a float.  It may be given either as a float or as a callable taking the same arguments as <code>func</code> returning the cost as a float.</p> <code>None</code> <p>Returns:</p> Type Description <code>func_iri</code> <p>IRI of the added function.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def add_function(\n    self,\n    func: \"Union[Callable, str]\",\n    expects: \"Union[str, Sequence, Mapping]\" = (),\n    returns: \"Union[str, Sequence]\" = (),\n    base_iri: \"Optional[str]\" = None,\n    standard: str = \"emmo\",\n    cost: \"Optional[Union[float, Callable]]\" = None,\n):\n\"\"\"Inspect function and add triples describing it to the triplestore.\n\n    Parameters:\n        func: Function to describe.  Should either be a callable or a\n            string with a unique function IRI.\n        expects: Sequence of IRIs to ontological concepts corresponding\n            to positional arguments of `func`.  May also be given as a\n            dict mapping argument names to corresponding ontological IRIs.\n        returns: IRI of return value.  May also be given as a sequence\n            of IRIs, if multiple values are returned.\n        base_iri: Base of the IRI representing the function in the\n            knowledge base.  Defaults to the base IRI of the triplestore.\n        standard: Name of ontology to use when describing the function.\n            Valid values are:\n            - \"emmo\": Elementary Multiperspective Material Ontology (EMMO)\n            - \"fno\": Function Ontology (FnO)\n        cost: User-defined cost of following this mapping relation\n            represented as a float.  It may be given either as a\n            float or as a callable taking the same arguments as `func`\n            returning the cost as a float.\n\n    Returns:\n        func_iri: IRI of the added function.\n    \"\"\"\n    if isinstance(expects, str):\n        expects = [expects]\n    if isinstance(returns, str):\n        returns = [returns]\n\n    method = getattr(self, f\"_add_function_{standard}\")\n    func_iri = method(func, expects, returns, base_iri)\n    self.function_repo[func_iri] = func if callable(func) else None\n    if cost is not None:\n        self._add_cost(cost, func_iri)\n\n    return func_iri\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.add_interpolation_source","title":"<code>add_interpolation_source(self, xcoord, ycoord, input_iri, output_iri, base_iri=None, standard='emmo', cost=None, left=None, right=None, period=None)</code>","text":"<p>Add data source to triplestore, such that it can be used to transparently transform other data.</p> <p>No data will be fetch before it is actually needed.</p> <p>Parameters:</p> Name Type Description Default <code>xcoord</code> <code>str</code> <p>IRI of data source with x-coordinates <code>xp</code>.  Must be increasing if argument <code>period</code> is not specified. Otherwise, <code>xp</code> is internally sorted after normalising the periodic boundaries with <code>xp = xp % period</code>.</p> required <code>ycoord</code> <code>str</code> <p>IRI of data source with y-coordinates <code>yp</code>.  Must have the same length as <code>xp</code>.</p> required <code>input_iri</code> <code>str</code> <p>IRI of ontological concept that interpolation input- data should be mapped to.</p> required <code>output_iri</code> <code>str</code> <p>IRI of ontological concept that interpolation output- data should be mapped to.</p> required <code>base_iri</code> <code>'Optional[str]'</code> <p>Base of the IRI representing the transformation in the knowledge base.  Defaults to the base IRI of the triplestore.</p> <code>None</code> <code>standard</code> <code>str</code> <p>Name of ontology to use when describing the transformation.  Valid values are: - \"emmo\": Elementary Multiperspective Material Ontology (EMMO) - \"fno\": Function Ontology (FnO)</p> <code>'emmo'</code> <code>cost</code> <code>'Optional[Union[float, Callable]]'</code> <p>User-defined cost of following this mapping relation represented as a float.  It may be given either as a float or as a callable taking the same arguments as <code>func</code> returning the cost as a float.</p> <code>None</code> <code>left</code> <code>'Optional[float]'</code> <p>Value to return for <code>x &lt; xp[0]</code>, default is <code>fp[0]</code>.</p> <code>None</code> <code>right</code> <code>'Optional[float]'</code> <p>Value to return for <code>x &gt; xp[-1]</code>, default is <code>fp[-1]</code>.</p> <code>None</code> <code>period</code> <code>'Optional[float]'</code> <p>A period for the x-coordinates. This parameter allows the proper interpolation of angular x-coordinates. Parameters <code>left</code> and <code>right</code> are ignored if <code>period</code> is specified.</p> <code>None</code> <p>Returns:</p> Type Description <code>transformation_iri</code> <p>IRI of the added transformation.</p> <p>Examples:</p> <p>Assume we have a data source that relates water temperature (mapped to EX.Temp) to the amount of blue-green algae (mapped to EX.AlgaeConc). By registering it with</p> <pre><code>&gt;&gt;&gt; temp = ts.add_data(...)  # Data source with temperatures\n&gt;&gt;&gt; conc = ts.add_data(...)  # Data source with algae conc.\n&gt;&gt;&gt; ts.add_interpolation_source(temp, conc, EX.Temp, EX.AlgaeConc)\n</code></pre> <p>we can now ask for the blue-green algae concentration in a fjord, given we have a data source with the water temperature field in the same fjord.</p> <pre><code>&gt;&gt;&gt; ts.add_data(..., EX.Temp)  # temperature field\n&gt;&gt;&gt; ts.map(EX.indv, EX.AlgaeConc)\n&gt;&gt;&gt; ts.get_data(EX.indv)  # should return the algae conc. field\n</code></pre> Source code in <code>tripper/triplestore.py</code> <pre><code>def add_interpolation_source(  # pylint: disable=too-many-arguments\n    self,\n    xcoord: str,\n    ycoord: str,\n    input_iri: str,\n    output_iri: str,\n    base_iri: \"Optional[str]\" = None,\n    standard: str = \"emmo\",\n    cost: \"Optional[Union[float, Callable]]\" = None,\n    left: \"Optional[float]\" = None,\n    right: \"Optional[float]\" = None,\n    period: \"Optional[float]\" = None,\n) -&gt; str:\n\"\"\"Add data source to triplestore, such that it can be used to\n    transparently transform other data.\n\n    No data will be fetch before it is actually needed.\n\n    Parameters:\n        xcoord: IRI of data source with x-coordinates `xp`.  Must be\n            increasing if argument `period` is not specified. Otherwise,\n            `xp` is internally sorted after normalising the periodic\n            boundaries with ``xp = xp % period``.\n        ycoord: IRI of data source with y-coordinates `yp`.  Must have\n            the same length as `xp`.\n        input_iri: IRI of ontological concept that interpolation input-\n            data should be mapped to.\n        output_iri: IRI of ontological concept that interpolation output-\n            data should be mapped to.\n        base_iri: Base of the IRI representing the transformation in the\n            knowledge base.  Defaults to the base IRI of the triplestore.\n        standard: Name of ontology to use when describing the\n            transformation.  Valid values are:\n            - \"emmo\": Elementary Multiperspective Material Ontology (EMMO)\n            - \"fno\": Function Ontology (FnO)\n        cost: User-defined cost of following this mapping relation\n            represented as a float.  It may be given either as a\n            float or as a callable taking the same arguments as `func`\n            returning the cost as a float.\n        left: Value to return for `x &lt; xp[0]`, default is `fp[0]`.\n        right: Value to return for `x &gt; xp[-1]`, default is `fp[-1]`.\n        period: A period for the x-coordinates. This parameter allows the\n            proper interpolation of angular x-coordinates. Parameters\n            `left` and `right` are ignored if `period` is specified.\n\n    Returns:\n        transformation_iri: IRI of the added transformation.\n\n    Example:\n        Assume we have a data source that relates water temperature\n        (mapped to EX.Temp) to the amount of blue-green algae (mapped to\n        EX.AlgaeConc). By registering it with\n\n        &gt;&gt;&gt; temp = ts.add_data(...)  # Data source with temperatures\n        &gt;&gt;&gt; conc = ts.add_data(...)  # Data source with algae conc.\n        &gt;&gt;&gt; ts.add_interpolation_source(temp, conc, EX.Temp, EX.AlgaeConc)\n\n        we can now ask for the blue-green algae concentration in a fjord,\n        given we have a data source with the water temperature field in\n        the same fjord.\n\n        &gt;&gt;&gt; ts.add_data(..., EX.Temp)  # temperature field\n        &gt;&gt;&gt; ts.map(EX.indv, EX.AlgaeConc)\n        &gt;&gt;&gt; ts.get_data(EX.indv)  # should return the algae conc. field\n    \"\"\"\n    try:\n        import numpy as np  # pylint: disable=import-outside-toplevel\n    except ImportError as exc:\n        raise RuntimeError(\n            \"Triplestore.add_interpolation_source() requires numpy.\\n\"\n            \"Install it with\\n\\n\"\n            \"    pip install numpy\"\n        ) from exc\n\n    def func(x):\n        xp = self.get_value(xcoord)\n        fp = self.get_value(ycoord)\n        return np.interp(\n            x,\n            xp=xp,\n            fp=fp,\n            left=left,\n            right=right,\n            period=period,\n        )\n\n    return self.add_function(\n        func,\n        expects=input_iri,\n        returns=output_iri,\n        base_iri=base_iri,\n        standard=standard,\n        cost=cost,\n    )\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.add_mapsTo","title":"<code>add_mapsTo(self, target, source, property_name=None, cost=None, target_cost=True)</code>","text":"<p>Add 'mapsTo' relation to triplestore.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>IRI of target ontological concept.</p> required <code>source</code> <code>str</code> <p>Source IRI (or entity object).</p> required <code>property_name</code> <code>'Optional[str]'</code> <p>Name of property if <code>source</code> is an entity or an entity IRI.</p> <code>None</code> <code>cost</code> <code>'Optional[Union[float, Callable]]'</code> <p>User-defined cost of following this mapping relation represented as a float.  It may be given either as a float or as a callable taking the value of the mapped quantity as input and returning the cost as a float.</p> <code>None</code> <code>target_cost</code> <code>bool</code> <p>Whether the cost is assigned to mapping steps that have <code>target</code> as output.</p> <code>True</code> <p>Note</p> <p>This is equivalent to the <code>map()</code> method, but reverts the two first arguments and adds the <code>property_name</code> argument.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def add_mapsTo(\n    self,\n    target: str,\n    source: str,\n    property_name: \"Optional[str]\" = None,\n    cost: \"Optional[Union[float, Callable]]\" = None,\n    target_cost: bool = True,\n):\n\"\"\"Add 'mapsTo' relation to triplestore.\n\n    Parameters:\n        target: IRI of target ontological concept.\n        source: Source IRI (or entity object).\n        property_name: Name of property if `source` is an entity or\n            an entity IRI.\n        cost: User-defined cost of following this mapping relation\n            represented as a float.  It may be given either as a\n            float or as a callable taking the value of the mapped\n            quantity as input and returning the cost as a float.\n        target_cost: Whether the cost is assigned to mapping steps\n            that have `target` as output.\n\n    Note:\n        This is equivalent to the `map()` method, but reverts the\n        two first arguments and adds the `property_name` argument.\n    \"\"\"\n    self.bind(\"map\", MAP)\n\n    if not property_name and not isinstance(source, str):\n        raise TriplestoreError(\n            \"`property_name` is required when `target` is not a string.\"\n        )\n\n    target = self.expand_iri(target)\n    source = self.expand_iri(infer_iri(source))\n    if property_name:\n        self.add((f\"{source}#{property_name}\", MAP.mapsTo, target))\n    else:\n        self.add((source, MAP.mapsTo, target))\n    if cost is not None:\n        dest = target if target_cost else source\n        self._add_cost(cost, dest)\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.add_triples","title":"<code>add_triples(self, triples)</code>","text":"<p>Add a sequence of triples.</p> <p>Parameters:</p> Name Type Description Default <code>triples</code> <code>'Sequence[Triple]'</code> <p>A sequence of <code>(s, p, o)</code> tuples to add to the triplestore.</p> required Source code in <code>tripper/triplestore.py</code> <pre><code>def add_triples(self, triples: \"Sequence[Triple]\"):\n\"\"\"Add a sequence of triples.\n\n    Arguments:\n        triples: A sequence of `(s, p, o)` tuples to add to the\n            triplestore.\n    \"\"\"\n    self.backend.add_triples(triples)\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.bind","title":"<code>bind(self, prefix, namespace, **kwargs)</code>","text":"<p>Bind prefix to namespace and return the new Namespace object.</p> <p>The new Namespace is created with <code>namespace</code> as IRI. Keyword arguments are passed to the Namespace() constructor.</p> <p>If <code>namespace</code> is None, the corresponding prefix is removed.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def bind(\n    self, prefix: str, namespace: \"Union[str, Namespace]\", **kwargs\n) -&gt; Namespace:\n\"\"\"Bind prefix to namespace and return the new Namespace object.\n\n    The new Namespace is created with `namespace` as IRI.\n    Keyword arguments are passed to the Namespace() constructor.\n\n    If `namespace` is None, the corresponding prefix is removed.\n    \"\"\"\n    if hasattr(self.backend, \"bind\"):\n        self.backend.bind(prefix, namespace)\n\n    if namespace is None:\n        del self.namespaces[prefix]\n        return None\n\n    self.namespaces[prefix] = (\n        namespace\n        if isinstance(namespace, Namespace)\n        else Namespace(namespace, **kwargs)\n    )\n    return self.namespaces[prefix]\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.close","title":"<code>close(self)</code>","text":"<p>Calls the backend close() method if it is implemented. Otherwise, this method has no effect.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def close(self):\n\"\"\"Calls the backend close() method if it is implemented.\n    Otherwise, this method has no effect.\n    \"\"\"\n    # It should be ok to call close() regardless of whether the backend\n    # implements this method or not.  Hence, don't call _check_method().\n    if not self.closed and hasattr(self.backend, \"close\"):\n        self.backend.close()\n    self.closed = True\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.create_database","title":"<code>create_database(backend, database, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a new database in backend.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>str</code> <p>Name of backend.</p> required <code>database</code> <code>str</code> <p>Name of the new database.</p> required <code>kwargs</code> <p>Keyword arguments passed to the backend create_database() method.</p> <code>{}</code> <p>Note</p> <p>This is a class method, which operates on the backend triplestore without connecting to it.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>@classmethod\ndef create_database(cls, backend: str, database: str, **kwargs):\n\"\"\"Create a new database in backend.\n\n    Parameters:\n        backend: Name of backend.\n        database: Name of the new database.\n        kwargs: Keyword arguments passed to the backend\n            create_database() method.\n\n    Note:\n        This is a class method, which operates on the backend\n        triplestore without connecting to it.\n    \"\"\"\n    cls._check_backend_method(backend, \"create_database\")\n    backend_class = cls._get_backend(backend)\n    return backend_class.create_database(database=database, **kwargs)\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.expand_iri","title":"<code>expand_iri(self, iri)</code>","text":"<p>Return the full IRI if <code>iri</code> is prefixed.  Otherwise <code>iri</code> is returned.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def expand_iri(self, iri: str):\n\"\"\"Return the full IRI if `iri` is prefixed.  Otherwise `iri` is\n    returned.\"\"\"\n    match = re.match(_MATCH_PREFIXED_IRI, iri)\n    if match:\n        prefix, name = match.groups()\n        if prefix not in self.namespaces:\n            raise NamespaceError(f\"unknown namespace: {prefix}\")\n        return f\"{self.namespaces[prefix]}{name}\"\n    return iri\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.get_value","title":"<code>get_value(self, iri, routeno=0, unit=None, magnitude=False, quantity=None, **kwargs)</code>","text":"<p>Return the value of an individual.</p> <p>Parameters:</p> Name Type Description Default <code>iri</code> <p>IRI of individual who's value we want to return.  IRI may either refer to a data source or an individual mapped to an ontological concept.</p> required <code>routeno</code> <p>Number identifying the mapping route to apply for retrieving the individual value in case IRI does not refer to a data source.</p> <code>0</code> <code>unit</code> <code>'Optional[str]'</code> <p>return the result in the given unit. Implies <code>magnitude=True</code>.</p> <code>None</code> <code>magnitude</code> <code>bool</code> <p>Whether to only return the magnitude of the evaluated value (with no unit).</p> <code>False</code> <code>quantity</code> <code>'Optional[Any]'</code> <p>Quantity class to use for evaluation.  Defaults to pint.</p> <code>None</code> <code>kwargs</code> <p>Additional arguments passed on to <code>mapping_routes()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>'Value'</code> <p>The value of the individual.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def get_value(\n    self,\n    iri,\n    routeno=0,\n    unit: \"Optional[str]\" = None,\n    magnitude: bool = False,\n    quantity: \"Optional[Any]\" = None,\n    **kwargs,\n) -&gt; \"Value\":\n\"\"\"Return the value of an individual.\n\n    Parameters:\n        iri: IRI of individual who's value we want to return.  IRI may\n            either refer to a data source or an individual mapped to\n            an ontological concept.\n        routeno: Number identifying the mapping route to apply for\n            retrieving the individual value in case IRI does not refer\n            to a data source.\n        unit: return the result in the given unit.\n            Implies `magnitude=True`.\n        magnitude: Whether to only return the magnitude of the evaluated\n            value (with no unit).\n        quantity: Quantity class to use for evaluation.  Defaults to pint.\n        kwargs: Additional arguments passed on to `mapping_routes()`.\n\n    Returns:\n        The value of the individual.\n    \"\"\"\n    from tripper.mappings import (  # pylint: disable=import-outside-toplevel\n        Value,\n        mapping_routes,\n    )\n\n    if self.has(iri, RDF.type, DataSource):\n        # `iri` refer to a DataSource\n        if self.has(iri, hasDataValue):  # literal value\n            return Value(\n                value=parse_literal(self.value(iri, hasDataValue)).to_python(),\n                unit=parse_literal(self.value(iri, hasUnit)).to_python()\n                if self.has(iri, hasUnit)\n                else None,\n                iri=self.value(iri, MAP.mapsTo),\n                cost=parse_literal(self.value(iri, hasCost)).to_python()\n                if self.has(iri, hasCost)\n                else 0.0,\n            ).get_value(unit=unit, magnitude=magnitude, quantity=quantity)\n\n        if self.has(iri, hasAccessFunction):  # callable\n            func_iri = self.value(iri, hasAccessFunction)\n            func = self.function_repo[func_iri]\n            assert callable(func)  # nosec\n            retval = func()\n            if isinstance(retval, Value):\n                return retval.get_value(\n                    unit=unit, magnitude=magnitude, quantity=quantity\n                )\n            return retval\n\n        raise TriplestoreError(\n            f\"data source {iri} has neither a 'hasDataValue' or a \"\n            f\"'hasAccessFunction' property\"\n        )\n\n    # `iri` correspond to an individual mapped to an ontological concept.\n    # In this case we check if there exists a mapping route.\n    routes = mapping_routes(\n        target=iri,\n        sources=list(self.subjects(RDF.type, DataSource)),\n        triplestore=self,\n        **kwargs,\n    )\n    if isinstance(routes, Value):\n        return routes.get_value(unit=unit, magnitude=magnitude, quantity=quantity)\n    return routes.eval(\n        routeno=routeno,\n        unit=unit,\n        magnitude=magnitude,\n        quantity=quantity,\n    )\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.has","title":"<code>has(self, subject=None, predicate=None, object=None)</code>","text":"<p>Returns true if the triplestore has any triple matching the give subject, predicate and/or object.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def has(\n    self, subject=None, predicate=None, object=None\n):  # pylint: disable=redefined-builtin\n\"\"\"Returns true if the triplestore has any triple matching\n    the give subject, predicate and/or object.\"\"\"\n    triple = self.triples(subject=subject, predicate=predicate, object=object)\n    try:\n        next(triple)\n    except StopIteration:\n        return False\n    return True\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.list_databases","title":"<code>list_databases(backend, **kwargs)</code>  <code>classmethod</code>","text":"<p>For backends that supports multiple databases, list of all databases.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>str</code> <p>Name of backend.</p> required <code>kwargs</code> <p>Keyword arguments passed to the backend list_databases() method.</p> <code>{}</code> <p>Note</p> <p>This is a class method, which operates on the backend triplestore without connecting to it.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>@classmethod\ndef list_databases(cls, backend: str, **kwargs):\n\"\"\"For backends that supports multiple databases, list of all\n    databases.\n\n    Parameters:\n        backend: Name of backend.\n        kwargs: Keyword arguments passed to the backend\n            list_databases() method.\n\n    Note:\n        This is a class method, which operates on the backend\n        triplestore without connecting to it.\n    \"\"\"\n    cls._check_backend_method(backend, \"list_databases\")\n    backend_class = cls._get_backend(backend)\n    return backend_class.list_databases(**kwargs)\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.map","title":"<code>map(self, source, target, cost=None, target_cost=True)</code>","text":"<p>Add 'mapsTo' relation to the triplestore.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source IRI.</p> required <code>target</code> <code>str</code> <p>IRI of target ontological concept.</p> required <code>cost</code> <code>'Optional[Union[float, Callable]]'</code> <p>User-defined cost of following this mapping relation represented as a float.  It may be given either as a float or as a callable taking the value of the mapped quantity as input and returning the cost as a float.</p> <code>None</code> <code>target_cost</code> <code>bool</code> <p>Whether the cost is assigned to mapping steps that have <code>target</code> as output.</p> <code>True</code> Source code in <code>tripper/triplestore.py</code> <pre><code>def map(\n    self,\n    source: str,\n    target: str,\n    cost: \"Optional[Union[float, Callable]]\" = None,\n    target_cost: bool = True,\n):\n\"\"\"Add 'mapsTo' relation to the triplestore.\n\n    Parameters:\n        source: Source IRI.\n        target: IRI of target ontological concept.\n        cost: User-defined cost of following this mapping relation\n            represented as a float.  It may be given either as a\n            float or as a callable taking the value of the mapped\n            quantity as input and returning the cost as a float.\n        target_cost: Whether the cost is assigned to mapping steps\n            that have `target` as output.\n    \"\"\"\n    return self.add_mapsTo(\n        target=target,\n        source=source,\n        cost=cost,\n        target_cost=target_cost,\n    )\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.objects","title":"<code>objects(self, subject=None, predicate=None)</code>","text":"<p>Returns a generator of objects for given subject and predicate.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def objects(self, subject=None, predicate=None):\n\"\"\"Returns a generator of objects for given subject and predicate.\"\"\"\n    for _, _, o in self.triples(subject=subject, predicate=predicate):\n        yield o\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.parse","title":"<code>parse(self, source=None, format=None, **kwargs)</code>","text":"<p>Parse source and add the resulting triples to triplestore.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <p>File-like object or file name.</p> <code>None</code> <code>format</code> <p>Needed if format can not be inferred from source.</p> <code>None</code> <code>kwargs</code> <p>Keyword arguments passed to the backend. The rdflib backend supports e.g. <code>location</code> (absolute or relative URL) and <code>data</code> (string containing the data to be parsed) arguments.</p> <code>{}</code> Source code in <code>tripper/triplestore.py</code> <pre><code>def parse(\n    self, source=None, format=None, **kwargs  # pylint: disable=redefined-builtin\n) -&gt; None:\n\"\"\"Parse source and add the resulting triples to triplestore.\n\n    Parameters:\n        source: File-like object or file name.\n        format: Needed if format can not be inferred from source.\n        kwargs: Keyword arguments passed to the backend.\n            The rdflib backend supports e.g. `location` (absolute\n            or relative URL) and `data` (string containing the\n            data to be parsed) arguments.\n    \"\"\"\n    self._check_method(\"parse\")\n    self.backend.parse(source=source, format=format, **kwargs)\n\n    if hasattr(self.backend, \"namespaces\"):\n        for prefix, namespace in self.backend.namespaces().items():\n            if prefix and prefix not in self.namespaces:\n                self.namespaces[prefix] = Namespace(namespace)\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.predicate_objects","title":"<code>predicate_objects(self, subject=None)</code>","text":"<p>Returns a generator of (predicate, object) tuples for given subject.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def predicate_objects(self, subject=None):\n\"\"\"Returns a generator of (predicate, object) tuples for given\n    subject.\"\"\"\n    for _, p, o in self.triples(subject=subject):\n        yield p, o\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.predicates","title":"<code>predicates(self, subject=None, object=None)</code>","text":"<p>Returns a generator of predicates for given subject and object.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def predicates(\n    self, subject=None, object=None  # pylint: disable=redefined-builtin\n):\n\"\"\"Returns a generator of predicates for given subject and object.\"\"\"\n    for _, p, _ in self.triples(subject=subject, object=object):\n        yield p\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.prefix_iri","title":"<code>prefix_iri(self, iri, require_prefixed=False)</code>","text":"<p>Return prefixed IRI.</p> <p>This is the reverse of expand_iri().</p> <p>If <code>require_prefixed</code> is true, a NamespaceError exception is raised if no prefix can be found.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def prefix_iri(self, iri: str, require_prefixed: bool = False):\n\"\"\"Return prefixed IRI.\n\n    This is the reverse of expand_iri().\n\n    If `require_prefixed` is true, a NamespaceError exception is raised\n    if no prefix can be found.\n    \"\"\"\n    if not re.match(_MATCH_PREFIXED_IRI, iri):\n        for prefix, namespace in self.namespaces.items():\n            if iri.startswith(str(namespace)):\n                return f\"{prefix}:{iri[len(str(namespace)):]}\"\n        if require_prefixed:\n            raise NamespaceError(f\"No prefix defined for IRI: {iri}\")\n    return iri\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.query","title":"<code>query(self, query_object, **kwargs)</code>","text":"<p>SPARQL query.</p> <p>Parameters:</p> Name Type Description Default <code>query_object</code> <p>String with the SPARQL query.</p> required <code>kwargs</code> <p>Keyword arguments passed to the backend query() method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>'List[Tuple[str, ...]]'</code> <p>List of tuples of IRIs for each matching row.</p> <p>Note</p> <p>This method is intended for SELECT queries. Use the update() method for INSERT and DELETE queries.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def query(self, query_object, **kwargs) -&gt; \"List[Tuple[str, ...]]\":\n\"\"\"SPARQL query.\n\n    Parameters:\n        query_object: String with the SPARQL query.\n        kwargs: Keyword arguments passed to the backend query() method.\n\n    Returns:\n        List of tuples of IRIs for each matching row.\n\n    Note:\n        This method is intended for SELECT queries. Use\n        the update() method for INSERT and DELETE queries.\n\n    \"\"\"\n    self._check_method(\"query\")\n    return self.backend.query(query_object=query_object, **kwargs)\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.remove","title":"<code>remove(self, subject=None, predicate=None, object=None, triple=None)</code>","text":"<p>Remove all matching triples from the backend.</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>'Optional[Union[str, Triple]]'</code> <p>If given, match triples with this subject.</p> <code>None</code> <code>predicate</code> <code>'Optional[str]'</code> <p>If given, match triples with this predicate.</p> <code>None</code> <code>object</code> <code>'Optional[Union[str, Literal]]'</code> <p>If given, match triples with this object.</p> <code>None</code> <code>triple</code> <code>'Optional[Triple]'</code> <p>Deprecated. A <code>(s, p, o)</code> tuple where <code>s</code>, <code>p</code> and <code>o</code> should either be None (matching anything) or an exact IRI to match.</p> <code>None</code> Source code in <code>tripper/triplestore.py</code> <pre><code>def remove(  # pylint: disable=redefined-builtin\n    self,\n    subject: \"Optional[Union[str, Triple]]\" = None,\n    predicate: \"Optional[str]\" = None,\n    object: \"Optional[Union[str, Literal]]\" = None,\n    triple: \"Optional[Triple]\" = None,\n) -&gt; None:\n\"\"\"Remove all matching triples from the backend.\n\n    Arguments:\n        subject: If given, match triples with this subject.\n        predicate: If given, match triples with this predicate.\n        object: If given, match triples with this object.\n        triple: Deprecated. A `(s, p, o)` tuple where `s`, `p` and `o`\n            should either be None (matching anything) or an exact IRI\n            to match.\n    \"\"\"\n    # __TODO__: Remove these lines when deprecated\n    if triple or (subject and not isinstance(subject, str)):\n        warnings.warn(\n            \"The `triple` argument is deprecated.  Use `subject`, \"\n            \"`predicate` and `object` arguments instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n    if subject and not isinstance(subject, str):\n        subject, predicate, object = subject\n    elif triple:\n        subject, predicate, object = triple\n\n    return self.backend.remove((subject, predicate, object))\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.remove_database","title":"<code>remove_database(backend, database, **kwargs)</code>  <code>classmethod</code>","text":"<p>Remove a database in backend.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>str</code> <p>Name of backend.</p> required <code>database</code> <code>str</code> <p>Name of the database to be removed.</p> required <code>kwargs</code> <p>Keyword arguments passed to the backend remove_database() method.</p> <code>{}</code> <p>Note</p> <p>This is a class method, which operates on the backend triplestore without connecting to it.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>@classmethod\ndef remove_database(cls, backend: str, database: str, **kwargs):\n\"\"\"Remove a database in backend.\n\n    Parameters:\n        backend: Name of backend.\n        database: Name of the database to be removed.\n        kwargs: Keyword arguments passed to the backend\n            remove_database() method.\n\n    Note:\n        This is a class method, which operates on the backend\n        triplestore without connecting to it.\n    \"\"\"\n    cls._check_backend_method(backend, \"remove_database\")\n    backend_class = cls._get_backend(backend)\n    return backend_class.remove_database(database=database, **kwargs)\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.serialize","title":"<code>serialize(self, destination=None, format='turtle', **kwargs)</code>","text":"<p>Serialise triplestore.</p> <p>Parameters:</p> Name Type Description Default <code>destination</code> <p>File name or object to write to.  If None, the serialisation is returned.</p> <code>None</code> <code>format</code> <p>Format to serialise as.  Supported formats, depends on the backend.</p> <code>'turtle'</code> <code>kwargs</code> <p>Passed to the backend serialize() method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>'Union[None, str]'</code> <p>Serialized string if <code>destination</code> is None.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def serialize(\n    self,\n    destination=None,\n    format=\"turtle\",  # pylint: disable=redefined-builtin\n    **kwargs,\n) -&gt; \"Union[None, str]\":\n\"\"\"Serialise triplestore.\n\n    Parameters:\n        destination: File name or object to write to.  If None, the\n            serialisation is returned.\n        format: Format to serialise as.  Supported formats, depends on\n            the backend.\n        kwargs: Passed to the backend serialize() method.\n\n    Returns:\n        Serialized string if `destination` is None.\n    \"\"\"\n    self._check_method(\"serialize\")\n    return self.backend.serialize(destination=destination, format=format, **kwargs)\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.set","title":"<code>set(self, triple)</code>","text":"<p>Convenience method to update the value of object.</p> <p>Removes any existing triples for subject and predicate before adding the given <code>triple</code>.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def set(self, triple):\n\"\"\"Convenience method to update the value of object.\n\n    Removes any existing triples for subject and predicate before adding\n    the given `triple`.\n    \"\"\"\n    s, p, _ = triple\n    self.remove(s, p)\n    self.add(triple)\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.subject_objects","title":"<code>subject_objects(self, predicate=None)</code>","text":"<p>Returns a generator of (subject, object) tuples for given predicate.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def subject_objects(self, predicate=None):\n\"\"\"Returns a generator of (subject, object) tuples for given\n    predicate.\"\"\"\n    for s, _, o in self.triples(predicate=predicate):\n        yield s, o\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.subject_predicates","title":"<code>subject_predicates(self, object=None)</code>","text":"<p>Returns a generator of (subject, predicate) tuples for given object.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def subject_predicates(self, object=None):  # pylint: disable=redefined-builtin\n\"\"\"Returns a generator of (subject, predicate) tuples for given\n    object.\"\"\"\n    for s, p, _ in self.triples(object=object):\n        yield s, p\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.subjects","title":"<code>subjects(self, predicate=None, object=None)</code>","text":"<p>Returns a generator of subjects for given predicate and object.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def subjects(\n    self, predicate=None, object=None  # pylint: disable=redefined-builtin\n):\n\"\"\"Returns a generator of subjects for given predicate and object.\"\"\"\n    for s, _, _ in self.triples(predicate=predicate, object=object):\n        yield s\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.triples","title":"<code>triples(self, subject=None, predicate=None, object=None, triple=None)</code>","text":"<p>Returns a generator over matching triples.</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>'Optional[Union[str, Triple]]'</code> <p>If given, match triples with this subject.</p> <code>None</code> <code>predicate</code> <code>'Optional[str]'</code> <p>If given, match triples with this predicate.</p> <code>None</code> <code>object</code> <code>'Optional[Union[str, Literal]]'</code> <p>If given, match triples with this object.</p> <code>None</code> <code>triple</code> <code>'Optional[Triple]'</code> <p>Deprecated. A <code>(s, p, o)</code> tuple where <code>s</code>, <code>p</code> and <code>o</code> should either be None (matching anything) or an exact IRI to match.</p> <code>None</code> <p>Returns:</p> Type Description <code>'Generator[Triple, None, None]'</code> <p>Generator over all matching triples.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def triples(  # pylint: disable=redefined-builtin\n    self,\n    subject: \"Optional[Union[str, Triple]]\" = None,\n    predicate: \"Optional[str]\" = None,\n    object: \"Optional[Union[str, Literal]]\" = None,\n    triple: \"Optional[Triple]\" = None,\n) -&gt; \"Generator[Triple, None, None]\":\n\"\"\"Returns a generator over matching triples.\n\n    Arguments:\n        subject: If given, match triples with this subject.\n        predicate: If given, match triples with this predicate.\n        object: If given, match triples with this object.\n        triple: Deprecated. A `(s, p, o)` tuple where `s`, `p` and `o`\n            should either be None (matching anything) or an exact IRI\n            to match.\n\n    Returns:\n        Generator over all matching triples.\n    \"\"\"\n    # __TODO__: Remove these lines when deprecated\n    if triple or (subject and not isinstance(subject, str)):\n        warnings.warn(\n            \"The `triple` argument is deprecated.  Use `subject`, \"\n            \"`predicate` and `object` arguments instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n    if subject and not isinstance(subject, str):\n        subject, predicate, object = subject\n    elif triple:\n        subject, predicate, object = triple\n\n    return self.backend.triples((subject, predicate, object))\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.update","title":"<code>update(self, update_object, **kwargs)</code>","text":"<p>Update triplestore with SPARQL.</p> <p>Parameters:</p> Name Type Description Default <code>update_object</code> <p>String with the SPARQL query.</p> required <code>kwargs</code> <p>Keyword arguments passed to the backend update() method.</p> <code>{}</code> <p>Note</p> <p>This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries.</p> Source code in <code>tripper/triplestore.py</code> <pre><code>def update(self, update_object, **kwargs) -&gt; None:\n\"\"\"Update triplestore with SPARQL.\n\n    Parameters:\n        update_object: String with the SPARQL query.\n        kwargs: Keyword arguments passed to the backend update() method.\n\n    Note:\n        This method is intended for INSERT and DELETE queries. Use\n        the query() method for SELECT queries.\n\n    \"\"\"\n    self._check_method(\"update\")\n    return self.backend.update(update_object=update_object, **kwargs)\n</code></pre>"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.value","title":"<code>value(self, subject=None, predicate=None, object=None, default=None, any=False)</code>","text":"<p>Return the value for a pair of two criteria.</p> <p>Useful if one knows that there may only be one value.</p> <p>Parameters:</p> Name Type Description Default <code>subject,</code> <code>predicate, object</code> <p>Triple to match.</p> required <code>default</code> <p>Value to return if no matches are found.</p> <code>None</code> <code>any</code> <p>If true, return any matching value, otherwise raise UniquenessError.</p> <code>False</code> Source code in <code>tripper/triplestore.py</code> <pre><code>def value(  # pylint: disable=redefined-builtin\n    self, subject=None, predicate=None, object=None, default=None, any=False\n):\n\"\"\"Return the value for a pair of two criteria.\n\n    Useful if one knows that there may only be one value.\n\n    Parameters:\n        subject, predicate, object: Triple to match.\n        default: Value to return if no matches are found.\n        any: If true, return any matching value, otherwise raise\n            UniquenessError.\n    \"\"\"\n    spo = (subject, predicate, object)\n    if sum(iri is None for iri in spo) != 1:\n        raise ValueError(\n            \"Exactly one of `subject`, `predicate` or `object` must be None.\"\n        )\n\n    triple = self.triples(subject, predicate, object)\n    try:\n        value = next(triple)\n    except StopIteration:\n        return default\n\n    # Index of subject-predicate-object argument that is None\n    (idx,) = [i for i, v in enumerate(spo) if v is None]\n\n    try:\n        next(triple)\n    except StopIteration:\n        return value[idx]\n\n    if any:\n        return value[idx]\n    raise UniquenessError(\"More than one match\")\n</code></pre>"},{"location":"api_reference/utils/","title":"utils","text":"<p>Utility functions.</p>"},{"location":"api_reference/utils/#tripper.utils.UnusedArgumentWarning","title":"<code> UnusedArgumentWarning            (Warning)         </code>","text":"<p>Argument is unused.</p> Source code in <code>tripper/utils.py</code> <pre><code>class UnusedArgumentWarning(Warning):\n\"\"\"Argument is unused.\"\"\"\n</code></pre>"},{"location":"api_reference/utils/#tripper.utils.as_python","title":"<code>as_python(value)</code>","text":"<p>Converts <code>value</code> to a native Python representation.</p> <p>If <code>value</code> is a Literal, its Python representation will be returned. If <code>value</code> is a string, it will first be converted to a Literal, before its Python representation is returned. Otherwise, <code>value</code> will be returned as-is.</p> Source code in <code>tripper/utils.py</code> <pre><code>def as_python(value: \"Any\") -&gt; \"Any\":\n\"\"\"Converts `value` to a native Python representation.\n\n    If `value` is a Literal, its Python representation will be returned.\n    If `value` is a string, it will first be converted to a Literal, before\n    its Python representation is returned.\n    Otherwise, `value` will be returned as-is.\n    \"\"\"\n    if isinstance(value, Literal):\n        return value.to_python()\n    if isinstance(value, str):\n        return parse_literal(value).to_python()\n    return value\n</code></pre>"},{"location":"api_reference/utils/#tripper.utils.check","title":"<code>check(func, s, exceptions)</code>","text":"<p>Help function that returns true if <code>func(s)</code> does not raise an exception.</p> <p>False is returned if <code>func(s)</code> raises an exception listed in <code>exceptions</code>. Otherwise the exception is propagated.</p> Source code in <code>tripper/utils.py</code> <pre><code>def check(func: \"Callable\", s: str, exceptions) -&gt; bool:\n\"\"\"Help function that returns true if `func(s)` does not raise an exception.\n\n    False is returned if `func(s)` raises an exception listed in `exceptions`.\n    Otherwise the exception is propagated.\n    \"\"\"\n    # Note that the missing type hint on `exceptions` is deliberate, see\n    # https://peps.python.org/pep-0484/#exceptions\n    try:\n        func(s)\n    except exceptions:\n        return False\n    return True\n</code></pre>"},{"location":"api_reference/utils/#tripper.utils.en","title":"<code>en(value)</code>","text":"<p>Convenience function that returns value as a plain english literal.</p> <p>Equivalent to <code>Literal(value, lang=\"en\")</code>.</p> Source code in <code>tripper/utils.py</code> <pre><code>def en(value) -&gt; \"Literal\":  # pylint: disable=invalid-name\n\"\"\"Convenience function that returns value as a plain english literal.\n\n    Equivalent to ``Literal(value, lang=\"en\")``.\n    \"\"\"\n    return Literal(value, lang=\"en\")\n</code></pre>"},{"location":"api_reference/utils/#tripper.utils.function_id","title":"<code>function_id(func, length=4)</code>","text":"<p>Return a checksum for function <code>func</code>.</p> <p>The returned object is a string of hexadecimal digits.</p> <p><code>length</code> is the number of bytes in the returned checksum.  Since the current implementation is based on the shake_128 algorithm, it make no sense to set <code>length</code> larger than 32 bytes.</p> Source code in <code>tripper/utils.py</code> <pre><code>def function_id(func: \"Callable\", length: int = 4) -&gt; str:\n\"\"\"Return a checksum for function `func`.\n\n    The returned object is a string of hexadecimal digits.\n\n    `length` is the number of bytes in the returned checksum.  Since\n    the current implementation is based on the shake_128 algorithm,\n    it make no sense to set `length` larger than 32 bytes.\n    \"\"\"\n    source = inspect.getsource(func)\n    doc = func.__doc__ if func.__doc__ else \"\"\n    return hashlib.shake_128(  # pylint: disable=too-many-function-args\n        (source + doc).encode()\n    ).hexdigest(length)\n</code></pre>"},{"location":"api_reference/utils/#tripper.utils.infer_iri","title":"<code>infer_iri(obj)</code>","text":"<p>Return IRI of the individual that stands for object <code>obj</code>.</p> Source code in <code>tripper/utils.py</code> <pre><code>def infer_iri(obj):\n\"\"\"Return IRI of the individual that stands for object `obj`.\"\"\"\n    if isinstance(obj, str):\n        iri = obj\n    elif hasattr(obj, \"uri\") and isinstance(obj.uri, str):\n        # dlite.Metadata or dataclass (or instance with uri)\n        iri = obj.uri\n    elif hasattr(obj, \"uuid\") and obj.uuid:\n        # dlite.Instance or dataclass\n        iri = str(obj.uuid)\n    elif hasattr(obj, \"schema\") and callable(obj.schema):\n        # pydantic.BaseModel\n        if hasattr(obj, \"identity\") and isinstance(obj.identity, str):\n            # soft7 pydantic model\n            iri = obj.identity\n        else:\n            # pydantic instance\n            schema = obj.schema()\n            properties = schema[\"properties\"]\n            if \"uri\" in properties and isinstance(properties[\"uri\"], str):\n                iri = properties[\"uri\"]\n            if \"identity\" in properties and isinstance(properties[\"identity\"], str):\n                iri = properties[\"identity\"]\n            if \"uuid\" in properties and properties[\"uuid\"]:\n                iri = str(properties[\"uuid\"])\n    else:\n        raise TypeError(f\"cannot infer IRI from object: {obj!r}\")\n    return str(iri)\n</code></pre>"},{"location":"api_reference/utils/#tripper.utils.parse_literal","title":"<code>parse_literal(literal)</code>","text":"<p>Parse <code>literal</code> and return it as an instance of Literal.</p> <p>The main difference between this function and the Literal constructor, is that this function correctly interprets n3-encoded literal strings.</p> Source code in <code>tripper/utils.py</code> <pre><code>def parse_literal(literal: \"Any\") -&gt; \"Literal\":\n\"\"\"Parse `literal` and return it as an instance of Literal.\n\n    The main difference between this function and the Literal constructor,\n    is that this function correctly interprets n3-encoded literal strings.\n    \"\"\"\n    # pylint: disable=invalid-name,too-many-branches\n    lang, datatype = None, None\n\n    if isinstance(literal, Literal):\n        return literal\n\n    if not isinstance(literal, str):\n        if isinstance(literal, tuple(Literal.datatypes)):\n            return Literal(\n                literal,\n                lang=lang,\n                datatype=Literal.datatypes.get(type(literal))[0],  # type: ignore\n            )\n        raise TypeError(f\"unsupported literal type: {type(literal)}\")\n\n    match = re.match(r'^\\s*(\"\"\"(.*)\"\"\"|\"(.*)\")\\s*$', literal, flags=re.DOTALL)\n    if match:\n        _, v1, v2 = match.groups()\n        value, datatype = v1 if v1 else v2, XSD.string\n    else:\n        match = re.match(\n            r'^\\s*(\"\"\"(.*)\"\"\"|\"(.*)\")\\^\\^(.*)\\s*$', literal, flags=re.DOTALL\n        )\n        if match:\n            _, v1, v2, datatype = match.groups()\n            value = v1 if v1 else v2\n        else:\n            match = re.match(\n                r'^\\s*(\"\"\"(.*)\"\"\"|\"(.*)\")@(.*)\\s*$', literal, flags=re.DOTALL\n            )\n            if match:\n                _, v1, v2, lang = match.groups()\n                value = v1 if v1 else v2\n            else:\n                value = literal\n\n    if lang or datatype:\n        if datatype:\n            types = {}\n            for pytype, datatypes in Literal.datatypes.items():\n                types.update({t: pytype for t in datatypes})\n            type_ = types[datatype]\n            try:\n                value = type_(value)\n            except TypeError:\n                pass\n        return Literal(value, lang=lang, datatype=datatype)\n\n    for type_, datatypes in Literal.datatypes.items():\n        if type_ is not bool:\n            try:\n                return Literal(type_(literal), lang=lang, datatype=datatypes[0])\n            except (ValueError, TypeError):\n                pass\n\n    raise ValueError(f'cannot parse literal \"{literal}\"')\n</code></pre>"},{"location":"api_reference/utils/#tripper.utils.parse_object","title":"<code>parse_object(obj)</code>","text":"<p>Applies heuristics to parse RDF object <code>obj</code> to an IRI or literal.</p> <p>The following heuristics is performed (in the given order): - If <code>obj</code> is a Literal, it is returned. - If <code>obj</code> is a string and   - starts with \"_:\", it is assumed to be a blank node and returned.   - starts with a scheme, it is asumed to be an IRI and returned.   - can be converted to a float, int or datetime, it is returned     converted to a literal of the corresponding type.   - it is a valid n3 representation, return it as the given type.   - otherwise, return it as a xsd:string literal. - Otherwise, raise an ValueError.</p> <p>Returns     A string if <code>obj</code> is considered to be an IRI, otherwise a     literal.</p> Source code in <code>tripper/utils.py</code> <pre><code>def parse_object(obj: \"Union[str, Literal]\") -&gt; \"Union[str, Literal]\":\n\"\"\"Applies heuristics to parse RDF object `obj` to an IRI or literal.\n\n    The following heuristics is performed (in the given order):\n    - If `obj` is a Literal, it is returned.\n    - If `obj` is a string and\n      - starts with \"_:\", it is assumed to be a blank node and returned.\n      - starts with a scheme, it is asumed to be an IRI and returned.\n      - can be converted to a float, int or datetime, it is returned\n        converted to a literal of the corresponding type.\n      - it is a valid n3 representation, return it as the given type.\n      - otherwise, return it as a xsd:string literal.\n    - Otherwise, raise an ValueError.\n\n    Returns\n        A string if `obj` is considered to be an IRI, otherwise a\n        literal.\n    \"\"\"\n    # pylint: disable=too-many-return-statements\n    if isinstance(obj, Literal):\n        return obj\n    if isinstance(obj, str):\n        if obj.startswith(\"_:\") or re.match(r\"^[a-z]+://\", obj):  # IRI\n            return obj\n        if obj in (\"true\", \"false\"):  # boolean\n            return Literal(obj, datatype=XSD.boolean)\n        if re.match(r\"^\\s*[+-]?\\d+\\s*$\", obj):  # integer\n            return Literal(obj, datatype=XSD.integer)\n        if check(float, obj, ValueError):  #  float\n            return Literal(obj, datatype=XSD.double)\n        if check(datetime.datetime.fromisoformat, obj, ValueError):  #  datetime\n            return Literal(obj, datatype=XSD.dateTime)\n        return parse_literal(obj)\n    raise ValueError(\"`obj` should be a literal or a string.\")\n</code></pre>"},{"location":"api_reference/utils/#tripper.utils.random_string","title":"<code>random_string(length=8)</code>","text":"<p>Return a random string of the given length.</p> Source code in <code>tripper/utils.py</code> <pre><code>def random_string(length=8):\n\"\"\"Return a random string of the given length.\"\"\"\n    letters = string.ascii_letters + string.digits\n    return \"\".join(random.choice(letters) for i in range(length))  # nosec\n</code></pre>"},{"location":"api_reference/utils/#tripper.utils.split_iri","title":"<code>split_iri(iri)</code>","text":"<p>Split iri into namespace and name parts and return them as a tuple.</p> <p>Parameters:</p> Name Type Description Default <code>iri</code> <code>str</code> <p>The IRI to be split.</p> required <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>A split IRI. Split into namespace and name.</p> Source code in <code>tripper/utils.py</code> <pre><code>def split_iri(iri: str) -&gt; \"Tuple[str, str]\":\n\"\"\"Split iri into namespace and name parts and return them as a tuple.\n\n    Parameters:\n        iri: The IRI to be split.\n\n    Returns:\n        A split IRI. Split into namespace and name.\n\n    \"\"\"\n    if \"#\" in iri:\n        namespace, name = iri.rsplit(\"#\", 1)\n        return f\"{namespace}#\", name\n\n    if \"/\" in iri:\n        namespace, name = iri.rsplit(\"/\", 1)\n        return f\"{namespace}/\", name\n\n    raise ValueError(\"all IRIs should contain a slash\")\n</code></pre>"},{"location":"api_reference/backends/collection/","title":"collection","text":"<p>Backend for DLite collections.</p>"},{"location":"api_reference/backends/collection/#tripper.backends.collection.CollectionStrategy","title":"<code> CollectionStrategy        </code>","text":"<p>Triplestore strategy for DLite collections.</p> <p>Parameters:</p> Name Type Description Default <code>base_iri</code> <code>Optional[str]</code> <p>Unused.</p> <code>None</code> <code>database</code> <code>Optional[str]</code> <p>Unused - collection does not support multiple databases.</p> <code>None</code> <code>collection</code> <code>Optional[Union[dlite.Collection, str]]</code> <p>Optional collection from which to initialise the triplestore from.</p> <code>None</code> Source code in <code>tripper/backends/collection.py</code> <pre><code>class CollectionStrategy:\n\"\"\"Triplestore strategy for DLite collections.\n\n    Arguments:\n        base_iri: Unused.\n        database: Unused - collection does not support multiple databases.\n        collection: Optional collection from which to initialise the\n            triplestore from.\n    \"\"\"\n\n    def __init__(\n        self,\n        base_iri: \"Optional[str]\" = None,\n        database: \"Optional[str]\" = None,\n        collection: \"Optional[Union[dlite.Collection, str]]\" = None,\n    ):\n        # pylint: disable=unused-argument\n        if collection is None:\n            self.collection = dlite.Collection()\n        elif isinstance(collection, str):\n            self.collection = dlite.get_instance(collection)\n            if self.collection.meta.uri != dlite.COLLECTION_ENTITY:\n                raise TypeError(\n                    f\"expected '{collection}' to be a collection, was a \"\n                    f\"{self.collection.meta.uri}\"\n                )\n        elif isinstance(collection, dlite.Collection):\n            self.collection = collection\n        else:\n            raise TypeError(\"`collection` should be None, string or a collection\")\n\n    def triples(self, triple: \"Triple\") -&gt; \"Generator[Triple, None, None]\":\n\"\"\"Returns a generator over matching triples.\"\"\"\n        for s, p, o in self.collection.get_relations(*triple):\n            yield s, p, parse_object(o)\n\n    def add_triples(self, triples: \"Sequence[Triple]\"):\n\"\"\"Add a sequence of triples.\"\"\"\n        for s, p, o in triples:\n            v = parse_object(o)\n            v_str = v.n3() if isinstance(v, Literal) else v\n            self.collection.add_relation(s, p, v_str)\n\n    def remove(self, triple: \"Triple\"):\n\"\"\"Remove all matching triples from the backend.\"\"\"\n        s, p, o = triple\n        v = parse_object(o)\n        v_str = v.n3() if isinstance(v, Literal) else v\n        self.collection.remove_relations(s, p, v_str)\n</code></pre>"},{"location":"api_reference/backends/collection/#tripper.backends.collection.CollectionStrategy.add_triples","title":"<code>add_triples(self, triples)</code>","text":"<p>Add a sequence of triples.</p> Source code in <code>tripper/backends/collection.py</code> <pre><code>def add_triples(self, triples: \"Sequence[Triple]\"):\n\"\"\"Add a sequence of triples.\"\"\"\n    for s, p, o in triples:\n        v = parse_object(o)\n        v_str = v.n3() if isinstance(v, Literal) else v\n        self.collection.add_relation(s, p, v_str)\n</code></pre>"},{"location":"api_reference/backends/collection/#tripper.backends.collection.CollectionStrategy.remove","title":"<code>remove(self, triple)</code>","text":"<p>Remove all matching triples from the backend.</p> Source code in <code>tripper/backends/collection.py</code> <pre><code>def remove(self, triple: \"Triple\"):\n\"\"\"Remove all matching triples from the backend.\"\"\"\n    s, p, o = triple\n    v = parse_object(o)\n    v_str = v.n3() if isinstance(v, Literal) else v\n    self.collection.remove_relations(s, p, v_str)\n</code></pre>"},{"location":"api_reference/backends/collection/#tripper.backends.collection.CollectionStrategy.triples","title":"<code>triples(self, triple)</code>","text":"<p>Returns a generator over matching triples.</p> Source code in <code>tripper/backends/collection.py</code> <pre><code>def triples(self, triple: \"Triple\") -&gt; \"Generator[Triple, None, None]\":\n\"\"\"Returns a generator over matching triples.\"\"\"\n    for s, p, o in self.collection.get_relations(*triple):\n        yield s, p, parse_object(o)\n</code></pre>"},{"location":"api_reference/backends/ontopy/","title":"ontopy","text":"<p>Backend for EMMOntoPy.</p> <p>For developers: The usage of <code>s</code>, <code>p</code>, and <code>o</code> represent the different parts of an RDF Triple: subject, predicate, and object.</p>"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy","title":"<code> OntopyStrategy        </code>","text":"<p>Triplestore strategy for EMMOntoPy.</p> <p>Parameters:</p> Name Type Description Default <code>base_iri</code> <code>Optional[str]</code> <p>The base iri of the ontology. Default to \"http://example.com/onto#\" if <code>onto</code> is not given.</p> <code>None</code> <code>database</code> <code>Optional[str]</code> <p>Unused - ontopy does not support multiple databases.</p> <code>None</code> <code>onto</code> <code>Optional[Ontology]</code> <p>Ontology to initiate the triplestore from.  Defaults to an new ontology with the given <code>base_iri</code>.</p> <code>None</code> <code>load</code> <code>bool</code> <p>Whether to load the ontology.</p> <code>False</code> <code>kwargs</code> <p>Keyword arguments passed to the ontology load() method.</p> <code>{}</code> <p>Either the <code>base_iri</code> or <code>onto</code> argument must be provided.</p> Source code in <code>tripper/backends/ontopy.py</code> <pre><code>class OntopyStrategy:\n\"\"\"Triplestore strategy for EMMOntoPy.\n\n    Arguments:\n        base_iri: The base iri of the ontology.\n            Default to \"http://example.com/onto#\" if `onto` is not given.\n        database: Unused - ontopy does not support multiple databases.\n        onto: Ontology to initiate the triplestore from.  Defaults to an new\n            ontology with the given `base_iri`.\n        load: Whether to load the ontology.\n        kwargs: Keyword arguments passed to the ontology load() method.\n\n    Either the `base_iri` or `onto` argument must be provided.\n    \"\"\"\n\n    def __init__(\n        self,\n        base_iri: \"Optional[str]\" = None,\n        database: \"Optional[str]\" = None,\n        onto: \"Optional[Ontology]\" = None,\n        load: bool = False,\n        **kwargs,\n    ):\n        # pylint: disable=unused-argument\n        if onto is None:\n            if base_iri is None:\n                base_iri = \"http://example.com/onto#\"\n            self.onto = get_ontology(base_iri)\n        elif isinstance(onto, Ontology):\n            self.onto = onto\n        else:\n            raise TypeError(\"`onto` must be either an ontology or None\")\n\n        if load:\n            self.onto.load(**kwargs)\n\n    def triples(self, triple: \"Triple\") -&gt; \"Generator[Triple, None, None]\":\n\"\"\"Returns a generator over matching triples.\"\"\"\n\n        def to_literal(o, datatype) -&gt; Literal:\n\"\"\"Returns a literal from (o, datatype).\"\"\"\n            if isinstance(datatype, str) and datatype.startswith(\"@\"):\n                return Literal(o, lang=datatype[1:], datatype=None)\n            return Literal(o, lang=None, datatype=datatype)\n\n        s, p, o = triple\n        abb = (\n            None if (s) is None else self.onto._abbreviate(s),\n            None if (p) is None else self.onto._abbreviate(p),\n            None if (o) is None else self.onto._abbreviate(o),\n        )\n        for s, p, o in self.onto._get_obj_triples_spo_spo(*abb):\n            yield (\n                _unabbreviate(self.onto, s),\n                _unabbreviate(self.onto, p),\n                _unabbreviate(self.onto, o),\n            )\n        for s, p, o, datatype in self.onto._get_data_triples_spod_spod(*abb, d=\"\"):\n            yield (\n                _unabbreviate(self.onto, s),\n                _unabbreviate(self.onto, p),\n                to_literal(o, datatype),\n            )\n\n    def add_triples(self, triples: \"Sequence[Triple]\"):\n\"\"\"Add a sequence of triples.\"\"\"\n        if TYPE_CHECKING:  # pragma: no cover\n            datatype: \"Union[int, str]\"\n        for s, p, o in triples:\n            if isinstance(o, Literal):\n                if o.lang:\n                    datatype = f\"@{o.lang}\"\n                elif o.datatype:\n                    datatype = f\"^^{o.datatype}\"\n                else:\n                    datatype = 0\n                self.onto._add_data_triple_spod(\n                    self.onto._abbreviate(s),\n                    self.onto._abbreviate(p),\n                    self.onto._abbreviate(o),\n                    datatype,\n                )\n            else:\n                self.onto._add_obj_triple_spo(\n                    self.onto._abbreviate(s),\n                    self.onto._abbreviate(p),\n                    self.onto._abbreviate(o),\n                )\n\n    def remove(self, triple: \"Triple\"):\n\"\"\"Remove all matching triples from the backend.\"\"\"\n        s, p, o = triple\n        to_remove = list(\n            self.onto._get_triples_spod_spod(\n                self.onto._abbreviate(s) if (s) is not None else None,\n                self.onto._abbreviate(p) if (s) is not None else None,\n                self.onto._abbreviate(o) if (s) is not None else None,\n            )\n        )\n        for s, p, o, datatype in to_remove:\n            if datatype:\n                self.onto._del_data_triple_spod(s, p, o, datatype)\n            else:\n                self.onto._del_obj_triple_spo(s, p, o)\n\n    # Optional methods\n    def parse(\n        self,\n        source=None,\n        location=None,\n        data=None,\n        format=None,  # pylint: disable=redefined-builtin\n        encoding=None,\n        **kwargs,\n    ):\n\"\"\"Parse source and add the resulting triples to triplestore.\n\n        The source is specified using one of `source`, `location` or `data`.\n\n        Parameters:\n            source: File-like object or file name.\n            location: String with relative or absolute URL to source.\n            data: String containing the data to be parsed.\n            format: Needed if format can not be inferred from source.\n            encoding: Encoding argument to io.open().\n            kwargs: Additional keyword arguments passed to Ontology.load().\n        \"\"\"\n        if source:\n            self.onto.load(filename=source, format=format, **kwargs)\n        elif location:\n            self.onto.load(filename=location, format=format, **kwargs)\n        elif data:\n            # s = io.StringIO(data)\n            # self.onto.load(filename=s, format=format, **kwargs)\n\n            # Could have been done much nicer if it hasn't been for Windows\n            filename = None\n            try:\n                tmpfile_options = {\"delete\": False}\n                if isinstance(data, str):\n                    tmpfile_options.update(mode=\"w+t\", encoding=encoding)\n                with tempfile.NamedTemporaryFile(**tmpfile_options) as handle:\n                    handle.write(data)\n                    filename = handle.name\n                self.onto.load(filename=filename, format=format, **kwargs)\n            finally:\n                if filename:\n                    os.remove(filename)\n\n        else:\n            raise ValueError(\"either `source`, `location` or `data` must be given\")\n\n    def serialize(\n        self,\n        destination=None,\n        format=\"turtle\",  # pylint: disable=redefined-builtin\n        **kwargs,\n    ) -&gt; \"Union[None, str]\":\n\"\"\"Serialise to destination.\n\n        Parameters:\n            destination: File name or object to write to.  If None, the\n                serialisation is returned.\n            format: Format to serialise as.  Supported formats, depends on\n                the backend.\n            kwargs: Passed to the Ontology.save() method.\n\n        Returns:\n            Serialised string if `destination` is None.\n        \"\"\"\n        if destination:\n            self.onto.save(destination, format=format, **kwargs)\n        else:\n            # Clumsy implementation due to Windows file locking...\n            filename = None\n            try:\n                with tempfile.NamedTemporaryFile(delete=False) as handle:\n                    filename = handle.name\n                    self.onto.save(filename, format=format, **kwargs)\n                with open(filename, \"rt\", encoding=\"utf8\") as handle:\n                    return handle.read()\n            finally:\n                if filename:\n                    os.remove(filename)\n        return None\n\n    def query(self, query_object, native=True, **kwargs) -&gt; \"Union[List, Result]\":\n\"\"\"SPARQL query.\n\n        Parameters:\n            query_object: String with the SPARQL query.\n            native: Whether or not to use EMMOntoPy/Owlready2 or RDFLib.\n            kwargs: Keyword arguments passed to rdflib.Graph.query().\n\n        Returns:\n            SPARQL query results.\n\n        \"\"\"\n        if TYPE_CHECKING:  # pragma: no cover\n            res: \"Union[List, Result]\"\n\n        if native:\n            res = self.onto.world.sparql(query_object)\n        else:\n            graph = self.onto.world.as_rdflib_graph()\n            res = graph.query(query_object, **kwargs)\n        # TODO: Convert result to expected type\n        return res\n\n    def update(self, update_object, native=True, **kwargs) -&gt; None:\n\"\"\"Update triplestore with SPARQL.\n\n        Parameters:\n            update_object: String with the SPARQL query.\n            native: Whether or not to use EMMOntoPy/Owlready2 or RDFLib.\n            kwargs: Keyword arguments passed to rdflib.Graph.update().\n\n        Note:\n            This method is intended for INSERT and DELETE queries. Use\n            the query() method for SELECT queries.\n\n        \"\"\"\n        if native:\n            self.onto.world.sparql(update_object)\n        else:\n            graph = self.onto.world.as_rdflib_graph()\n            graph.update(update_object, **kwargs)\n</code></pre>"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.add_triples","title":"<code>add_triples(self, triples)</code>","text":"<p>Add a sequence of triples.</p> Source code in <code>tripper/backends/ontopy.py</code> <pre><code>def add_triples(self, triples: \"Sequence[Triple]\"):\n\"\"\"Add a sequence of triples.\"\"\"\n    if TYPE_CHECKING:  # pragma: no cover\n        datatype: \"Union[int, str]\"\n    for s, p, o in triples:\n        if isinstance(o, Literal):\n            if o.lang:\n                datatype = f\"@{o.lang}\"\n            elif o.datatype:\n                datatype = f\"^^{o.datatype}\"\n            else:\n                datatype = 0\n            self.onto._add_data_triple_spod(\n                self.onto._abbreviate(s),\n                self.onto._abbreviate(p),\n                self.onto._abbreviate(o),\n                datatype,\n            )\n        else:\n            self.onto._add_obj_triple_spo(\n                self.onto._abbreviate(s),\n                self.onto._abbreviate(p),\n                self.onto._abbreviate(o),\n            )\n</code></pre>"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.parse","title":"<code>parse(self, source=None, location=None, data=None, format=None, encoding=None, **kwargs)</code>","text":"<p>Parse source and add the resulting triples to triplestore.</p> <p>The source is specified using one of <code>source</code>, <code>location</code> or <code>data</code>.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <p>File-like object or file name.</p> <code>None</code> <code>location</code> <p>String with relative or absolute URL to source.</p> <code>None</code> <code>data</code> <p>String containing the data to be parsed.</p> <code>None</code> <code>format</code> <p>Needed if format can not be inferred from source.</p> <code>None</code> <code>encoding</code> <p>Encoding argument to io.open().</p> <code>None</code> <code>kwargs</code> <p>Additional keyword arguments passed to Ontology.load().</p> <code>{}</code> Source code in <code>tripper/backends/ontopy.py</code> <pre><code>def parse(\n    self,\n    source=None,\n    location=None,\n    data=None,\n    format=None,  # pylint: disable=redefined-builtin\n    encoding=None,\n    **kwargs,\n):\n\"\"\"Parse source and add the resulting triples to triplestore.\n\n    The source is specified using one of `source`, `location` or `data`.\n\n    Parameters:\n        source: File-like object or file name.\n        location: String with relative or absolute URL to source.\n        data: String containing the data to be parsed.\n        format: Needed if format can not be inferred from source.\n        encoding: Encoding argument to io.open().\n        kwargs: Additional keyword arguments passed to Ontology.load().\n    \"\"\"\n    if source:\n        self.onto.load(filename=source, format=format, **kwargs)\n    elif location:\n        self.onto.load(filename=location, format=format, **kwargs)\n    elif data:\n        # s = io.StringIO(data)\n        # self.onto.load(filename=s, format=format, **kwargs)\n\n        # Could have been done much nicer if it hasn't been for Windows\n        filename = None\n        try:\n            tmpfile_options = {\"delete\": False}\n            if isinstance(data, str):\n                tmpfile_options.update(mode=\"w+t\", encoding=encoding)\n            with tempfile.NamedTemporaryFile(**tmpfile_options) as handle:\n                handle.write(data)\n                filename = handle.name\n            self.onto.load(filename=filename, format=format, **kwargs)\n        finally:\n            if filename:\n                os.remove(filename)\n\n    else:\n        raise ValueError(\"either `source`, `location` or `data` must be given\")\n</code></pre>"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.query","title":"<code>query(self, query_object, native=True, **kwargs)</code>","text":"<p>SPARQL query.</p> <p>Parameters:</p> Name Type Description Default <code>query_object</code> <p>String with the SPARQL query.</p> required <code>native</code> <p>Whether or not to use EMMOntoPy/Owlready2 or RDFLib.</p> <code>True</code> <code>kwargs</code> <p>Keyword arguments passed to rdflib.Graph.query().</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[List, Result]</code> <p>SPARQL query results.</p> Source code in <code>tripper/backends/ontopy.py</code> <pre><code>def query(self, query_object, native=True, **kwargs) -&gt; \"Union[List, Result]\":\n\"\"\"SPARQL query.\n\n    Parameters:\n        query_object: String with the SPARQL query.\n        native: Whether or not to use EMMOntoPy/Owlready2 or RDFLib.\n        kwargs: Keyword arguments passed to rdflib.Graph.query().\n\n    Returns:\n        SPARQL query results.\n\n    \"\"\"\n    if TYPE_CHECKING:  # pragma: no cover\n        res: \"Union[List, Result]\"\n\n    if native:\n        res = self.onto.world.sparql(query_object)\n    else:\n        graph = self.onto.world.as_rdflib_graph()\n        res = graph.query(query_object, **kwargs)\n    # TODO: Convert result to expected type\n    return res\n</code></pre>"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.remove","title":"<code>remove(self, triple)</code>","text":"<p>Remove all matching triples from the backend.</p> Source code in <code>tripper/backends/ontopy.py</code> <pre><code>def remove(self, triple: \"Triple\"):\n\"\"\"Remove all matching triples from the backend.\"\"\"\n    s, p, o = triple\n    to_remove = list(\n        self.onto._get_triples_spod_spod(\n            self.onto._abbreviate(s) if (s) is not None else None,\n            self.onto._abbreviate(p) if (s) is not None else None,\n            self.onto._abbreviate(o) if (s) is not None else None,\n        )\n    )\n    for s, p, o, datatype in to_remove:\n        if datatype:\n            self.onto._del_data_triple_spod(s, p, o, datatype)\n        else:\n            self.onto._del_obj_triple_spo(s, p, o)\n</code></pre>"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.serialize","title":"<code>serialize(self, destination=None, format='turtle', **kwargs)</code>","text":"<p>Serialise to destination.</p> <p>Parameters:</p> Name Type Description Default <code>destination</code> <p>File name or object to write to.  If None, the serialisation is returned.</p> <code>None</code> <code>format</code> <p>Format to serialise as.  Supported formats, depends on the backend.</p> <code>'turtle'</code> <code>kwargs</code> <p>Passed to the Ontology.save() method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[None, str]</code> <p>Serialised string if <code>destination</code> is None.</p> Source code in <code>tripper/backends/ontopy.py</code> <pre><code>def serialize(\n    self,\n    destination=None,\n    format=\"turtle\",  # pylint: disable=redefined-builtin\n    **kwargs,\n) -&gt; \"Union[None, str]\":\n\"\"\"Serialise to destination.\n\n    Parameters:\n        destination: File name or object to write to.  If None, the\n            serialisation is returned.\n        format: Format to serialise as.  Supported formats, depends on\n            the backend.\n        kwargs: Passed to the Ontology.save() method.\n\n    Returns:\n        Serialised string if `destination` is None.\n    \"\"\"\n    if destination:\n        self.onto.save(destination, format=format, **kwargs)\n    else:\n        # Clumsy implementation due to Windows file locking...\n        filename = None\n        try:\n            with tempfile.NamedTemporaryFile(delete=False) as handle:\n                filename = handle.name\n                self.onto.save(filename, format=format, **kwargs)\n            with open(filename, \"rt\", encoding=\"utf8\") as handle:\n                return handle.read()\n        finally:\n            if filename:\n                os.remove(filename)\n    return None\n</code></pre>"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.triples","title":"<code>triples(self, triple)</code>","text":"<p>Returns a generator over matching triples.</p> Source code in <code>tripper/backends/ontopy.py</code> <pre><code>def triples(self, triple: \"Triple\") -&gt; \"Generator[Triple, None, None]\":\n\"\"\"Returns a generator over matching triples.\"\"\"\n\n    def to_literal(o, datatype) -&gt; Literal:\n\"\"\"Returns a literal from (o, datatype).\"\"\"\n        if isinstance(datatype, str) and datatype.startswith(\"@\"):\n            return Literal(o, lang=datatype[1:], datatype=None)\n        return Literal(o, lang=None, datatype=datatype)\n\n    s, p, o = triple\n    abb = (\n        None if (s) is None else self.onto._abbreviate(s),\n        None if (p) is None else self.onto._abbreviate(p),\n        None if (o) is None else self.onto._abbreviate(o),\n    )\n    for s, p, o in self.onto._get_obj_triples_spo_spo(*abb):\n        yield (\n            _unabbreviate(self.onto, s),\n            _unabbreviate(self.onto, p),\n            _unabbreviate(self.onto, o),\n        )\n    for s, p, o, datatype in self.onto._get_data_triples_spod_spod(*abb, d=\"\"):\n        yield (\n            _unabbreviate(self.onto, s),\n            _unabbreviate(self.onto, p),\n            to_literal(o, datatype),\n        )\n</code></pre>"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.update","title":"<code>update(self, update_object, native=True, **kwargs)</code>","text":"<p>Update triplestore with SPARQL.</p> <p>Parameters:</p> Name Type Description Default <code>update_object</code> <p>String with the SPARQL query.</p> required <code>native</code> <p>Whether or not to use EMMOntoPy/Owlready2 or RDFLib.</p> <code>True</code> <code>kwargs</code> <p>Keyword arguments passed to rdflib.Graph.update().</p> <code>{}</code> <p>Note</p> <p>This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries.</p> Source code in <code>tripper/backends/ontopy.py</code> <pre><code>def update(self, update_object, native=True, **kwargs) -&gt; None:\n\"\"\"Update triplestore with SPARQL.\n\n    Parameters:\n        update_object: String with the SPARQL query.\n        native: Whether or not to use EMMOntoPy/Owlready2 or RDFLib.\n        kwargs: Keyword arguments passed to rdflib.Graph.update().\n\n    Note:\n        This method is intended for INSERT and DELETE queries. Use\n        the query() method for SELECT queries.\n\n    \"\"\"\n    if native:\n        self.onto.world.sparql(update_object)\n    else:\n        graph = self.onto.world.as_rdflib_graph()\n        graph.update(update_object, **kwargs)\n</code></pre>"},{"location":"api_reference/backends/rdflib/","title":"rdflib","text":"<p>Backend for RDFLib.</p> <p>For developers: The usage of <code>s</code>, <code>p</code>, and <code>o</code> represent the different parts of an RDF Triple: subject, predicate, and object.</p>"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy","title":"<code> RdflibStrategy        </code>","text":"<p>Triplestore strategy for rdflib.</p> <p>Parameters:</p> Name Type Description Default <code>base_iri</code> <code>Optional[str]</code> <p>Unused by this backend.</p> <code>None</code> <code>database</code> <code>Optional[str]</code> <p>Unused - rdflib does not support multiple databases.</p> <code>None</code> <code>triplestore_url</code> <code>Optional[str]</code> <p>If given, initialise the triplestore from this storage.  When <code>close()</code> is called, the storage will be overwritten with the current content of the triplestore.</p> <code>None</code> <code>format</code> <code>Optional[str]</code> <p>Format of storage specified with <code>base_iri</code>.</p> <code>None</code> Source code in <code>tripper/backends/rdflib.py</code> <pre><code>class RdflibStrategy:\n\"\"\"Triplestore strategy for rdflib.\n\n    Arguments:\n        base_iri: Unused by this backend.\n        database: Unused - rdflib does not support multiple databases.\n        triplestore_url: If given, initialise the triplestore from this\n            storage.  When `close()` is called, the storage will be\n            overwritten with the current content of the triplestore.\n        format: Format of storage specified with `base_iri`.\n    \"\"\"\n\n    def __init__(\n        self,\n        base_iri: \"Optional[str]\" = None,\n        database: \"Optional[str]\" = None,\n        triplestore_url: \"Optional[str]\" = None,\n        format: \"Optional[str]\" = None,  # pylint: disable=redefined-builtin\n    ) -&gt; None:\n        if base_iri:\n            warnings.warn(\"base_iri\", UnusedArgumentWarning, stacklevel=2)\n        if database:\n            warnings.warn(\"database\", UnusedArgumentWarning, stacklevel=2)\n\n        self.graph = Graph()\n        self.triplestore_url = triplestore_url\n        if self.triplestore_url is not None:\n            if format is None:\n                format = guess_format(self.triplestore_url)\n            self.parse(location=self.triplestore_url, format=format)\n        self.base_format = format\n\n    def triples(self, triple: \"Triple\") -&gt; \"Generator[Triple, None, None]\":\n\"\"\"Returns a generator over matching triples.\"\"\"\n        for s, p, o in self.graph.triples(  # pylint: disable=not-an-iterable\n            astriple(triple)\n        ):\n            yield (\n                str(s),\n                str(p),\n                Literal(\n                    o.value,\n                    lang=o.language,\n                    datatype=str(o.datatype) if o.datatype else o.datatype,\n                )\n                if isinstance(o, rdflibLiteral)\n                else str(o),\n            )\n\n    def add_triples(self, triples: \"Sequence[Triple]\"):\n\"\"\"Add a sequence of triples.\"\"\"\n        for triple in triples:\n            self.graph.add(astriple(triple))\n\n    def remove(self, triple: \"Triple\"):\n\"\"\"Remove all matching triples from the backend.\"\"\"\n        self.graph.remove(astriple(triple))\n\n    # Optional methods\n    def close(self):\n\"\"\"Close the internal RDFLib graph.\"\"\"\n        if self.triplestore_url:\n            self.serialize(destination=self.triplestore_url, format=self.base_format)\n        self.graph.close()\n\n    def parse(\n        self,\n        source=None,\n        location=None,\n        data=None,\n        format=None,  # pylint: disable=redefined-builtin\n        **kwargs,\n    ):\n\"\"\"Parse source and add the resulting triples to triplestore.\n\n        The source is specified using one of `source`, `location` or `data`.\n\n        Parameters:\n            source: File-like object or file name.\n            location: String with relative or absolute URL to source.\n            data: String containing the data to be parsed.\n            format: Needed if format can not be inferred from source.\n            kwargs: Additional less used keyword arguments.\n                See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.parse\n        \"\"\"\n        self.graph.parse(\n            source=source, location=location, data=data, format=format, **kwargs\n        )\n\n    def serialize(\n        self,\n        destination=None,\n        format=\"turtle\",  # pylint: disable=redefined-builtin\n        **kwargs,\n    ) -&gt; \"Union[None, str]\":\n\"\"\"Serialise to destination.\n\n        Parameters:\n            destination: File name or object to write to. If None, the serialisation is\n                returned.\n            format: Format to serialise as. Supported formats, depends on the backend.\n            kwargs: Passed to the rdflib.Graph.serialize() method.\n                See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.serialize\n\n        Returns:\n            Serialised string if `destination` is None.\n        \"\"\"\n        result = self.graph.serialize(destination=destination, format=format, **kwargs)\n        if destination is None:\n            # Depending on the version of rdflib the return value of\n            # graph.serialize() man either be a string or a bytes object...\n            return result if isinstance(result, str) else result.decode()\n        return None\n\n    def query(self, query_object, **kwargs) -&gt; \"List[Tuple[str, ...]]\":\n\"\"\"SPARQL query.\n\n        Parameters:\n            query_object: String with the SPARQL query.\n            kwargs: Keyword arguments passed to rdflib.Graph.query().\n\n        Returns:\n            List of tuples of IRIs for each matching row.\n\n        \"\"\"\n        rows = self.graph.query(query_object=query_object, **kwargs)\n        return [tuple(str(v) for v in row) for row in rows]\n\n    def update(self, update_object, **kwargs) -&gt; None:\n\"\"\"Update triplestore with SPARQL.\n\n        Parameters:\n            update_object: String with the SPARQL query.\n            kwargs: Keyword arguments passed to rdflib.Graph.update().\n\n        Note:\n            This method is intended for INSERT and DELETE queries. Use\n            the query() method for SELECT queries.\n\n        \"\"\"\n        return self.graph.update(update_object=update_object, **kwargs)\n\n    def bind(self, prefix: str, namespace: str):\n\"\"\"Bind prefix to namespace.\n\n        Should only be defined if the backend supports namespaces.\n        Called by triplestore.bind().\n        \"\"\"\n        if namespace:\n            self.graph.bind(prefix, namespace, replace=True)\n        else:\n            warnings.warn(\"rdflib does not support removing namespace prefixes\")\n\n    def namespaces(self) -&gt; dict:\n\"\"\"Returns a dict mapping prefixes to namespaces.\n\n        Should only be defined if the backend supports namespaces.\n        Used by triplestore.parse() to get prefixes after reading\n        triples from an external source.\n        \"\"\"\n        return {prefix: str(namespace) for prefix, namespace in self.graph.namespaces()}\n</code></pre>"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.add_triples","title":"<code>add_triples(self, triples)</code>","text":"<p>Add a sequence of triples.</p> Source code in <code>tripper/backends/rdflib.py</code> <pre><code>def add_triples(self, triples: \"Sequence[Triple]\"):\n\"\"\"Add a sequence of triples.\"\"\"\n    for triple in triples:\n        self.graph.add(astriple(triple))\n</code></pre>"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.bind","title":"<code>bind(self, prefix, namespace)</code>","text":"<p>Bind prefix to namespace.</p> <p>Should only be defined if the backend supports namespaces. Called by triplestore.bind().</p> Source code in <code>tripper/backends/rdflib.py</code> <pre><code>def bind(self, prefix: str, namespace: str):\n\"\"\"Bind prefix to namespace.\n\n    Should only be defined if the backend supports namespaces.\n    Called by triplestore.bind().\n    \"\"\"\n    if namespace:\n        self.graph.bind(prefix, namespace, replace=True)\n    else:\n        warnings.warn(\"rdflib does not support removing namespace prefixes\")\n</code></pre>"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.close","title":"<code>close(self)</code>","text":"<p>Close the internal RDFLib graph.</p> Source code in <code>tripper/backends/rdflib.py</code> <pre><code>def close(self):\n\"\"\"Close the internal RDFLib graph.\"\"\"\n    if self.triplestore_url:\n        self.serialize(destination=self.triplestore_url, format=self.base_format)\n    self.graph.close()\n</code></pre>"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.namespaces","title":"<code>namespaces(self)</code>","text":"<p>Returns a dict mapping prefixes to namespaces.</p> <p>Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source.</p> Source code in <code>tripper/backends/rdflib.py</code> <pre><code>def namespaces(self) -&gt; dict:\n\"\"\"Returns a dict mapping prefixes to namespaces.\n\n    Should only be defined if the backend supports namespaces.\n    Used by triplestore.parse() to get prefixes after reading\n    triples from an external source.\n    \"\"\"\n    return {prefix: str(namespace) for prefix, namespace in self.graph.namespaces()}\n</code></pre>"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.parse","title":"<code>parse(self, source=None, location=None, data=None, format=None, **kwargs)</code>","text":"<p>Parse source and add the resulting triples to triplestore.</p> <p>The source is specified using one of <code>source</code>, <code>location</code> or <code>data</code>.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <p>File-like object or file name.</p> <code>None</code> <code>location</code> <p>String with relative or absolute URL to source.</p> <code>None</code> <code>data</code> <p>String containing the data to be parsed.</p> <code>None</code> <code>format</code> <p>Needed if format can not be inferred from source.</p> <code>None</code> <code>kwargs</code> <p>Additional less used keyword arguments. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.parse</p> <code>{}</code> Source code in <code>tripper/backends/rdflib.py</code> <pre><code>def parse(\n    self,\n    source=None,\n    location=None,\n    data=None,\n    format=None,  # pylint: disable=redefined-builtin\n    **kwargs,\n):\n\"\"\"Parse source and add the resulting triples to triplestore.\n\n    The source is specified using one of `source`, `location` or `data`.\n\n    Parameters:\n        source: File-like object or file name.\n        location: String with relative or absolute URL to source.\n        data: String containing the data to be parsed.\n        format: Needed if format can not be inferred from source.\n        kwargs: Additional less used keyword arguments.\n            See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.parse\n    \"\"\"\n    self.graph.parse(\n        source=source, location=location, data=data, format=format, **kwargs\n    )\n</code></pre>"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.query","title":"<code>query(self, query_object, **kwargs)</code>","text":"<p>SPARQL query.</p> <p>Parameters:</p> Name Type Description Default <code>query_object</code> <p>String with the SPARQL query.</p> required <code>kwargs</code> <p>Keyword arguments passed to rdflib.Graph.query().</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[Tuple[str, ...]]</code> <p>List of tuples of IRIs for each matching row.</p> Source code in <code>tripper/backends/rdflib.py</code> <pre><code>def query(self, query_object, **kwargs) -&gt; \"List[Tuple[str, ...]]\":\n\"\"\"SPARQL query.\n\n    Parameters:\n        query_object: String with the SPARQL query.\n        kwargs: Keyword arguments passed to rdflib.Graph.query().\n\n    Returns:\n        List of tuples of IRIs for each matching row.\n\n    \"\"\"\n    rows = self.graph.query(query_object=query_object, **kwargs)\n    return [tuple(str(v) for v in row) for row in rows]\n</code></pre>"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.remove","title":"<code>remove(self, triple)</code>","text":"<p>Remove all matching triples from the backend.</p> Source code in <code>tripper/backends/rdflib.py</code> <pre><code>def remove(self, triple: \"Triple\"):\n\"\"\"Remove all matching triples from the backend.\"\"\"\n    self.graph.remove(astriple(triple))\n</code></pre>"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.serialize","title":"<code>serialize(self, destination=None, format='turtle', **kwargs)</code>","text":"<p>Serialise to destination.</p> <p>Parameters:</p> Name Type Description Default <code>destination</code> <p>File name or object to write to. If None, the serialisation is returned.</p> <code>None</code> <code>format</code> <p>Format to serialise as. Supported formats, depends on the backend.</p> <code>'turtle'</code> <code>kwargs</code> <p>Passed to the rdflib.Graph.serialize() method. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.serialize</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[None, str]</code> <p>Serialised string if <code>destination</code> is None.</p> Source code in <code>tripper/backends/rdflib.py</code> <pre><code>def serialize(\n    self,\n    destination=None,\n    format=\"turtle\",  # pylint: disable=redefined-builtin\n    **kwargs,\n) -&gt; \"Union[None, str]\":\n\"\"\"Serialise to destination.\n\n    Parameters:\n        destination: File name or object to write to. If None, the serialisation is\n            returned.\n        format: Format to serialise as. Supported formats, depends on the backend.\n        kwargs: Passed to the rdflib.Graph.serialize() method.\n            See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.serialize\n\n    Returns:\n        Serialised string if `destination` is None.\n    \"\"\"\n    result = self.graph.serialize(destination=destination, format=format, **kwargs)\n    if destination is None:\n        # Depending on the version of rdflib the return value of\n        # graph.serialize() man either be a string or a bytes object...\n        return result if isinstance(result, str) else result.decode()\n    return None\n</code></pre>"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.triples","title":"<code>triples(self, triple)</code>","text":"<p>Returns a generator over matching triples.</p> Source code in <code>tripper/backends/rdflib.py</code> <pre><code>def triples(self, triple: \"Triple\") -&gt; \"Generator[Triple, None, None]\":\n\"\"\"Returns a generator over matching triples.\"\"\"\n    for s, p, o in self.graph.triples(  # pylint: disable=not-an-iterable\n        astriple(triple)\n    ):\n        yield (\n            str(s),\n            str(p),\n            Literal(\n                o.value,\n                lang=o.language,\n                datatype=str(o.datatype) if o.datatype else o.datatype,\n            )\n            if isinstance(o, rdflibLiteral)\n            else str(o),\n        )\n</code></pre>"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.update","title":"<code>update(self, update_object, **kwargs)</code>","text":"<p>Update triplestore with SPARQL.</p> <p>Parameters:</p> Name Type Description Default <code>update_object</code> <p>String with the SPARQL query.</p> required <code>kwargs</code> <p>Keyword arguments passed to rdflib.Graph.update().</p> <code>{}</code> <p>Note</p> <p>This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries.</p> Source code in <code>tripper/backends/rdflib.py</code> <pre><code>def update(self, update_object, **kwargs) -&gt; None:\n\"\"\"Update triplestore with SPARQL.\n\n    Parameters:\n        update_object: String with the SPARQL query.\n        kwargs: Keyword arguments passed to rdflib.Graph.update().\n\n    Note:\n        This method is intended for INSERT and DELETE queries. Use\n        the query() method for SELECT queries.\n\n    \"\"\"\n    return self.graph.update(update_object=update_object, **kwargs)\n</code></pre>"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.astriple","title":"<code>astriple(triple)</code>","text":"<p>Help function converting a triple to rdflib triple.</p> Source code in <code>tripper/backends/rdflib.py</code> <pre><code>def astriple(triple: \"Triple\"):\n\"\"\"Help function converting a triple to rdflib triple.\"\"\"\n    s, p, o = triple\n    return asuri(s), asuri(p), asuri(o)\n</code></pre>"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.asuri","title":"<code>asuri(value)</code>","text":"<p>Help function converting a spo-value to proper rdflib type.</p> Source code in <code>tripper/backends/rdflib.py</code> <pre><code>def asuri(value: \"Union[None, Literal, str]\"):\n\"\"\"Help function converting a spo-value to proper rdflib type.\"\"\"\n    if value is None:\n        return None\n    if isinstance(value, Literal):\n        return rdflibLiteral(value.value, lang=value.lang, datatype=value.datatype)\n    if value.startswith(\"_:\"):\n        return BNode(value)\n    return URIRef(value)\n</code></pre>"},{"location":"api_reference/backends/sparqlwrapper/","title":"sparqlwrapper","text":"<p>Backend for SPARQLWrapper</p>"},{"location":"api_reference/backends/sparqlwrapper/#tripper.backends.sparqlwrapper.SparqlwrapperStrategy","title":"<code> SparqlwrapperStrategy        </code>","text":"<p>Triplestore strategy for SPARQLWrapper.</p> <p>Parameters:</p> Name Type Description Default <code>base_iri</code> <code>str</code> <p>URI of SPARQL endpoint.</p> required <code>kwargs</code> <p>Additional arguments passed to the SPARQLWrapper constructor.</p> <code>{}</code> Source code in <code>tripper/backends/sparqlwrapper.py</code> <pre><code>class SparqlwrapperStrategy:\n\"\"\"Triplestore strategy for SPARQLWrapper.\n\n    Arguments:\n        base_iri: URI of SPARQL endpoint.\n        kwargs: Additional arguments passed to the SPARQLWrapper constructor.\n\n    \"\"\"\n\n    def __init__(self, base_iri: str, **kwargs) -&gt; None:\n        kwargs.pop(\n            \"database\", None\n        )  # database is not used in the SPARQLWrapper backend\n        self.sparql = SPARQLWrapper(endpoint=base_iri, **kwargs)\n\n    def triples(self, triple: \"Triple\") -&gt; \"Generator[Triple, None, None]\":\n\"\"\"Returns a generator over matching triples.\"\"\"\n        variables = [\n            f\"?{triple_name}\"\n            for triple_name, triple_value in zip(\"spo\", triple)\n            if triple_value is None\n        ]\n        where_spec = \" \".join(\n            f\"?{triple_name}\"\n            if triple_value is None\n            else triple_value\n            if triple_value.startswith(\"&lt;\")\n            else f\"&lt;{triple_value}&gt;\"\n            for triple_name, triple_value in zip(\"spo\", triple)\n        )\n        query = \"\\n\".join(\n            [\n                f\"SELECT {' '.join(variables)} WHERE {{\",\n                f\"  {where_spec} .\",\n                \"}\",\n            ]\n        )\n        self.sparql.setReturnFormat(JSON)\n        self.sparql.setMethod(GET)\n        self.sparql.setQuery(query)\n        ret = self.sparql.queryAndConvert()\n        for binding in ret[\"results\"][\"bindings\"]:\n            yield tuple(\n                convert_json_entrydict(binding[name]) if name in binding else value\n                for name, value in zip(\"spo\", triple)\n            )\n\n    def add_triples(self, triples: \"Sequence[Triple]\") -&gt; \"QueryResult\":\n\"\"\"Add a sequence of triples.\"\"\"\n        spec = \"\\n\".join(\n            \"  \"\n            + \" \".join(\n                value.n3()\n                if isinstance(value, Literal)\n                else value\n                if value.startswith(\"&lt;\")\n                else f\"&lt;{value}&gt;\"\n                for value in triple\n            )\n            + \" .\"\n            for triple in triples\n        )\n        query = f\"INSERT DATA {{\\n{spec}\\n}}\"\n        self.sparql.setReturnFormat(RDFXML)\n        self.sparql.setMethod(POST)\n        self.sparql.setQuery(query)\n        return self.sparql.query()\n\n    def remove(self, triple: \"Triple\") -&gt; \"QueryResult\":\n\"\"\"Remove all matching triples from the backend.\"\"\"\n        spec = \" \".join(\n            f\"?{name}\"\n            if value is None\n            else value.n3()\n            if isinstance(value, Literal)\n            else value\n            if value.startswith(\"&lt;\")\n            else f\"&lt;{value}&gt;\"\n            for name, value in zip(\"spo\", triple)\n        )\n        query = f\"DELETE {{ {spec} }}\"\n        self.sparql.setReturnFormat(RDFXML)\n        self.sparql.setMethod(POST)\n        self.sparql.setQuery(query)\n        return self.sparql.query()\n</code></pre>"},{"location":"api_reference/backends/sparqlwrapper/#tripper.backends.sparqlwrapper.SparqlwrapperStrategy.add_triples","title":"<code>add_triples(self, triples)</code>","text":"<p>Add a sequence of triples.</p> Source code in <code>tripper/backends/sparqlwrapper.py</code> <pre><code>def add_triples(self, triples: \"Sequence[Triple]\") -&gt; \"QueryResult\":\n\"\"\"Add a sequence of triples.\"\"\"\n    spec = \"\\n\".join(\n        \"  \"\n        + \" \".join(\n            value.n3()\n            if isinstance(value, Literal)\n            else value\n            if value.startswith(\"&lt;\")\n            else f\"&lt;{value}&gt;\"\n            for value in triple\n        )\n        + \" .\"\n        for triple in triples\n    )\n    query = f\"INSERT DATA {{\\n{spec}\\n}}\"\n    self.sparql.setReturnFormat(RDFXML)\n    self.sparql.setMethod(POST)\n    self.sparql.setQuery(query)\n    return self.sparql.query()\n</code></pre>"},{"location":"api_reference/backends/sparqlwrapper/#tripper.backends.sparqlwrapper.SparqlwrapperStrategy.remove","title":"<code>remove(self, triple)</code>","text":"<p>Remove all matching triples from the backend.</p> Source code in <code>tripper/backends/sparqlwrapper.py</code> <pre><code>def remove(self, triple: \"Triple\") -&gt; \"QueryResult\":\n\"\"\"Remove all matching triples from the backend.\"\"\"\n    spec = \" \".join(\n        f\"?{name}\"\n        if value is None\n        else value.n3()\n        if isinstance(value, Literal)\n        else value\n        if value.startswith(\"&lt;\")\n        else f\"&lt;{value}&gt;\"\n        for name, value in zip(\"spo\", triple)\n    )\n    query = f\"DELETE {{ {spec} }}\"\n    self.sparql.setReturnFormat(RDFXML)\n    self.sparql.setMethod(POST)\n    self.sparql.setQuery(query)\n    return self.sparql.query()\n</code></pre>"},{"location":"api_reference/backends/sparqlwrapper/#tripper.backends.sparqlwrapper.SparqlwrapperStrategy.triples","title":"<code>triples(self, triple)</code>","text":"<p>Returns a generator over matching triples.</p> Source code in <code>tripper/backends/sparqlwrapper.py</code> <pre><code>def triples(self, triple: \"Triple\") -&gt; \"Generator[Triple, None, None]\":\n\"\"\"Returns a generator over matching triples.\"\"\"\n    variables = [\n        f\"?{triple_name}\"\n        for triple_name, triple_value in zip(\"spo\", triple)\n        if triple_value is None\n    ]\n    where_spec = \" \".join(\n        f\"?{triple_name}\"\n        if triple_value is None\n        else triple_value\n        if triple_value.startswith(\"&lt;\")\n        else f\"&lt;{triple_value}&gt;\"\n        for triple_name, triple_value in zip(\"spo\", triple)\n    )\n    query = \"\\n\".join(\n        [\n            f\"SELECT {' '.join(variables)} WHERE {{\",\n            f\"  {where_spec} .\",\n            \"}\",\n        ]\n    )\n    self.sparql.setReturnFormat(JSON)\n    self.sparql.setMethod(GET)\n    self.sparql.setQuery(query)\n    ret = self.sparql.queryAndConvert()\n    for binding in ret[\"results\"][\"bindings\"]:\n        yield tuple(\n            convert_json_entrydict(binding[name]) if name in binding else value\n            for name, value in zip(\"spo\", triple)\n        )\n</code></pre>"},{"location":"api_reference/backends/sparqlwrapper/#tripper.backends.sparqlwrapper.convert_json_entrydict","title":"<code>convert_json_entrydict(entrydict)</code>","text":"<p>Convert SPARQLWrapper json entry dict (representing a single IRI or literal) to a tripper type.</p> Source code in <code>tripper/backends/sparqlwrapper.py</code> <pre><code>def convert_json_entrydict(entrydict: \"Dict[str, str]\") -&gt; str:\n\"\"\"Convert SPARQLWrapper json entry dict (representing a single IRI or\n    literal) to a tripper type.\"\"\"\n    if entrydict[\"type\"] == \"uri\":\n        return entrydict[\"value\"]\n\n    if entrydict[\"type\"] == \"literal\":\n        return Literal(\n            entrydict[\"value\"],\n            lang=entrydict.get(\"xml:lang\"),\n            datatype=entrydict.get(\"datatype\"),\n        )\n\n    if entrydict[\"type\"] == \"bnode\":\n        return (\n            entrydict[\"value\"]\n            if entrydict[\"value\"].startswith(\"_:\")\n            else f\"_:{entrydict['value']}\"\n        )\n\n    raise ValueError(f\"unexpected type in entrydict: {entrydict}\")\n</code></pre>"},{"location":"api_reference/mappings/mappings/","title":"mappings","text":"<p>Implements mappings between entities.</p> <p>Units are currently handled with pint.Quantity.  The benefit of this compared to explicit unit conversions, is that units will be handled transparently by mapping functions, without any need to specify units of input and output parameters.</p> <p>Shapes are automatically handled by expressing non-scalar quantities with numpy.</p>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.AmbiguousMappingError","title":"<code> AmbiguousMappingError            (MappingError)         </code>","text":"<p>A property maps to more than one value.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>class AmbiguousMappingError(MappingError):\n\"\"\"A property maps to more than one value.\"\"\"\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.InconsistentDimensionError","title":"<code> InconsistentDimensionError            (MappingError)         </code>","text":"<p>The size of a dimension is assigned to more than one value.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>class InconsistentDimensionError(MappingError):\n\"\"\"The size of a dimension is assigned to more than one value.\"\"\"\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.InconsistentTriplesError","title":"<code> InconsistentTriplesError            (MappingError)         </code>","text":"<p>Inconsistcy in RDF triples.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>class InconsistentTriplesError(MappingError):\n\"\"\"Inconsistcy in RDF triples.\"\"\"\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.InsufficientMappingError","title":"<code> InsufficientMappingError            (MappingError)         </code>","text":"<p>There are properties or dimensions that are not mapped.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>class InsufficientMappingError(MappingError):\n\"\"\"There are properties or dimensions that are not mapped.\"\"\"\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingError","title":"<code> MappingError            (Exception)         </code>","text":"<p>Base class for mapping errors.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>class MappingError(Exception):\n\"\"\"Base class for mapping errors.\"\"\"\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep","title":"<code> MappingStep        </code>","text":"<p>A step in a mapping route from a target to one or more sources.</p> <p>A mapping step corresponds to one or more RDF triples.  In the simple case of a <code>mo:mapsTo</code> or <code>rdfs:isSubclassOf</code> relation, it is only one triple.  For transformations that has several input and output, a set of triples are expected.</p> <p>Parameters:</p> Name Type Description Default <code>output_iri</code> <code>str</code> <p>IRI of the output concept.</p> required <code>steptype</code> <code>'StepType'</code> <p>One of the step types from the StepType enum.</p> <code>&lt;StepType.UNSPECIFIED: 0&gt;</code> <code>function</code> <code>'Optional[Callable]'</code> <p>Callable that evaluates the output from the input.</p> <code>None</code> <code>cost</code> <code>'Union[float, Callable]'</code> <p>The cost related to this mapping step.  Should be either a float or a callable taking three arguments (<code>triplestore</code>, <code>input_iris</code> and <code>output_iri</code>) and return the cost as a float.</p> <code>1.0</code> <code>output_unit</code> <code>'Optional[str]'</code> <p>Output unit.</p> <code>None</code> <code>triplestore</code> <code>'Optional[Triplestore]'</code> <p>Triplestore instance containing the knowledge base that this mapping step was created from.</p> <code>None</code> <p>The arguments can also be assigned as attributes.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>class MappingStep:\n\"\"\"A step in a mapping route from a target to one or more sources.\n\n    A mapping step corresponds to one or more RDF triples.  In the\n    simple case of a `mo:mapsTo` or `rdfs:isSubclassOf` relation, it is\n    only one triple.  For transformations that has several input and\n    output, a set of triples are expected.\n\n    Arguments:\n        output_iri: IRI of the output concept.\n        steptype: One of the step types from the StepType enum.\n        function: Callable that evaluates the output from the input.\n        cost: The cost related to this mapping step.  Should be either a\n            float or a callable taking three arguments (`triplestore`,\n            `input_iris` and `output_iri`) and return the cost as a float.\n        output_unit: Output unit.\n        triplestore: Triplestore instance containing the knowledge base\n            that this mapping step was created from.\n\n    The arguments can also be assigned as attributes.\n    \"\"\"\n\n    # pylint: disable=too-many-instance-attributes\n\n    def __init__(\n        self,\n        output_iri: str,\n        steptype: \"StepType\" = StepType.UNSPECIFIED,\n        function: \"Optional[Callable]\" = None,\n        cost: \"Union[float, Callable]\" = 1.0,\n        output_unit: \"Optional[str]\" = None,\n        triplestore: \"Optional[Triplestore]\" = None,\n    ) -&gt; None:\n        self.output_iri = output_iri\n        self.steptype = steptype\n        self.function = function\n        self.cost = cost\n        self.triplestore = triplestore\n        self.output_unit = output_unit\n        self.input_routes: \"List[dict]\" = []  # list of inputs dicts\n        self.join_mode = False  # whether to join upcoming input\n        self.joined_input: \"Inputs\" = {}\n\n    def add_inputs(self, inputs: \"Inputs\") -&gt; None:\n\"\"\"Add input dict for an input route.\"\"\"\n        assert isinstance(inputs, dict)  # nosec B101\n        self.input_routes.append(inputs)\n\n    def add_input(self, input: \"Input\", name: \"Optional[str]\" = None) -&gt; None:\n\"\"\"Add an input (MappingStep or Value), where `name` is the name\n        assigned to the argument.\n\n        If the `join_mode` attribute is false, a new route is created with\n        only one input.\n\n        If the `join_mode` attribute is true, the input is remembered, but\n        first added when join_input() is called.\n        \"\"\"\n        assert isinstance(input, (MappingStep, Value))  # nosec B101\n        argname = name if name else f\"arg{len(self.joined_input)+1}\"\n        if self.join_mode:\n            self.joined_input[argname] = input\n        else:\n            self.add_inputs({argname: input})\n\n    def join_input(self) -&gt; None:\n\"\"\"Join all input added with add_input() since `join_mode` was set true.\n        Resets `join_mode` to false.\"\"\"\n        if not self.join_mode:\n            raise MappingError(\"Calling join_input() when join_mode is false.\")\n        self.join_mode = False\n        self.add_inputs(self.joined_input)\n        self.joined_input = {}\n\n    def eval(\n        self,\n        routeno: \"Optional[int]\" = None,\n        unit: \"Optional[str]\" = None,\n        magnitude: bool = False,\n        quantity: \"Optional[Type[Quantity]]\" = None,\n    ) -&gt; \"Any\":\n\"\"\"Returns the evaluated value of given input route number.\n\n        Arguments:\n            routeno: The route number to evaluate.  If None (default)\n                the route with the lowest cost is evalueated.\n            unit: return the result in the given unit.\n                Implies `magnitude=True`.\n            magnitude: Whether to only return the magnitude of the evaluated\n                value (with no unit).\n            quantity: Quantity class to use for evaluation.  Defaults to pint.\n\n        Returns:\n            Evaluation result.\n        \"\"\"\n        if quantity is None:\n            quantity = Quantity\n        if routeno is None:\n            ((_, routeno),) = self.lowest_costs(nresults=1)\n        inputs, idx = self.get_inputs(routeno)\n        values = get_values(inputs, idx, quantity=quantity)\n\n        if len(inputs) == 1 and all(isinstance(v, Value) for v in inputs.values()):\n            (value,) = tuple(inputs.values())\n        elif self.function:\n            value = self.function(**values)\n        elif len(values) == 1:\n            (value,) = values.values()\n        else:\n            raise TypeError(f\"Expected inputs to be a single argument: {values}\")\n\n        if isinstance(value, Quantity) and unit:\n            return value.m_as(unit)\n        if isinstance(value, Quantity) and magnitude:\n            return value.m\n        if isinstance(value, Value):\n            return value.get_value(unit=unit, magnitude=magnitude, quantity=quantity)\n        return value\n\n    def get_inputs(self, routeno: int) -&gt; \"Tuple[Inputs, int]\":\n\"\"\"Returns input and input index `(inputs, idx)` for route number\n        `routeno`.\n\n        Arguments:\n            routeno: The route number to return inputs for.\n\n        Returns:\n            Inputs and difference between route number and number of routes for an\n            input dictioary.\n        \"\"\"\n        n = 0\n        for inputs in self.input_routes:\n            n0 = n\n            n += get_nroutes(inputs)\n            if n &gt; routeno:\n                return inputs, routeno - n0\n        raise ValueError(f\"routeno={routeno} exceeds number of routes\")\n\n    def get_input_iris(self, routeno: int) -&gt; \"Dict[str, Optional[str]]\":\n\"\"\"Returns a dict mapping input names to iris for the given route\n        number.\n\n        Arguments:\n            routeno: The route number to return a mapping for.\n\n        Returns:\n            Mapping of input names to IRIs.\n\n        \"\"\"\n        inputs, _ = self.get_inputs(routeno)\n        return {\n            k: v.output_iri if isinstance(v, MappingStep) else v.output_iri\n            for k, v in inputs.items()\n        }\n\n    def number_of_routes(self) -&gt; int:\n\"\"\"Total number of routes to this mapping step.\n\n        Returns:\n            Total number of routes to this mapping step.\n        \"\"\"\n        n = 0\n        for inputs in self.input_routes:\n            n += get_nroutes(inputs)\n        return n\n\n    def lowest_costs(self, nresults: int = 5) -&gt; \"List[Tuple[float, int]]\":\n\"\"\"Returns a list of `(cost, routeno)` tuples with up to the `nresult`\n        lowest costs and their corresponding route numbers.\n\n        Arguments:\n            nresults: Number of results to return.\n\n        Returns:\n            A list of `(cost, routeno)` tuples.\n        \"\"\"\n        result = []\n        n = 0  # total number of routes\n\n        # Loop over all toplevel routes leading into this mapping step\n        for inputs in self.input_routes:\n            # For each route, loop over all input arguments of this step\n            # The number of permutations we must consider is the product\n            # of the total number of routes to each input argument.\n            #\n            # We (potentially drastic) limit the possibilities by only\n            # considering the `nresults` routes with lowest costs into\n            # each argument.  This gives at maximum\n            #\n            #     nresults * number_of_input_arguments\n            #\n            # possibilities. We calculate the costs for all of them and\n            # store them in an array with two columns: `cost` and `routeno`.\n            # The `results` list is extended with the cost array\n            # for each toplevel route leading into this step.\n            base = np.rec.fromrecords([(0.0, 0)], names=\"cost,routeno\", formats=\"f8,i8\")\n            m = 1\n            for input in inputs.values():\n                if isinstance(input, MappingStep):\n                    nroutes = input.number_of_routes()\n                    res = np.rec.fromrecords(\n                        sorted(\n                            input.lowest_costs(nresults=nresults),\n                            key=lambda x: x[1],\n                        ),\n                        # [\n                        #     row\n                        #     for row in sorted(\n                        #         input.lowest_costs(nresults=nresults),\n                        #         key=lambda x: x[1],\n                        #     )\n                        # ],\n                        dtype=base.dtype,\n                    )\n                    res1 = res.repeat(len(base))\n                    base = np.tile(base, len(res))\n                    base.cost += res1.cost\n                    base.routeno += res1.routeno * m\n                    m *= nroutes\n                else:\n                    base.cost += input.cost\n\n            # Reduce the length of base (makes probably only sense in\n            # the case self.cost is a callable, but it doesn't hurt...)\n            base.sort()\n            base = base[:nresults]\n            base.routeno += n\n            n += m\n\n            # Add the cost for this step to `res`.  If `self.cost` is\n            # a callable, we call it with the input for each routeno\n            # as arguments.  Otherwise `self.cost` is the cost of this\n            # mapping step.\n            if callable(self.cost):\n                for i, rno in enumerate(base.routeno):\n                    inputs, _ = self.get_inputs(rno)\n                    input_iris = [input.output_iri for input in inputs.values()]\n                    owncost = self.cost(self.triplestore, input_iris, self.output_iri)\n                    base.cost[i] += owncost\n            else:\n                owncost = self.cost\n                base.cost += owncost\n\n            result.extend(base.tolist())\n\n        # Finally sort the results according to cost and return the\n        # `nresults` rows with lowest cost.\n        return sorted(result)[:nresults]\n\n    def show(\n        self,\n        routeno: \"Optional[int]\" = None,\n        name: \"Optional[str]\" = None,\n        indent: int = 0,\n    ) -&gt; str:\n\"\"\"Returns a string representation of the mapping routes to this step.\n\n        Arguments:\n            routeno: show given route.  The default is to show all routes.\n            name: Name of the last mapping step (mainly for internal use).\n            indent: How of blanks to prepend each line with (mainly for\n                internal use).\n\n        Returns:\n            String representation of the mapping routes.\n        \"\"\"\n        strings = []\n        ind = \" \" * indent\n        strings.append(ind + f'{name if name else \"Step\"}:')\n        strings.append(\n            ind + f\"  steptype: \" f\"{self.steptype.name if self.steptype else None}\"\n        )\n        strings.append(ind + f\"  output_iri: {self.output_iri}\")\n        strings.append(ind + f\"  output_unit: {self.output_unit}\")\n        strings.append(ind + f\"  cost: {self.cost}\")\n        if routeno is None:\n            strings.append(ind + \"  routes:\")\n            for inputs in self.input_routes:\n                t = \"\\n\".join(\n                    [\n                        input_.show(name=name_, indent=indent + 6)\n                        for name_, input_ in inputs.items()\n                    ]\n                )\n                strings.append(ind + \"    - \" + t[indent + 6 :])\n        else:\n            strings.append(ind + \"  inputs:\")\n            inputs, idx = self.get_inputs(routeno)\n            t = \"\\n\".join(\n                [\n                    input_.show(routeno=idx, name=name_, indent=indent + 6)\n                    for name_, input_ in inputs.items()\n                ]\n            )\n            strings.append(ind + \"    - \" + t[indent + 6 :])\n        return \"\\n\".join(strings)\n\n    def _iri(self, iri: str) -&gt; str:\n\"\"\"Help method that returns prefixed iri if possible, otherwise `iri`.\"\"\"\n        return self.triplestore.prefix_iri(iri) if self.triplestore else iri\n\n    def _visualise(self, routeno: int, next_iri: str, next_steptype: StepType) -&gt; str:\n\"\"\"Help function for visualise().\n\n        Arguments:\n            routeno: Route number to visualise.\n            next_iri: IRI of the next mapping step (i.e. the previous mapping\n                when starting from the target).\n            next_steptype: Step type from this to next iri.\n\n        Returns:\n            Mapping route in dot (graphviz) notation.\n        \"\"\"\n        hasOutput = EMMO.EMMO_c4bace1d_4db0_4cd3_87e9_18122bae2840\n\n        # Edge labels. We invert the steptypes, since we want to visualise\n        # the workflow in forward direction, while the steptypes refer to\n        # backward direction\n        labeldict = {\n            StepType.UNSPECIFIED: \"\",\n            StepType.MAPSTO: \"inverse(mapsTo)\",\n            StepType.INV_MAPSTO: \"mapsTo\",\n            StepType.INSTANCEOF: \"instanceOf\",\n            StepType.INV_INSTANCEOF: \"inverse(instanceOf)\",\n            StepType.SUBCLASSOF: \"subClassOf\",\n            StepType.INV_SUBCLASSOF: \"inverse(subClassOf)\",\n            StepType.FUNCTION: \"function\",\n        }\n        inputs, idx = self.get_inputs(routeno)\n        strings = []\n        for _, input in inputs.items():\n            if isinstance(input, Value):\n                strings.append(\n                    f'  \"{self._iri(input.output_iri)}\" -&gt; '\n                    f'\"{self._iri(self.output_iri)}\" '\n                    f'[label=\"{labeldict[self.steptype]}\"];'\n                )\n            elif isinstance(input, MappingStep):\n                strings.append(\n                    input._visualise(  # pylint: disable=protected-access\n                        routeno=idx,\n                        next_iri=self.output_iri,\n                        next_steptype=self.steptype,\n                    )\n                )\n            else:\n                raise TypeError(\"input should be Value or MappingStep\")\n        if next_iri:\n            label = labeldict[next_steptype]\n            if next_steptype == StepType.FUNCTION and self.triplestore:\n                model_iri = self.triplestore.value(\n                    predicate=hasOutput,  # Assuming EMMO\n                    object=next_iri,\n                    default=\"function\",\n                    any=True,\n                )\n                if model_iri:\n                    label = self.triplestore.value(\n                        subject=model_iri,\n                        predicate=RDFS.label,\n                        default=self._iri(model_iri),\n                        any=True,\n                    )\n            else:\n                label = labeldict[next_steptype]\n            strings.append(\n                f'  \"{self._iri(self.output_iri)}\" -&gt; '\n                f'\"{self._iri(next_iri)}\" [label=\"{label}\"];'\n            )\n        return \"\\n\".join(strings)\n\n    def visualise(\n        self,\n        routeno: int,\n        output: \"Optional[str]\" = None,\n        format: \"Optional[str]\" = \"png\",\n        dot: str = \"dot\",\n    ) -&gt; str:\n\"\"\"Greate a Graphviz visualisation of a given mapping route.\n\n        Arguments:\n            routeno: Number of mapping route to visualise.\n            output: If given, write the graph to this file.\n            format: File format to use with `output`.\n            dot: Path to Graphviz dot executable.\n\n        Returns:\n            String representation of the graph in dot format.\n        \"\"\"\n        strings = []\n        strings.append(\"digraph G {\")\n        strings.append(self._visualise(routeno, \"\", StepType.UNSPECIFIED))\n        strings.append(\"}\")\n        graph = \"\\n\".join(strings) + \"\\n\"\n        if output:\n            subprocess.run(\n                args=[dot, f\"-T{format}\", \"-o\", output],\n                shell=False,  # nosec: B603\n                check=True,\n                input=graph.encode(),\n            )\n        return graph\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep.add_input","title":"<code>add_input(self, input, name=None)</code>","text":"<p>Add an input (MappingStep or Value), where <code>name</code> is the name assigned to the argument.</p> <p>If the <code>join_mode</code> attribute is false, a new route is created with only one input.</p> <p>If the <code>join_mode</code> attribute is true, the input is remembered, but first added when join_input() is called.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def add_input(self, input: \"Input\", name: \"Optional[str]\" = None) -&gt; None:\n\"\"\"Add an input (MappingStep or Value), where `name` is the name\n    assigned to the argument.\n\n    If the `join_mode` attribute is false, a new route is created with\n    only one input.\n\n    If the `join_mode` attribute is true, the input is remembered, but\n    first added when join_input() is called.\n    \"\"\"\n    assert isinstance(input, (MappingStep, Value))  # nosec B101\n    argname = name if name else f\"arg{len(self.joined_input)+1}\"\n    if self.join_mode:\n        self.joined_input[argname] = input\n    else:\n        self.add_inputs({argname: input})\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep.add_inputs","title":"<code>add_inputs(self, inputs)</code>","text":"<p>Add input dict for an input route.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def add_inputs(self, inputs: \"Inputs\") -&gt; None:\n\"\"\"Add input dict for an input route.\"\"\"\n    assert isinstance(inputs, dict)  # nosec B101\n    self.input_routes.append(inputs)\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep.eval","title":"<code>eval(self, routeno=None, unit=None, magnitude=False, quantity=None)</code>","text":"<p>Returns the evaluated value of given input route number.</p> <p>Parameters:</p> Name Type Description Default <code>routeno</code> <code>'Optional[int]'</code> <p>The route number to evaluate.  If None (default) the route with the lowest cost is evalueated.</p> <code>None</code> <code>unit</code> <code>'Optional[str]'</code> <p>return the result in the given unit. Implies <code>magnitude=True</code>.</p> <code>None</code> <code>magnitude</code> <code>bool</code> <p>Whether to only return the magnitude of the evaluated value (with no unit).</p> <code>False</code> <code>quantity</code> <code>'Optional[Type[Quantity]]'</code> <p>Quantity class to use for evaluation.  Defaults to pint.</p> <code>None</code> <p>Returns:</p> Type Description <code>'Any'</code> <p>Evaluation result.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def eval(\n    self,\n    routeno: \"Optional[int]\" = None,\n    unit: \"Optional[str]\" = None,\n    magnitude: bool = False,\n    quantity: \"Optional[Type[Quantity]]\" = None,\n) -&gt; \"Any\":\n\"\"\"Returns the evaluated value of given input route number.\n\n    Arguments:\n        routeno: The route number to evaluate.  If None (default)\n            the route with the lowest cost is evalueated.\n        unit: return the result in the given unit.\n            Implies `magnitude=True`.\n        magnitude: Whether to only return the magnitude of the evaluated\n            value (with no unit).\n        quantity: Quantity class to use for evaluation.  Defaults to pint.\n\n    Returns:\n        Evaluation result.\n    \"\"\"\n    if quantity is None:\n        quantity = Quantity\n    if routeno is None:\n        ((_, routeno),) = self.lowest_costs(nresults=1)\n    inputs, idx = self.get_inputs(routeno)\n    values = get_values(inputs, idx, quantity=quantity)\n\n    if len(inputs) == 1 and all(isinstance(v, Value) for v in inputs.values()):\n        (value,) = tuple(inputs.values())\n    elif self.function:\n        value = self.function(**values)\n    elif len(values) == 1:\n        (value,) = values.values()\n    else:\n        raise TypeError(f\"Expected inputs to be a single argument: {values}\")\n\n    if isinstance(value, Quantity) and unit:\n        return value.m_as(unit)\n    if isinstance(value, Quantity) and magnitude:\n        return value.m\n    if isinstance(value, Value):\n        return value.get_value(unit=unit, magnitude=magnitude, quantity=quantity)\n    return value\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep.get_input_iris","title":"<code>get_input_iris(self, routeno)</code>","text":"<p>Returns a dict mapping input names to iris for the given route number.</p> <p>Parameters:</p> Name Type Description Default <code>routeno</code> <code>int</code> <p>The route number to return a mapping for.</p> required <p>Returns:</p> Type Description <code>'Dict[str, Optional[str]]'</code> <p>Mapping of input names to IRIs.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def get_input_iris(self, routeno: int) -&gt; \"Dict[str, Optional[str]]\":\n\"\"\"Returns a dict mapping input names to iris for the given route\n    number.\n\n    Arguments:\n        routeno: The route number to return a mapping for.\n\n    Returns:\n        Mapping of input names to IRIs.\n\n    \"\"\"\n    inputs, _ = self.get_inputs(routeno)\n    return {\n        k: v.output_iri if isinstance(v, MappingStep) else v.output_iri\n        for k, v in inputs.items()\n    }\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep.get_inputs","title":"<code>get_inputs(self, routeno)</code>","text":"<p>Returns input and input index <code>(inputs, idx)</code> for route number <code>routeno</code>.</p> <p>Parameters:</p> Name Type Description Default <code>routeno</code> <code>int</code> <p>The route number to return inputs for.</p> required <p>Returns:</p> Type Description <code>'Tuple[Inputs, int]'</code> <p>Inputs and difference between route number and number of routes for an input dictioary.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def get_inputs(self, routeno: int) -&gt; \"Tuple[Inputs, int]\":\n\"\"\"Returns input and input index `(inputs, idx)` for route number\n    `routeno`.\n\n    Arguments:\n        routeno: The route number to return inputs for.\n\n    Returns:\n        Inputs and difference between route number and number of routes for an\n        input dictioary.\n    \"\"\"\n    n = 0\n    for inputs in self.input_routes:\n        n0 = n\n        n += get_nroutes(inputs)\n        if n &gt; routeno:\n            return inputs, routeno - n0\n    raise ValueError(f\"routeno={routeno} exceeds number of routes\")\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep.join_input","title":"<code>join_input(self)</code>","text":"<p>Join all input added with add_input() since <code>join_mode</code> was set true. Resets <code>join_mode</code> to false.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def join_input(self) -&gt; None:\n\"\"\"Join all input added with add_input() since `join_mode` was set true.\n    Resets `join_mode` to false.\"\"\"\n    if not self.join_mode:\n        raise MappingError(\"Calling join_input() when join_mode is false.\")\n    self.join_mode = False\n    self.add_inputs(self.joined_input)\n    self.joined_input = {}\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep.lowest_costs","title":"<code>lowest_costs(self, nresults=5)</code>","text":"<p>Returns a list of <code>(cost, routeno)</code> tuples with up to the <code>nresult</code> lowest costs and their corresponding route numbers.</p> <p>Parameters:</p> Name Type Description Default <code>nresults</code> <code>int</code> <p>Number of results to return.</p> <code>5</code> <p>Returns:</p> Type Description <code>'List[Tuple[float, int]]'</code> <p>A list of <code>(cost, routeno)</code> tuples.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def lowest_costs(self, nresults: int = 5) -&gt; \"List[Tuple[float, int]]\":\n\"\"\"Returns a list of `(cost, routeno)` tuples with up to the `nresult`\n    lowest costs and their corresponding route numbers.\n\n    Arguments:\n        nresults: Number of results to return.\n\n    Returns:\n        A list of `(cost, routeno)` tuples.\n    \"\"\"\n    result = []\n    n = 0  # total number of routes\n\n    # Loop over all toplevel routes leading into this mapping step\n    for inputs in self.input_routes:\n        # For each route, loop over all input arguments of this step\n        # The number of permutations we must consider is the product\n        # of the total number of routes to each input argument.\n        #\n        # We (potentially drastic) limit the possibilities by only\n        # considering the `nresults` routes with lowest costs into\n        # each argument.  This gives at maximum\n        #\n        #     nresults * number_of_input_arguments\n        #\n        # possibilities. We calculate the costs for all of them and\n        # store them in an array with two columns: `cost` and `routeno`.\n        # The `results` list is extended with the cost array\n        # for each toplevel route leading into this step.\n        base = np.rec.fromrecords([(0.0, 0)], names=\"cost,routeno\", formats=\"f8,i8\")\n        m = 1\n        for input in inputs.values():\n            if isinstance(input, MappingStep):\n                nroutes = input.number_of_routes()\n                res = np.rec.fromrecords(\n                    sorted(\n                        input.lowest_costs(nresults=nresults),\n                        key=lambda x: x[1],\n                    ),\n                    # [\n                    #     row\n                    #     for row in sorted(\n                    #         input.lowest_costs(nresults=nresults),\n                    #         key=lambda x: x[1],\n                    #     )\n                    # ],\n                    dtype=base.dtype,\n                )\n                res1 = res.repeat(len(base))\n                base = np.tile(base, len(res))\n                base.cost += res1.cost\n                base.routeno += res1.routeno * m\n                m *= nroutes\n            else:\n                base.cost += input.cost\n\n        # Reduce the length of base (makes probably only sense in\n        # the case self.cost is a callable, but it doesn't hurt...)\n        base.sort()\n        base = base[:nresults]\n        base.routeno += n\n        n += m\n\n        # Add the cost for this step to `res`.  If `self.cost` is\n        # a callable, we call it with the input for each routeno\n        # as arguments.  Otherwise `self.cost` is the cost of this\n        # mapping step.\n        if callable(self.cost):\n            for i, rno in enumerate(base.routeno):\n                inputs, _ = self.get_inputs(rno)\n                input_iris = [input.output_iri for input in inputs.values()]\n                owncost = self.cost(self.triplestore, input_iris, self.output_iri)\n                base.cost[i] += owncost\n        else:\n            owncost = self.cost\n            base.cost += owncost\n\n        result.extend(base.tolist())\n\n    # Finally sort the results according to cost and return the\n    # `nresults` rows with lowest cost.\n    return sorted(result)[:nresults]\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep.number_of_routes","title":"<code>number_of_routes(self)</code>","text":"<p>Total number of routes to this mapping step.</p> <p>Returns:</p> Type Description <code>int</code> <p>Total number of routes to this mapping step.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def number_of_routes(self) -&gt; int:\n\"\"\"Total number of routes to this mapping step.\n\n    Returns:\n        Total number of routes to this mapping step.\n    \"\"\"\n    n = 0\n    for inputs in self.input_routes:\n        n += get_nroutes(inputs)\n    return n\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep.show","title":"<code>show(self, routeno=None, name=None, indent=0)</code>","text":"<p>Returns a string representation of the mapping routes to this step.</p> <p>Parameters:</p> Name Type Description Default <code>routeno</code> <code>'Optional[int]'</code> <p>show given route.  The default is to show all routes.</p> <code>None</code> <code>name</code> <code>'Optional[str]'</code> <p>Name of the last mapping step (mainly for internal use).</p> <code>None</code> <code>indent</code> <code>int</code> <p>How of blanks to prepend each line with (mainly for internal use).</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the mapping routes.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def show(\n    self,\n    routeno: \"Optional[int]\" = None,\n    name: \"Optional[str]\" = None,\n    indent: int = 0,\n) -&gt; str:\n\"\"\"Returns a string representation of the mapping routes to this step.\n\n    Arguments:\n        routeno: show given route.  The default is to show all routes.\n        name: Name of the last mapping step (mainly for internal use).\n        indent: How of blanks to prepend each line with (mainly for\n            internal use).\n\n    Returns:\n        String representation of the mapping routes.\n    \"\"\"\n    strings = []\n    ind = \" \" * indent\n    strings.append(ind + f'{name if name else \"Step\"}:')\n    strings.append(\n        ind + f\"  steptype: \" f\"{self.steptype.name if self.steptype else None}\"\n    )\n    strings.append(ind + f\"  output_iri: {self.output_iri}\")\n    strings.append(ind + f\"  output_unit: {self.output_unit}\")\n    strings.append(ind + f\"  cost: {self.cost}\")\n    if routeno is None:\n        strings.append(ind + \"  routes:\")\n        for inputs in self.input_routes:\n            t = \"\\n\".join(\n                [\n                    input_.show(name=name_, indent=indent + 6)\n                    for name_, input_ in inputs.items()\n                ]\n            )\n            strings.append(ind + \"    - \" + t[indent + 6 :])\n    else:\n        strings.append(ind + \"  inputs:\")\n        inputs, idx = self.get_inputs(routeno)\n        t = \"\\n\".join(\n            [\n                input_.show(routeno=idx, name=name_, indent=indent + 6)\n                for name_, input_ in inputs.items()\n            ]\n        )\n        strings.append(ind + \"    - \" + t[indent + 6 :])\n    return \"\\n\".join(strings)\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep.visualise","title":"<code>visualise(self, routeno, output=None, format='png', dot='dot')</code>","text":"<p>Greate a Graphviz visualisation of a given mapping route.</p> <p>Parameters:</p> Name Type Description Default <code>routeno</code> <code>int</code> <p>Number of mapping route to visualise.</p> required <code>output</code> <code>'Optional[str]'</code> <p>If given, write the graph to this file.</p> <code>None</code> <code>format</code> <code>'Optional[str]'</code> <p>File format to use with <code>output</code>.</p> <code>'png'</code> <code>dot</code> <code>str</code> <p>Path to Graphviz dot executable.</p> <code>'dot'</code> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the graph in dot format.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def visualise(\n    self,\n    routeno: int,\n    output: \"Optional[str]\" = None,\n    format: \"Optional[str]\" = \"png\",\n    dot: str = \"dot\",\n) -&gt; str:\n\"\"\"Greate a Graphviz visualisation of a given mapping route.\n\n    Arguments:\n        routeno: Number of mapping route to visualise.\n        output: If given, write the graph to this file.\n        format: File format to use with `output`.\n        dot: Path to Graphviz dot executable.\n\n    Returns:\n        String representation of the graph in dot format.\n    \"\"\"\n    strings = []\n    strings.append(\"digraph G {\")\n    strings.append(self._visualise(routeno, \"\", StepType.UNSPECIFIED))\n    strings.append(\"}\")\n    graph = \"\\n\".join(strings) + \"\\n\"\n    if output:\n        subprocess.run(\n            args=[dot, f\"-T{format}\", \"-o\", output],\n            shell=False,  # nosec: B603\n            check=True,\n            input=graph.encode(),\n        )\n    return graph\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MissingRelationError","title":"<code> MissingRelationError            (MappingError)         </code>","text":"<p>There are missing relations in RDF triples.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>class MissingRelationError(MappingError):\n\"\"\"There are missing relations in RDF triples.\"\"\"\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.StepType","title":"<code> StepType            (Enum)         </code>","text":"<p>Type of mapping step when going from the output to the inputs.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>class StepType(Enum):\n\"\"\"Type of mapping step when going from the output to the inputs.\"\"\"\n\n    UNSPECIFIED = 0\n    MAPSTO = 1\n    INV_MAPSTO = -1\n    INSTANCEOF = 2\n    INV_INSTANCEOF = -2\n    SUBCLASSOF = 3\n    INV_SUBCLASSOF = -3\n    FUNCTION = 4\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.Value","title":"<code> Value        </code>","text":"<p>Represents the value of an instance property.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>'Any'</code> <p>Property value.</p> <code>None</code> <code>unit</code> <code>'Optional[str]'</code> <p>Property unit.</p> <code>None</code> <code>iri</code> <code>'Optional[str]'</code> <p>IRI of ontological concept that this value is an instance of.</p> <code>None</code> <code>property_iri</code> <code>'Optional[str]'</code> <p>IRI of datamodel property that this value is an instance of.</p> <code>None</code> <code>cost</code> <code>'Union[float, Callable]'</code> <p>Cost of accessing this value.</p> <code>0.0</code> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>class Value:\n\"\"\"Represents the value of an instance property.\n\n    Arguments:\n        value: Property value.\n        unit: Property unit.\n        iri: IRI of ontological concept that this value is an instance of.\n        property_iri: IRI of datamodel property that this value is an\n            instance of.\n        cost: Cost of accessing this value.\n    \"\"\"\n\n    # pylint: disable=too-few-public-methods\n\n    def __init__(\n        self,\n        value: \"Any\" = None,\n        unit: \"Optional[str]\" = None,\n        iri: \"Optional[str]\" = None,\n        property_iri: \"Optional[str]\" = None,\n        cost: \"Union[float, Callable]\" = 0.0,\n    ):\n        self._value = value\n        self.unit = unit\n        if iri:\n            self.output_iri = iri\n        elif hasattr(value, __name__):\n            self.output_iri = value.__name__\n        else:\n            self.output_iri = f\"_:value_{id(value)}\"\n        self.property_iri = property_iri\n        self.cost = cost\n\n    value = property(\n        lambda self: self._value() if callable(self._value) else self._value,\n        doc=\"Value of property.\",\n    )\n\n    def __repr__(self):\n        args = []\n        if self.unit:\n            args.append(\", unit={self.unit}\")\n        if self.output_iri:\n            args.append(\", iri={self.output_iri}\")\n        if self.property_iri:\n            args.append(\", property_iri={self.property_iri}\")\n        if self.cost:\n            args.append(\", cost={self.cost}\")\n        return f\"Value({self._value}{''.join(args)})\"\n\n    def get_value(self, unit=None, magnitude=False, quantity=None) -&gt; \"Any\":\n\"\"\"Returns the evaluated value of given input route number.\n\n        Arguments:\n            unit: return the result in the given unit.\n                Implies `magnitude=True`.\n            magnitude: Whether to only return the magnitude of the evaluated\n                value (with no unit).\n            quantity: Quantity class to use for evaluation.  Defaults to pint.\n\n        Returns:\n            Value.\n        \"\"\"\n        if quantity is None:\n            quantity = Quantity\n        value = self._value() if callable(self._value) else self._value\n        if not isinstance(value, Quantity) and not self.unit:\n            return value\n        q = quantity(value, self.unit)\n        if unit:\n            return q.m_as(unit)\n        if magnitude:\n            return q.m\n        return q\n\n    def show(\n        self,\n        routeno: \"Optional[int]\" = None,\n        name: \"Optional[str]\" = None,\n        indent: int = 0,\n    ) -&gt; str:\n        # pylint: disable=unused-argument\n\"\"\"Returns a string representation of the Value.\n\n        Arguments:\n            routeno: Unused.  The argument exists for consistency with\n                the corresponding method in Step.\n            name: Name of value.\n            indent: Indentation level.\n\n        Returns:\n            String representation of the value.\n        \"\"\"\n        strings = []\n        ind = \" \" * indent\n        strings.append(ind + f'{name if name else \"Value\"}:')\n        strings.append(ind + f\"  iri: {self.output_iri}\")\n        strings.append(ind + f\"  property_iri: {self.property_iri}\")\n        strings.append(ind + f\"  unit: {self.unit}\")\n        strings.append(ind + f\"  cost: {self.cost}\")\n        strings.append(ind + f\"  value: {self.value}\")\n        return \"\\n\".join(strings)\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.Value.value","title":"<code>value</code>  <code>property</code> <code>readonly</code>","text":"<p>Value of property.</p>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.Value.get_value","title":"<code>get_value(self, unit=None, magnitude=False, quantity=None)</code>","text":"<p>Returns the evaluated value of given input route number.</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <p>return the result in the given unit. Implies <code>magnitude=True</code>.</p> <code>None</code> <code>magnitude</code> <p>Whether to only return the magnitude of the evaluated value (with no unit).</p> <code>False</code> <code>quantity</code> <p>Quantity class to use for evaluation.  Defaults to pint.</p> <code>None</code> <p>Returns:</p> Type Description <code>'Any'</code> <p>Value.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def get_value(self, unit=None, magnitude=False, quantity=None) -&gt; \"Any\":\n\"\"\"Returns the evaluated value of given input route number.\n\n    Arguments:\n        unit: return the result in the given unit.\n            Implies `magnitude=True`.\n        magnitude: Whether to only return the magnitude of the evaluated\n            value (with no unit).\n        quantity: Quantity class to use for evaluation.  Defaults to pint.\n\n    Returns:\n        Value.\n    \"\"\"\n    if quantity is None:\n        quantity = Quantity\n    value = self._value() if callable(self._value) else self._value\n    if not isinstance(value, Quantity) and not self.unit:\n        return value\n    q = quantity(value, self.unit)\n    if unit:\n        return q.m_as(unit)\n    if magnitude:\n        return q.m\n    return q\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.Value.show","title":"<code>show(self, routeno=None, name=None, indent=0)</code>","text":"<p>Returns a string representation of the Value.</p> <p>Parameters:</p> Name Type Description Default <code>routeno</code> <code>'Optional[int]'</code> <p>Unused.  The argument exists for consistency with the corresponding method in Step.</p> <code>None</code> <code>name</code> <code>'Optional[str]'</code> <p>Name of value.</p> <code>None</code> <code>indent</code> <code>int</code> <p>Indentation level.</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the value.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def show(\n    self,\n    routeno: \"Optional[int]\" = None,\n    name: \"Optional[str]\" = None,\n    indent: int = 0,\n) -&gt; str:\n    # pylint: disable=unused-argument\n\"\"\"Returns a string representation of the Value.\n\n    Arguments:\n        routeno: Unused.  The argument exists for consistency with\n            the corresponding method in Step.\n        name: Name of value.\n        indent: Indentation level.\n\n    Returns:\n        String representation of the value.\n    \"\"\"\n    strings = []\n    ind = \" \" * indent\n    strings.append(ind + f'{name if name else \"Value\"}:')\n    strings.append(ind + f\"  iri: {self.output_iri}\")\n    strings.append(ind + f\"  property_iri: {self.property_iri}\")\n    strings.append(ind + f\"  unit: {self.unit}\")\n    strings.append(ind + f\"  cost: {self.cost}\")\n    strings.append(ind + f\"  value: {self.value}\")\n    return \"\\n\".join(strings)\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.emmo_mapper","title":"<code>emmo_mapper(triplestore)</code>","text":"<p>Finds all function definitions in <code>triplestore</code> based on EMMO.</p> <p>Return a dict mapping output IRIs to a list of</p> <pre><code>(function_iri, [input_iris, ...])\n</code></pre> <p>tuples.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def emmo_mapper(triplestore: \"Triplestore\") -&gt; \"Dict[str, list]\":\n\"\"\"Finds all function definitions in `triplestore` based on EMMO.\n\n    Return a dict mapping output IRIs to a list of\n\n        (function_iri, [input_iris, ...])\n\n    tuples.\n    \"\"\"\n    Task = EMMO.EMMO_4299e344_a321_4ef2_a744_bacfcce80afc\n    hasInput = EMMO.EMMO_36e69413_8c59_4799_946c_10b05d266e22\n    hasOutput = EMMO.EMMO_c4bace1d_4db0_4cd3_87e9_18122bae2840\n\n    d = defaultdict(list)\n    for task in triplestore.subjects(RDF.type, Task):\n        inputs = list(triplestore.objects(task, hasInput))\n        for output in triplestore.objects(task, hasOutput):\n            d[output].append((task, inputs))\n\n    return d\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.fno_mapper","title":"<code>fno_mapper(triplestore)</code>","text":"<p>Finds all function definitions in <code>triplestore</code> based on the function ontololy (FNO).</p> <p>Parameters:</p> Name Type Description Default <code>triplestore</code> <code>'Triplestore'</code> <p>The triplestore to investigate.</p> required <p>Returns:</p> Type Description <code>'Dict[str, list]'</code> <p>A mapping of output IRIs to a list of <code>(function_iri, [input_iris, ...])</code> tuples.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def fno_mapper(triplestore: \"Triplestore\") -&gt; \"Dict[str, list]\":\n\"\"\"Finds all function definitions in `triplestore` based on the function\n    ontololy (FNO).\n\n    Arguments:\n        triplestore: The triplestore to investigate.\n\n    Returns:\n        A mapping of output IRIs to a list of `(function_iri, [input_iris, ...])`\n        tuples.\n    \"\"\"\n    # pylint: disable=too-many-branches\n\n    # Temporary dicts for fast lookup\n    Dfirst = dict(triplestore.subject_objects(RDF.first))\n    Drest = dict(triplestore.subject_objects(RDF.rest))\n    Dexpects = defaultdict(list)\n    Dreturns = defaultdict(list)\n    for s, o in triplestore.subject_objects(FNO.expects):\n        Dexpects[s].append(o)\n    for s, o in triplestore.subject_objects(FNO.returns):\n        Dreturns[s].append(o)\n\n    d = defaultdict(list)\n    for func, lst in Dreturns.items():\n        input_iris = []\n        for exp in Dexpects.get(func, ()):\n            if exp in Dfirst:\n                while exp in Dfirst:\n                    input_iris.append(Dfirst[exp])\n                    if exp not in Drest:\n                        break\n                    exp = Drest[exp]\n            else:\n                # Support also misuse of FNO, where fno:expects refers\n                # directly to input individuals\n                input_iris.append(exp)\n\n        for ret in lst:\n            if ret in Dfirst:\n                while ret in Dfirst:\n                    d[Dfirst[ret]].append((func, input_iris))\n                    if ret not in Drest:\n                        break\n                    ret = Drest[ret]\n            else:\n                # Support also misuse of FNO, where fno:returns refers\n                # directly to the returned individual\n                d[ret].append((func, input_iris))\n\n    return d\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.get_nroutes","title":"<code>get_nroutes(inputs)</code>","text":"<p>Help function returning the number of routes for an input dict.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>'Inputs'</code> <p>Input dictionary.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of routes in the <code>inputs</code> input dictionary.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def get_nroutes(inputs: \"Inputs\") -&gt; int:\n\"\"\"Help function returning the number of routes for an input dict.\n\n    Arguments:\n        inputs: Input dictionary.\n\n    Returns:\n        Number of routes in the `inputs` input dictionary.\n    \"\"\"\n    nroutes = 1\n    for input in inputs.values():\n        if isinstance(input, MappingStep):\n            nroutes *= input.number_of_routes()\n    return nroutes\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.get_values","title":"<code>get_values(inputs, routeno, quantity=&lt;class 'pint.quantity.Quantity'&gt;, magnitudes=False)</code>","text":"<p>Help function returning a dict mapping the input names to actual value of expected input unit.</p> <p>There exists <code>get_nroutes(inputs)</code> routes to populate <code>inputs</code>. <code>routeno</code> is the index of the specific route we will use to obtain the values.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>'dict[str, Any]'</code> <p>Input dictionary.</p> required <code>routeno</code> <code>int</code> <p>Route number index.</p> required <code>quantity</code> <code>'Type[Quantity]'</code> <p>A unit quantity class.</p> <code>&lt;class 'pint.quantity.Quantity'&gt;</code> <code>magnitudes</code> <code>bool</code> <p>Whether to only return the magnitude of the evaluated value (with no unit).</p> <code>False</code> <p>Returns:</p> Type Description <code>'dict[str, Any]'</code> <p>A mapping between input names and values of expected input unit.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def get_values(\n    inputs: \"dict[str, Any]\",\n    routeno: int,\n    quantity: \"Type[Quantity]\" = Quantity,\n    magnitudes: bool = False,\n) -&gt; \"dict[str, Any]\":\n\"\"\"Help function returning a dict mapping the input names to actual value\n    of expected input unit.\n\n    There exists `get_nroutes(inputs)` routes to populate `inputs`.\n    `routeno` is the index of the specific route we will use to obtain the\n    values.\n\n    Arguments:\n        inputs: Input dictionary.\n        routeno: Route number index.\n        quantity: A unit quantity class.\n        magnitudes: Whether to only return the magnitude of the evaluated\n            value (with no unit).\n\n    Returns:\n        A mapping between input names and values of expected input unit.\n    \"\"\"\n    values = {}\n    for k, v in inputs.items():\n        if isinstance(v, MappingStep):\n            value = v.eval(routeno=routeno, quantity=quantity)\n            values[k] = (\n                value.to(v.output_unit)\n                if v.output_unit and isinstance(v, quantity)\n                else value\n            )\n        elif isinstance(v, Value):\n            values[k] = v.value if v.unit is None else quantity(v.value, v.unit)\n        else:\n            raise TypeError(\n                \"Expected values in inputs to be either `MappingStep` or \"\n                \"`Value` objects.\"\n            )\n\n        if magnitudes:\n            values = {\n                k: v.m if isinstance(v, quantity) else v for k, v in values.items()\n            }\n\n    return values\n</code></pre>"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.mapping_routes","title":"<code>mapping_routes(target, sources, triplestore, function_repo=None, function_mappers=(&lt;function emmo_mapper at 0x7f98d57055f0&gt;, &lt;function fno_mapper at 0x7f98d5705680&gt;), default_costs=(('function', 10.0), ('mapsTo', 2.0), ('instanceOf', 1.0), ('subClassOf', 1.0), ('value', 0.0)), value_class=None, mappingstep_class=None, mapsTo='http://emmo.info/domain-mappings#mapsTo', instanceOf='http://emmo.info/datamodel#instanceOf', subClassOf='http://www.w3.org/2000/01/rdf-schema#subClassOf', label='http://www.w3.org/2000/01/rdf-schema#label', hasUnit='http://emmo.info/datamodel#hasUnit', hasCost='http://emmo.info/datamodel#hasCost', hasAccessFunction='http://emmo.info/emmo#hasAccessFunction', hasDataValue='http://www.w3.org/1999/02/22-rdf-syntax-ns#value')</code>","text":"<p>Find routes of mappings from any source in <code>sources</code> to <code>target</code>.</p> <p>This implementation supports functions (using FnO) and subclass relations.  It also correctly handles transitivity of <code>mapsTo</code> and <code>subClassOf</code> relations.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>IRI of the target in <code>triplestore</code>.</p> required <code>sources</code> <code>'Union[Dict[str, Union[Value, None]], Sequence[str]]'</code> <p>Dict mapping source IRIs to source values or a sequence of source IRIs (with no explicit values).</p> required <code>triplestore</code> <code>'Triplestore'</code> <p>Triplestore instance for the knowledge graph to traverse.</p> required <p>Additional arguments for fine-grained tuning:     !!! function_repo \"Dict mapping function IRIs to corresponding Python\"         function.  Default is to use <code>triplestore.function_repo</code>.     !!! function_mappers \"Name of mapping standard: \"emmo\" or \"fno\".\"         Alternatively, a sequence of mapping functions that takes         <code>triplestore</code> as argument and return a dict mapping output IRIs         to a list of <code>(function_iri, [input_iris, ...])</code> tuples.     !!! default_costs \"A dict providing default costs of different types\"         of mapping steps (\"function\", \"mapsTo\", \"instanceOf\",         \"subclassOf\", and \"value\").  These costs can be overridden with         'hasCost' relations in the ontology.     !!! value_class \"Optional <code>Value</code> subclass to use instead of <code>Value</code> when\"         creating the returned mapping route.     !!! mappingstep_class \"Optional <code>MappingStep</code> subclass to use instead of\"         <code>MappingStep</code> when creating the returned mapping route.     mapsTo: IRI of 'mapsTo' in <code>triplestore</code>.     instanceOf: IRI of 'instanceOf' in <code>triplestore</code>.     !!! subclassof \"IRI of 'subClassOf' in <code>triples</code>.  Set it to None if\"         subclasses should not be considered.     !!! label \"IRI of 'label' in <code>triplestore</code>.  Used for naming function\"         input parameters.  The default is to use rdfs:label.     !!! hasunit \"IRI of 'hasUnit' in <code>triplestore</code>.  Can be used to explicit\"         specify the unit of a quantity.     !!! hascost \"IRI of 'hasCost' in <code>triplestore</code>.  Used for associating a\"         user-defined cost or cost function with instantiation of a         property.     !!! hasaccessfunction \"IRI of 'hasAccessFunction'.  Used to associate a\"         data source to a function that retrieves the data.     !!! hasdatavalue \"IRI of 'hasDataValue'.  Used to associate a data source\"         with its literal value.</p> <p>Returns:</p> Type Description <code>Input</code> <p>A MappingStep instance.  This is a root of a nested tree of MappingStep instances providing an (efficient) internal description of all possible mapping routes from <code>sources</code> to <code>target</code>.</p> Source code in <code>tripper/mappings/mappings.py</code> <pre><code>def mapping_routes(\n    target: str,\n    sources: \"Union[Dict[str, Union[Value, None]], Sequence[str]]\",\n    triplestore: \"Triplestore\",\n    function_repo: \"Optional[dict]\" = None,\n    function_mappers: \"Union[str, Sequence[Callable]]\" = (emmo_mapper, fno_mapper),\n    default_costs: \"Tuple\" = (\n        (\"function\", 10.0),\n        (\"mapsTo\", 2.0),\n        (\"instanceOf\", 1.0),\n        (\"subClassOf\", 1.0),\n        (\"value\", 0.0),\n    ),\n    value_class: \"Optional[Type[Value]]\" = None,\n    mappingstep_class: \"Optional[Type[MappingStep]]\" = None,\n    mapsTo: str = MAP.mapsTo,\n    instanceOf: str = DM.instanceOf,\n    subClassOf: str = RDFS.subClassOf,\n    # description: str = DCTERMS.description,\n    label: str = RDFS.label,\n    hasUnit: str = DM.hasUnit,\n    hasCost: str = DM.hasCost,  # TODO - add hasCost to the DM ontology\n    hasAccessFunction: str = hasAccessFunction,  # pylint: disable=redefined-outer-name\n    hasDataValue: str = hasDataValue,  # pylint: disable=redefined-outer-name\n) -&gt; Input:\n\"\"\"Find routes of mappings from any source in `sources` to `target`.\n\n    This implementation supports functions (using FnO) and subclass\n    relations.  It also correctly handles transitivity of `mapsTo` and\n    `subClassOf` relations.\n\n    Arguments:\n        target: IRI of the target in `triplestore`.\n        sources: Dict mapping source IRIs to source values or a sequence\n            of source IRIs (with no explicit values).\n        triplestore: Triplestore instance for the knowledge graph to traverse.\n\n    Additional arguments for fine-grained tuning:\n        function_repo: Dict mapping function IRIs to corresponding Python\n            function.  Default is to use `triplestore.function_repo`.\n        function_mappers: Name of mapping standard: \"emmo\" or \"fno\".\n            Alternatively, a sequence of mapping functions that takes\n            `triplestore` as argument and return a dict mapping output IRIs\n            to a list of `(function_iri, [input_iris, ...])` tuples.\n        default_costs: A dict providing default costs of different types\n            of mapping steps (\"function\", \"mapsTo\", \"instanceOf\",\n            \"subclassOf\", and \"value\").  These costs can be overridden with\n            'hasCost' relations in the ontology.\n        value_class: Optional `Value` subclass to use instead of `Value` when\n            creating the returned mapping route.\n        mappingstep_class: Optional `MappingStep` subclass to use instead of\n            `MappingStep` when creating the returned mapping route.\n        mapsTo: IRI of 'mapsTo' in `triplestore`.\n        instanceOf: IRI of 'instanceOf' in `triplestore`.\n        subClassOf: IRI of 'subClassOf' in `triples`.  Set it to None if\n            subclasses should not be considered.\n        label: IRI of 'label' in `triplestore`.  Used for naming function\n            input parameters.  The default is to use rdfs:label.\n        hasUnit: IRI of 'hasUnit' in `triplestore`.  Can be used to explicit\n            specify the unit of a quantity.\n        hasCost: IRI of 'hasCost' in `triplestore`.  Used for associating a\n            user-defined cost or cost function with instantiation of a\n            property.\n        hasAccessFunction: IRI of 'hasAccessFunction'.  Used to associate a\n            data source to a function that retrieves the data.\n        hasDataValue: IRI of 'hasDataValue'.  Used to associate a data source\n            with its literal value.\n\n    Returns:\n        A MappingStep instance.  This is a root of a nested tree of\n        MappingStep instances providing an (efficient) internal description\n        of all possible mapping routes from `sources` to `target`.\n    \"\"\"\n    # pylint: disable=too-many-arguments,too-many-locals,too-many-statements\n\n    if target in sources:\n        return Value(iri=target)\n\n    if isinstance(sources, Sequence):\n        sources = {iri: None for iri in sources}\n\n    if function_repo is None:\n        function_repo = triplestore.function_repo\n\n    if isinstance(function_mappers, str):\n        fmd = {\"emmo\": emmo_mapper, \"fno\": fno_mapper}\n        function_mappers = [fmd[name] for name in function_mappers.split(\",\")]\n\n    default_costs = dict(default_costs)\n\n    if value_class is None:\n        value_class = Value\n\n    if mappingstep_class is None:\n        mappingstep_class = MappingStep\n\n    # Create lookup tables for fast access to triplestore content\n    soMaps = defaultdict(list)  # (s, mapsTo, o)     ==&gt; soMaps[s]  -&gt; [o, ..]\n    osMaps = defaultdict(list)  # (o, inv(mapsTo), s)     ==&gt; osMaps[o]  -&gt; [s, ..]\n    osSubcl = defaultdict(list)  # (o, inv(subClassOf), s) ==&gt; osSubcl[o] -&gt; [s, ..]\n    soInst = {}  # (s, instanceOf, o) ==&gt; soInst[s]  -&gt; o\n    osInst = defaultdict(list)  # (o, inv(instanceOf), s) ==&gt; osInst[o]  -&gt; [s, ..]\n    for s, o in triplestore.subject_objects(mapsTo):\n        soMaps[s].append(o)\n        osMaps[o].append(s)\n    for s, o in triplestore.subject_objects(subClassOf):\n        osSubcl[o].append(s)\n    for s, o in triplestore.subject_objects(instanceOf):\n        if s in soInst:\n            raise InconsistentTriplesError(\n                f\"The same individual can only relate to one datamodel \"\n                f\"property via {instanceOf} relations.\"\n            )\n        soInst[s] = o\n        osInst[o].append(s)\n    soName = dict(triplestore.subject_objects(label))\n    soUnit = dict(triplestore.subject_objects(hasUnit))\n    soCost = dict(triplestore.subject_objects(hasCost))\n    soAFun = dict(triplestore.subject_objects(hasAccessFunction))\n    soDVal = dict(triplestore.subject_objects(hasDataValue))\n\n    def getcost(target, stepname):\n\"\"\"Returns the cost assigned to IRI `target` for a mapping step\n        of type `stepname`.\"\"\"\n        cost = soCost.get(target, default_costs[stepname])\n        if cost is None:\n            return None\n        return (\n            function_repo[cost] if cost in function_repo else float(parse_literal(cost))\n        )\n\n    def walk(target, visited, step):\n\"\"\"Walk backward in rdf graph from `node` to sources.\"\"\"\n        if target in visited:\n            return\n        visited.add(target)\n\n        def addnode(node, steptype, stepname):\n            if node in visited:\n                return\n            step.steptype = steptype\n            step.cost = getcost(target, stepname)\n            if node in soAFun:\n                value = value_class(\n                    value=triplestore.function_repo[soAFun[node]],\n                    unit=soUnit.get(node),\n                    iri=node,\n                    property_iri=soInst.get(node),\n                    cost=getcost(node, \"value\"),\n                )\n                step.add_input(value, name=soName.get(node))\n            elif node in soDVal:\n                literal = parse_literal(soDVal[node])\n                value = value_class(\n                    value=literal.to_python(),\n                    unit=soUnit.get(node),\n                    iri=node,\n                    property_iri=soInst.get(node),\n                    cost=getcost(node, \"value\"),\n                )\n                step.add_input(value, name=soName.get(node))\n            elif node in sources:\n                value = value_class(\n                    value=sources[node],\n                    unit=soUnit.get(node),\n                    iri=node,\n                    property_iri=soInst.get(node),\n                    cost=getcost(node, \"value\"),\n                )\n                step.add_input(value, name=soName.get(node))\n            else:\n                prevstep = mappingstep_class(\n                    output_iri=node,\n                    output_unit=soUnit.get(node),\n                    triplestore=triplestore,\n                )\n                step.add_input(prevstep, name=soName.get(node))\n                walk(node, visited, prevstep)\n\n        for node in osInst[target]:\n            addnode(node, StepType.INV_INSTANCEOF, \"instanceOf\")\n\n        for node in soMaps[target]:\n            addnode(node, StepType.MAPSTO, \"mapsTo\")\n\n        for node in osMaps[target]:\n            addnode(node, StepType.INV_MAPSTO, \"mapsTo\")\n\n        for node in osSubcl[target]:\n            addnode(node, StepType.INV_SUBCLASSOF, \"subClassOf\")\n\n        for fmap in function_mappers:\n            for func, input_iris in fmap(triplestore)[target]:\n                step.steptype = StepType.FUNCTION\n                step.cost = getcost(func, \"function\")\n                step.function = function_repo.get(func)\n                step.join_mode = True\n                for input_iri in input_iris:\n                    step0 = mappingstep_class(\n                        output_iri=input_iri,\n                        output_unit=soUnit.get(input_iri),\n                        triplestore=triplestore,\n                    )\n                    step.add_input(step0, name=soName.get(input_iri))\n                    walk(input_iri, visited, step0)\n                step.join_input()\n\n    visited = set()\n    step = mappingstep_class(\n        output_iri=target,\n        output_unit=soUnit.get(target),\n        triplestore=triplestore,\n    )\n    if target in soInst:\n        # It is only initially we want to follow instanceOf in forward\n        # direction.  Later on we will only follow mapsTo and instanceOf in\n        # backward direction.\n        visited.add(target)  # do we really wan't this?  Yes, I think so...\n        source = soInst[target]\n        step.steptype = StepType.INSTANCEOF\n        step.cost = getcost(source, \"instanceOf\")\n        step0 = mappingstep_class(\n            output_iri=source,\n            output_unit=soUnit.get(source),\n            triplestore=triplestore,\n        )\n        step.add_input(step0, name=soName.get(target))\n        step = step0\n        target = source\n\n    if target not in soMaps:\n        raise MissingRelationError(f'Missing \"mapsTo\" relation on: {target}')\n    walk(target, visited, step)\n\n    return step\n</code></pre>"}]}