{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tripper \u00b6 Triplestore wrapper for Python providing a simple and consistent interface to a range of triplestore backends - the best ride when handling any triplestore. Basic concepts \u00b6 Tripper provides a simple and consistent interface to a range of triplestore backends. It strives for simplicity and is modelled after rdflib (with a few simplifications). In Tripper: All IRIs are represented by Python strings. Example: \"http://emmo.info/emmo#Atom\" Blank nodes are strings starting with \"_:\". Example: \"_:bnode1\" Literals are constructed with tripper.Literal . Example: tripper.Literal(3.14, datatype=XSD.float) To make it easy to work with IRIs, provide Tripper a set of pre-defined namespaces, like XSD.float . New namespaces can be defined with the tripper.Namespace class. A triplestore wrapper is created with the tripper.Triplestore class. Documentation \u00b6 Getting started: Take a look at the tutorial . Reference manual: API Reference Installation \u00b6 Tripper has by itself no dependencies outside the standard library, but the triplestore backends may have specific dependencies. The package can be installed from PyPI using pip : pip install tripper License and copyright \u00b6 All files in this repository are licensed under the MIT license . If not stated otherwise in the top of the files, they have copyright \u00a9 2022 SINTEF.","title":"Home"},{"location":"#tripper","text":"Triplestore wrapper for Python providing a simple and consistent interface to a range of triplestore backends - the best ride when handling any triplestore.","title":"Tripper"},{"location":"#basic-concepts","text":"Tripper provides a simple and consistent interface to a range of triplestore backends. It strives for simplicity and is modelled after rdflib (with a few simplifications). In Tripper: All IRIs are represented by Python strings. Example: \"http://emmo.info/emmo#Atom\" Blank nodes are strings starting with \"_:\". Example: \"_:bnode1\" Literals are constructed with tripper.Literal . Example: tripper.Literal(3.14, datatype=XSD.float) To make it easy to work with IRIs, provide Tripper a set of pre-defined namespaces, like XSD.float . New namespaces can be defined with the tripper.Namespace class. A triplestore wrapper is created with the tripper.Triplestore class.","title":"Basic concepts"},{"location":"#documentation","text":"Getting started: Take a look at the tutorial . Reference manual: API Reference","title":"Documentation"},{"location":"#installation","text":"Tripper has by itself no dependencies outside the standard library, but the triplestore backends may have specific dependencies. The package can be installed from PyPI using pip : pip install tripper","title":"Installation"},{"location":"#license-and-copyright","text":"All files in this repository are licensed under the MIT license . If not stated otherwise in the top of the files, they have copyright \u00a9 2022 SINTEF.","title":"License and copyright"},{"location":"CHANGELOG/","text":"Changelog \u00b6 Unreleased (2023-01-30) \u00b6 Full Changelog Fixed bugs: pre-commit failing hook installation #75 ontopy backend failing tests #7 Closed issues: Describe functions with EMMO instead of FnO #65 Merged pull requests: Using isort 5.12.0 for pre-commit #76 ( CasperWA ) Fix deprecated calls syntax to Triplestore.triples() #71 ( jesper-friis ) Made the value optional + added some cleanup #70 ( jesper-friis ) Add map() method to Triplestore #69 ( jesper-friis ) Proper cost function #68 ( jesper-friis ) Updated Triplestore.add_function() to also support EMMO. #67 ( jesper-friis ) Added mappings #62 ( jesper-friis ) [Auto-generated] Update dependencies #60 ( TEAM4-0 ) v0.2.1 (2022-12-18) \u00b6 Full Changelog Closed issues: Simplify use of the Triplestore triples() and remove() methods #50 Merged pull requests: Commented out __hash__() and __eq__() methods from Literal. #55 ( jesper-friis ) Simplify use of the Triplestore triples() and remove() methods #51 ( jesper-friis ) Separated base_iri argument from triplestore_url in rdflib backend #49 ( jesper-friis ) v0.2.0 (2022-12-13) \u00b6 Full Changelog Fixed bugs: Deploy docs failing due to wrong dependency installation #53 Closed issues: Remove backend packages from requirements #48 Fix utils.parse_object() #45 Merged pull requests: Update docs extra #54 ( CasperWA ) Remove backend packages from requirements #52 ( jesper-friis ) Fix utils.parse_object() #46 ( jesper-friis ) v0.1.2 (2022-12-11) \u00b6 Full Changelog Implemented enhancements: The return value of query() depends on the query #42 Add DLite collection backend #41 Implement create_database() and remove_database() methods #34 SPARQLWrapper backend #10 Refactor triplestore.py (triplestore module API) #3 Closed issues: Revert to using the proper general version for SINTEF/ci-cd #35 Write in type annotations #33 Improve README file #18 Add support for simple persistent storage in the rdflib backend #14 Merged pull requests: Added collection backend #44 ( jesper-friis ) Fix return types #43 ( CasperWA ) Updated import statements in the tutorial #40 ( jesper-friis ) Added create_database() and remove_database() methods. #39 ( jesper-friis ) Use the proper version of SINTEF/ci-cd #36 ( CasperWA ) bumped ci-cd version to remove --strict mkdocs command #32 ( daniel-sintef ) 3 refactor triplestorepy triplestore module api #31 ( daniel-sintef ) [Auto-generated] Update dependencies #28 ( TEAM4-0 ) 3 refactor triplestore #27 ( jesper-friis ) Corrected copyright #21 ( jesper-friis ) Add a useful description to README file. #19 ( jesper-friis ) Added support for simple persistent storage in the rdflib backend #15 ( jesper-friis ) sparqlwrapper backend #11 ( jesper-friis ) Documented return value of the Triplestore.query() and added a test for it #9 ( jesper-friis ) v0.1.1 (2022-10-13) \u00b6 Full Changelog Implemented enhancements: Change package name to tripper on PyPI #13 Clean up newly initialized Python API #1 Fixed bugs: Enable proper release workflow #8 Fix workflows so they succeed #2 Merged pull requests: [Auto-generated] Update dependencies #17 ( TEAM4-0 ) Use the package name tripper (not tripperpy ) #16 ( CasperWA ) Clean up repository & fix workflows #5 ( CasperWA ) Added version number in __init__ to enable local pip install #4 ( quaat ) * This Changelog was automatically generated by github_changelog_generator","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#unreleased-2023-01-30","text":"Full Changelog Fixed bugs: pre-commit failing hook installation #75 ontopy backend failing tests #7 Closed issues: Describe functions with EMMO instead of FnO #65 Merged pull requests: Using isort 5.12.0 for pre-commit #76 ( CasperWA ) Fix deprecated calls syntax to Triplestore.triples() #71 ( jesper-friis ) Made the value optional + added some cleanup #70 ( jesper-friis ) Add map() method to Triplestore #69 ( jesper-friis ) Proper cost function #68 ( jesper-friis ) Updated Triplestore.add_function() to also support EMMO. #67 ( jesper-friis ) Added mappings #62 ( jesper-friis ) [Auto-generated] Update dependencies #60 ( TEAM4-0 )","title":"Unreleased (2023-01-30)"},{"location":"CHANGELOG/#v021-2022-12-18","text":"Full Changelog Closed issues: Simplify use of the Triplestore triples() and remove() methods #50 Merged pull requests: Commented out __hash__() and __eq__() methods from Literal. #55 ( jesper-friis ) Simplify use of the Triplestore triples() and remove() methods #51 ( jesper-friis ) Separated base_iri argument from triplestore_url in rdflib backend #49 ( jesper-friis )","title":"v0.2.1 (2022-12-18)"},{"location":"CHANGELOG/#v020-2022-12-13","text":"Full Changelog Fixed bugs: Deploy docs failing due to wrong dependency installation #53 Closed issues: Remove backend packages from requirements #48 Fix utils.parse_object() #45 Merged pull requests: Update docs extra #54 ( CasperWA ) Remove backend packages from requirements #52 ( jesper-friis ) Fix utils.parse_object() #46 ( jesper-friis )","title":"v0.2.0 (2022-12-13)"},{"location":"CHANGELOG/#v012-2022-12-11","text":"Full Changelog Implemented enhancements: The return value of query() depends on the query #42 Add DLite collection backend #41 Implement create_database() and remove_database() methods #34 SPARQLWrapper backend #10 Refactor triplestore.py (triplestore module API) #3 Closed issues: Revert to using the proper general version for SINTEF/ci-cd #35 Write in type annotations #33 Improve README file #18 Add support for simple persistent storage in the rdflib backend #14 Merged pull requests: Added collection backend #44 ( jesper-friis ) Fix return types #43 ( CasperWA ) Updated import statements in the tutorial #40 ( jesper-friis ) Added create_database() and remove_database() methods. #39 ( jesper-friis ) Use the proper version of SINTEF/ci-cd #36 ( CasperWA ) bumped ci-cd version to remove --strict mkdocs command #32 ( daniel-sintef ) 3 refactor triplestorepy triplestore module api #31 ( daniel-sintef ) [Auto-generated] Update dependencies #28 ( TEAM4-0 ) 3 refactor triplestore #27 ( jesper-friis ) Corrected copyright #21 ( jesper-friis ) Add a useful description to README file. #19 ( jesper-friis ) Added support for simple persistent storage in the rdflib backend #15 ( jesper-friis ) sparqlwrapper backend #11 ( jesper-friis ) Documented return value of the Triplestore.query() and added a test for it #9 ( jesper-friis )","title":"v0.1.2 (2022-12-11)"},{"location":"CHANGELOG/#v011-2022-10-13","text":"Full Changelog Implemented enhancements: Change package name to tripper on PyPI #13 Clean up newly initialized Python API #1 Fixed bugs: Enable proper release workflow #8 Fix workflows so they succeed #2 Merged pull requests: [Auto-generated] Update dependencies #17 ( TEAM4-0 ) Use the package name tripper (not tripperpy ) #16 ( CasperWA ) Clean up repository & fix workflows #5 ( CasperWA ) Added version number in __init__ to enable local pip install #4 ( quaat ) * This Changelog was automatically generated by github_changelog_generator","title":"v0.1.1 (2022-10-13)"},{"location":"LICENSE/","text":"MIT License Copyright (c) 2022 SINTEF Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"planned-backends/","text":"Planned backends \u00b6 In addition to the currently existing backends, the following additional backends may be supported in upcoming versions: OntoRec/OntoFlowKB Stardog DLite triplestore (based on Redland librdf) Redland librdf Apache Jena Fuseki Allegrograph Wikidata","title":"Planned backends"},{"location":"planned-backends/#planned-backends","text":"In addition to the currently existing backends, the following additional backends may be supported in upcoming versions: OntoRec/OntoFlowKB Stardog DLite triplestore (based on Redland librdf) Redland librdf Apache Jena Fuseki Allegrograph Wikidata","title":"Planned backends"},{"location":"tutorial/","text":"Tutorial \u00b6 Create a triplestore instance using the rdflib backend: from tripper import Triplestore ts = Triplestore ( backend = \"rdflib\" ) The module already provides a set of pre-defined namespaces that simplifies writing IRIs. For example: from tripper import RDFS , OWL RDFS . subClassOf # -> 'http://www.w3.org/2000/01/rdf-schema#subClassOf' New namespaces can be created using the Namespace class, but are usually added with the bind() method: ONTO = ts . bind ( \"onto\" , \"http://example.com/onto#\" ) ONTO . MyConcept # -> 'http://example.com/onto#MyConcept' Namespace also supports access by label and IRI checking. Both of these features requires loading an ontology. The following example shows how to create an EMMO namespace with IRI checking. The keyword argument label_annotations=True enables access by skos:prefLabel , rdfs:label or skos:altLabel . The check=True enables checking for existing IRIs. The triplestore_url=... is a resolvable URL that can be read by the 'rdflib' backend. It is needed, because the 'rdflib' backend is currently not able to load EMMO from the http://emmo.info/emmo# namespace. EMMO = ts . bind ( \"emmo\" , \"http://emmo.info/emmo#\" , label_annotations = True , check = True , triplestore_url = \"https://emmo-repo.github.io/versions/1.0.0-beta4/emmo-inferred.ttl\" , ) EMMO . Atom # -> 'http://emmo.info/emmo#EMMO_eb77076b_a104_42ac_a065_798b2d2809ad' EMMO . invalid_name # -> NoSuchIRIError: http://emmo.info/emmo#invalid_name New triples can be added either with the parse() method (for backends that support it) or the add() and add_triples() methods: # en(msg) is a convenient function for adding english literals. # It is equivalent to ``tripper.Literal(msg, lang=\"en\")``. from tripper.utils import en ts . parse ( \"onto.ttl\" , format = \"turtle\" ) ts . add_triples ([ ( ONTO . MyConcept , RDFS . subClassOf , OWL . Thing ), ( ONTO . MyConcept , RDFS . label , en ( \"My briliant ontological concept.\" )), ]) For backends that support it the triplestore can be serialised using serialize() : ts . serialize ( \"onto2.ttl\" ) A set of convenient functions exists for simple queries, including triples() , subjects() , predicates() , objects() , subject_predicates() , subject_objects() , predicate_objects() and value() . Except for value() , they return the result as generators. For example: ts . objects ( subject = ONTO . MyConcept , predicate = RDFS . subClassOf ) # -> <generator object Triplestore.objects at 0x7fa502590200> list ( ts . objects ( subject = ONTO . MyConcept , predicate = RDFS . subClassOf )) # -> ['http://www.w3.org/2002/07/owl#Thing'] The query() and update() methods can be used to query and update the triplestore using SPARQL. Finally Triplestore has two specialised methods add_mapsTo() and add_function() that simplify working with mappings. add_mapsTo() is convinient for defining new mappings: from tripper import Namespace META = Namespace ( \"http://onto-ns.com/meta/0.1/MyEntity#\" ) ts . add_mapsTo ( ONTO . MyConcept , META . my_property ) It can also be used with DLite and SOFT7 data models. Here we repeat the above with DLite: import dlite meta = dlite . get_instance ( \"http://onto-ns.com/meta/0.1/MyEntity\" ) ts . add_mapsTo ( ONTO . MyConcept , meta , \"my_property\" ) The add_function() describes a function and adds mappings for its arguments and return value(s). Currently it only supports the Function Ontology (FnO) . def mean ( x , y ): \"\"\"Returns the mean value of `x` and `y`.\"\"\" return ( x + y ) / 2 ts . add_function ( mean , expects = ( ONTO . RightArmLength , ONTO . LeftArmLength ), returns = ONTO . AverageArmLength , )","title":"Tutorial"},{"location":"tutorial/#tutorial","text":"Create a triplestore instance using the rdflib backend: from tripper import Triplestore ts = Triplestore ( backend = \"rdflib\" ) The module already provides a set of pre-defined namespaces that simplifies writing IRIs. For example: from tripper import RDFS , OWL RDFS . subClassOf # -> 'http://www.w3.org/2000/01/rdf-schema#subClassOf' New namespaces can be created using the Namespace class, but are usually added with the bind() method: ONTO = ts . bind ( \"onto\" , \"http://example.com/onto#\" ) ONTO . MyConcept # -> 'http://example.com/onto#MyConcept' Namespace also supports access by label and IRI checking. Both of these features requires loading an ontology. The following example shows how to create an EMMO namespace with IRI checking. The keyword argument label_annotations=True enables access by skos:prefLabel , rdfs:label or skos:altLabel . The check=True enables checking for existing IRIs. The triplestore_url=... is a resolvable URL that can be read by the 'rdflib' backend. It is needed, because the 'rdflib' backend is currently not able to load EMMO from the http://emmo.info/emmo# namespace. EMMO = ts . bind ( \"emmo\" , \"http://emmo.info/emmo#\" , label_annotations = True , check = True , triplestore_url = \"https://emmo-repo.github.io/versions/1.0.0-beta4/emmo-inferred.ttl\" , ) EMMO . Atom # -> 'http://emmo.info/emmo#EMMO_eb77076b_a104_42ac_a065_798b2d2809ad' EMMO . invalid_name # -> NoSuchIRIError: http://emmo.info/emmo#invalid_name New triples can be added either with the parse() method (for backends that support it) or the add() and add_triples() methods: # en(msg) is a convenient function for adding english literals. # It is equivalent to ``tripper.Literal(msg, lang=\"en\")``. from tripper.utils import en ts . parse ( \"onto.ttl\" , format = \"turtle\" ) ts . add_triples ([ ( ONTO . MyConcept , RDFS . subClassOf , OWL . Thing ), ( ONTO . MyConcept , RDFS . label , en ( \"My briliant ontological concept.\" )), ]) For backends that support it the triplestore can be serialised using serialize() : ts . serialize ( \"onto2.ttl\" ) A set of convenient functions exists for simple queries, including triples() , subjects() , predicates() , objects() , subject_predicates() , subject_objects() , predicate_objects() and value() . Except for value() , they return the result as generators. For example: ts . objects ( subject = ONTO . MyConcept , predicate = RDFS . subClassOf ) # -> <generator object Triplestore.objects at 0x7fa502590200> list ( ts . objects ( subject = ONTO . MyConcept , predicate = RDFS . subClassOf )) # -> ['http://www.w3.org/2002/07/owl#Thing'] The query() and update() methods can be used to query and update the triplestore using SPARQL. Finally Triplestore has two specialised methods add_mapsTo() and add_function() that simplify working with mappings. add_mapsTo() is convinient for defining new mappings: from tripper import Namespace META = Namespace ( \"http://onto-ns.com/meta/0.1/MyEntity#\" ) ts . add_mapsTo ( ONTO . MyConcept , META . my_property ) It can also be used with DLite and SOFT7 data models. Here we repeat the above with DLite: import dlite meta = dlite . get_instance ( \"http://onto-ns.com/meta/0.1/MyEntity\" ) ts . add_mapsTo ( ONTO . MyConcept , meta , \"my_property\" ) The add_function() describes a function and adds mappings for its arguments and return value(s). Currently it only supports the Function Ontology (FnO) . def mean ( x , y ): \"\"\"Returns the mean value of `x` and `y`.\"\"\" return ( x + y ) / 2 ts . add_function ( mean , expects = ( ONTO . RightArmLength , ONTO . LeftArmLength ), returns = ONTO . AverageArmLength , )","title":"Tutorial"},{"location":"api_reference/errors/","text":"errors \u00b6 Exceptions for the triplestore package. NamespaceError ( TriplestoreError ) \u00b6 Namespace error. Source code in tripper/errors.py class NamespaceError ( TriplestoreError ): \"\"\"Namespace error.\"\"\" NoSuchIRIError ( NamespaceError ) \u00b6 Namespace has no such IRI. Source code in tripper/errors.py class NoSuchIRIError ( NamespaceError ): \"\"\"Namespace has no such IRI.\"\"\" TriplestoreError ( Exception ) \u00b6 Base exception for triplestore errors. Source code in tripper/errors.py class TriplestoreError ( Exception ): \"\"\"Base exception for triplestore errors.\"\"\" UniquenessError ( TriplestoreError ) \u00b6 More than one matching triple. Source code in tripper/errors.py class UniquenessError ( TriplestoreError ): \"\"\"More than one matching triple.\"\"\"","title":"errors"},{"location":"api_reference/errors/#errors","text":"Exceptions for the triplestore package.","title":"errors"},{"location":"api_reference/errors/#tripper.errors.NamespaceError","text":"Namespace error. Source code in tripper/errors.py class NamespaceError ( TriplestoreError ): \"\"\"Namespace error.\"\"\"","title":"NamespaceError"},{"location":"api_reference/errors/#tripper.errors.NoSuchIRIError","text":"Namespace has no such IRI. Source code in tripper/errors.py class NoSuchIRIError ( NamespaceError ): \"\"\"Namespace has no such IRI.\"\"\"","title":"NoSuchIRIError"},{"location":"api_reference/errors/#tripper.errors.TriplestoreError","text":"Base exception for triplestore errors. Source code in tripper/errors.py class TriplestoreError ( Exception ): \"\"\"Base exception for triplestore errors.\"\"\"","title":"TriplestoreError"},{"location":"api_reference/errors/#tripper.errors.UniquenessError","text":"More than one matching triple. Source code in tripper/errors.py class UniquenessError ( TriplestoreError ): \"\"\"More than one matching triple.\"\"\"","title":"UniquenessError"},{"location":"api_reference/interface/","text":"interface \u00b6 Provides the ITriplestore protocol class, that documents the interface of the triplestore backends. ITriplestore ( Protocol ) \u00b6 Interface for triplestore backends. In addition to the methods specified by this interface, a backend may also implement the following optional methods: def __init__ ( self , base_iri : str = None , ** kwargs ): \"\"\"Initialise triplestore. Arguments: base_iri: Optional base IRI to initiate the triplestore from. kwargs: Additional keyword arguments passed to the backend. \"\"\" def parse ( self , source : Union [ str , Path , IO ] = None , location : str = None , data : str = None , format : str = None , ** kwargs ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Arguments: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. kwargs: Additional backend-specific parameters controlling the parsing. \"\"\" def serialize ( self , destination : Union [ str , Path , IO ] = None , format : str = 'xml' , ** kwargs ): \"\"\"Serialise to destination. Arguments: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Additional backend-specific parameters controlling the serialisation. Returns: Serialised string if `destination` is None. \"\"\" def query ( self , query_object : str , ** kwargs ) -> List [ Tuple [ str , ... ]]: \"\"\"SPARQL query. Arguments: query_object: String with the SPARQL query. kwargs: Additional backend-specific keyword arguments. Returns: List of tuples of IRIs for each matching row. \"\"\" def update ( self , update_object : str , ** kwargs ): \"\"\"Update triplestore with SPARQL. Arguments: query_object: String with the SPARQL query. kwargs: Additional backend-specific keyword arguments. Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" def bind ( self , prefix : str , namespace : str ) -> Namespace : \"\"\"Bind prefix to namespace. Should only be defined if the backend supports namespaces. \"\"\" def namespaces ( self ) -> dict : \"\"\"Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. \"\"\" @classmethod def create_database ( cls , database : str , ** kwargs ): \"\"\"Create a new database in backend. Parameters: database: Name of the new database. kwargs: Keyword arguments passed to the backend create_database() method. Note: This is a class method, which operates on the backend triplestore without connecting to it. \"\"\" @classmethod def remove_database ( cls , database : str , ** kwargs ): \"\"\"Remove a database in backend. Parameters: database: Name of the database to be removed. kwargs: Keyword arguments passed to the backend remove_database() method. Note: This is a class method, which operates on the backend triplestore without connecting to it. \"\"\" @classmethod def list_databases ( cls , ** kwargs ): \"\"\"For backends that supports multiple databases, list of all databases. Parameters: kwargs: Keyword arguments passed to the backend list_database() method. Note: This is a class method, which operates on the backend triplestore without connecting to it. \"\"\" Source code in tripper/interface.py class ITriplestore ( Protocol ): '''Interface for triplestore backends. In addition to the methods specified by this interface, a backend may also implement the following optional methods: ```python def __init__(self, base_iri: str = None, **kwargs): \"\"\"Initialise triplestore. Arguments: base_iri: Optional base IRI to initiate the triplestore from. kwargs: Additional keyword arguments passed to the backend. \"\"\" def parse( self, source: Union[str, Path, IO] = None, location: str = None, data: str = None, format: str = None, **kwargs ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Arguments: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. kwargs: Additional backend-specific parameters controlling the parsing. \"\"\" def serialize( self, destination: Union[str, Path, IO] = None, format: str ='xml', **kwargs ): \"\"\"Serialise to destination. Arguments: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Additional backend-specific parameters controlling the serialisation. Returns: Serialised string if `destination` is None. \"\"\" def query(self, query_object: str, **kwargs) -> List[Tuple[str, ...]]: \"\"\"SPARQL query. Arguments: query_object: String with the SPARQL query. kwargs: Additional backend-specific keyword arguments. Returns: List of tuples of IRIs for each matching row. \"\"\" def update(self, update_object: str, **kwargs): \"\"\"Update triplestore with SPARQL. Arguments: query_object: String with the SPARQL query. kwargs: Additional backend-specific keyword arguments. Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" def bind(self, prefix: str, namespace: str) -> Namespace: \"\"\"Bind prefix to namespace. Should only be defined if the backend supports namespaces. \"\"\" def namespaces(self) -> dict: \"\"\"Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. \"\"\" @classmethod def create_database(cls, database: str, **kwargs): \"\"\"Create a new database in backend. Parameters: database: Name of the new database. kwargs: Keyword arguments passed to the backend create_database() method. Note: This is a class method, which operates on the backend triplestore without connecting to it. \"\"\" @classmethod def remove_database(cls, database: str, **kwargs): \"\"\"Remove a database in backend. Parameters: database: Name of the database to be removed. kwargs: Keyword arguments passed to the backend remove_database() method. Note: This is a class method, which operates on the backend triplestore without connecting to it. \"\"\" @classmethod def list_databases(cls, **kwargs): \"\"\"For backends that supports multiple databases, list of all databases. Parameters: kwargs: Keyword arguments passed to the backend list_database() method. Note: This is a class method, which operates on the backend triplestore without connecting to it. \"\"\" ``` ''' def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples. Arguments: triple: A `(s, p, o)` tuple where `s`, `p` and `o` should either be None (matching anything) or an exact IRI to match. \"\"\" def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples. Arguments: triples: A sequence of `(s, p, o)` tuples to add to the triplestore. \"\"\" def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" add_triples ( self , triples ) \u00b6 Add a sequence of triples. Parameters: Name Type Description Default triples Sequence[Triple] A sequence of (s, p, o) tuples to add to the triplestore. required Source code in tripper/interface.py def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples. Arguments: triples: A sequence of `(s, p, o)` tuples to add to the triplestore. \"\"\" remove ( self , triple ) \u00b6 Remove all matching triples from the backend. Source code in tripper/interface.py def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" triples ( self , triple ) \u00b6 Returns a generator over matching triples. Parameters: Name Type Description Default triple Triple A (s, p, o) tuple where s , p and o should either be None (matching anything) or an exact IRI to match. required Source code in tripper/interface.py def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples. Arguments: triple: A `(s, p, o)` tuple where `s`, `p` and `o` should either be None (matching anything) or an exact IRI to match. \"\"\"","title":"interface"},{"location":"api_reference/interface/#interface","text":"Provides the ITriplestore protocol class, that documents the interface of the triplestore backends.","title":"interface"},{"location":"api_reference/interface/#tripper.interface.ITriplestore","text":"Interface for triplestore backends. In addition to the methods specified by this interface, a backend may also implement the following optional methods: def __init__ ( self , base_iri : str = None , ** kwargs ): \"\"\"Initialise triplestore. Arguments: base_iri: Optional base IRI to initiate the triplestore from. kwargs: Additional keyword arguments passed to the backend. \"\"\" def parse ( self , source : Union [ str , Path , IO ] = None , location : str = None , data : str = None , format : str = None , ** kwargs ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Arguments: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. kwargs: Additional backend-specific parameters controlling the parsing. \"\"\" def serialize ( self , destination : Union [ str , Path , IO ] = None , format : str = 'xml' , ** kwargs ): \"\"\"Serialise to destination. Arguments: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Additional backend-specific parameters controlling the serialisation. Returns: Serialised string if `destination` is None. \"\"\" def query ( self , query_object : str , ** kwargs ) -> List [ Tuple [ str , ... ]]: \"\"\"SPARQL query. Arguments: query_object: String with the SPARQL query. kwargs: Additional backend-specific keyword arguments. Returns: List of tuples of IRIs for each matching row. \"\"\" def update ( self , update_object : str , ** kwargs ): \"\"\"Update triplestore with SPARQL. Arguments: query_object: String with the SPARQL query. kwargs: Additional backend-specific keyword arguments. Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" def bind ( self , prefix : str , namespace : str ) -> Namespace : \"\"\"Bind prefix to namespace. Should only be defined if the backend supports namespaces. \"\"\" def namespaces ( self ) -> dict : \"\"\"Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. \"\"\" @classmethod def create_database ( cls , database : str , ** kwargs ): \"\"\"Create a new database in backend. Parameters: database: Name of the new database. kwargs: Keyword arguments passed to the backend create_database() method. Note: This is a class method, which operates on the backend triplestore without connecting to it. \"\"\" @classmethod def remove_database ( cls , database : str , ** kwargs ): \"\"\"Remove a database in backend. Parameters: database: Name of the database to be removed. kwargs: Keyword arguments passed to the backend remove_database() method. Note: This is a class method, which operates on the backend triplestore without connecting to it. \"\"\" @classmethod def list_databases ( cls , ** kwargs ): \"\"\"For backends that supports multiple databases, list of all databases. Parameters: kwargs: Keyword arguments passed to the backend list_database() method. Note: This is a class method, which operates on the backend triplestore without connecting to it. \"\"\" Source code in tripper/interface.py class ITriplestore ( Protocol ): '''Interface for triplestore backends. In addition to the methods specified by this interface, a backend may also implement the following optional methods: ```python def __init__(self, base_iri: str = None, **kwargs): \"\"\"Initialise triplestore. Arguments: base_iri: Optional base IRI to initiate the triplestore from. kwargs: Additional keyword arguments passed to the backend. \"\"\" def parse( self, source: Union[str, Path, IO] = None, location: str = None, data: str = None, format: str = None, **kwargs ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Arguments: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. kwargs: Additional backend-specific parameters controlling the parsing. \"\"\" def serialize( self, destination: Union[str, Path, IO] = None, format: str ='xml', **kwargs ): \"\"\"Serialise to destination. Arguments: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Additional backend-specific parameters controlling the serialisation. Returns: Serialised string if `destination` is None. \"\"\" def query(self, query_object: str, **kwargs) -> List[Tuple[str, ...]]: \"\"\"SPARQL query. Arguments: query_object: String with the SPARQL query. kwargs: Additional backend-specific keyword arguments. Returns: List of tuples of IRIs for each matching row. \"\"\" def update(self, update_object: str, **kwargs): \"\"\"Update triplestore with SPARQL. Arguments: query_object: String with the SPARQL query. kwargs: Additional backend-specific keyword arguments. Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" def bind(self, prefix: str, namespace: str) -> Namespace: \"\"\"Bind prefix to namespace. Should only be defined if the backend supports namespaces. \"\"\" def namespaces(self) -> dict: \"\"\"Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. \"\"\" @classmethod def create_database(cls, database: str, **kwargs): \"\"\"Create a new database in backend. Parameters: database: Name of the new database. kwargs: Keyword arguments passed to the backend create_database() method. Note: This is a class method, which operates on the backend triplestore without connecting to it. \"\"\" @classmethod def remove_database(cls, database: str, **kwargs): \"\"\"Remove a database in backend. Parameters: database: Name of the database to be removed. kwargs: Keyword arguments passed to the backend remove_database() method. Note: This is a class method, which operates on the backend triplestore without connecting to it. \"\"\" @classmethod def list_databases(cls, **kwargs): \"\"\"For backends that supports multiple databases, list of all databases. Parameters: kwargs: Keyword arguments passed to the backend list_database() method. Note: This is a class method, which operates on the backend triplestore without connecting to it. \"\"\" ``` ''' def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples. Arguments: triple: A `(s, p, o)` tuple where `s`, `p` and `o` should either be None (matching anything) or an exact IRI to match. \"\"\" def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples. Arguments: triples: A sequence of `(s, p, o)` tuples to add to the triplestore. \"\"\" def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\"","title":"ITriplestore"},{"location":"api_reference/interface/#tripper.interface.ITriplestore.add_triples","text":"Add a sequence of triples. Parameters: Name Type Description Default triples Sequence[Triple] A sequence of (s, p, o) tuples to add to the triplestore. required Source code in tripper/interface.py def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples. Arguments: triples: A sequence of `(s, p, o)` tuples to add to the triplestore. \"\"\"","title":"add_triples()"},{"location":"api_reference/interface/#tripper.interface.ITriplestore.remove","text":"Remove all matching triples from the backend. Source code in tripper/interface.py def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\"","title":"remove()"},{"location":"api_reference/interface/#tripper.interface.ITriplestore.triples","text":"Returns a generator over matching triples. Parameters: Name Type Description Default triple Triple A (s, p, o) tuple where s , p and o should either be None (matching anything) or an exact IRI to match. required Source code in tripper/interface.py def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples. Arguments: triple: A `(s, p, o)` tuple where `s`, `p` and `o` should either be None (matching anything) or an exact IRI to match. \"\"\"","title":"triples()"},{"location":"api_reference/literal/","text":"literal \u00b6 Literal rdf values. Literal ( str ) \u00b6 A literal RDF value. Parameters: Name Type Description Default value Union[datetime, bytes, bytearray, bool, int, float, str] The literal value. See the datatypes class attribute for valid supported data types. A localised string is provided as a string with lang set to a language code. required lang Optional[str] A standard language code, like \"en\", \"no\", etc. Implies that the value is a localised string. required datatype Any Explicit specification of the type of value . Should not be combined with lang . required Source code in tripper/literal.py class Literal ( str ): \"\"\"A literal RDF value. Arguments: value (Union[datetime, bytes, bytearray, bool, int, float, str]): The literal value. See the `datatypes` class attribute for valid supported data types. A localised string is provided as a string with `lang` set to a language code. lang (Optional[str]): A standard language code, like \"en\", \"no\", etc. Implies that the `value` is a localised string. datatype (Any): Explicit specification of the type of `value`. Should not be combined with `lang`. \"\"\" lang : \"Union[str, None]\" datatype : \"Any\" # Note that the order of datatypes matters - it is used by # utils.parse_literal() when inferring the datatype of a literal. datatypes = { datetime : ( XSD . dateTime ,), bytes : ( XSD . hexBinary ,), bytearray : ( XSD . hexBinary ,), bool : ( XSD . boolean ,), int : ( XSD . integer , XSD . int , XSD . short , XSD . long , XSD . nonPositiveInteger , XSD . negativeInteger , XSD . unsignedInt , XSD . unsignedShort , XSD . unsignedLong , XSD . byte , XSD . unsignedByte , ), float : ( XSD . double , XSD . decimal , XSD . dateTimeStamp , XSD . real , XSD . rational ), str : ( XSD . string , RDF . PlainLiteral , RDF . XMLLiteral , RDFS . Literal , XSD . anyURI , XSD . language , XSD . Name , XSD . NMName , XSD . normalizedString , XSD . token , XSD . NMTOKEN , ), } def __new__ ( cls , value : \"Union[datetime, bytes, bytearray, bool, int, float, str]\" , lang : \"Optional[str]\" = None , datatype : \"Optional[Any]\" = None , ): string = super () . __new__ ( cls , value ) if lang : if datatype : raise TypeError ( \"A literal can only have one of `lang` or `datatype`.\" ) string . lang = str ( lang ) string . datatype = None else : string . lang = None if datatype : string . datatype = cls . datatypes . get ( datatype , ( datatype ,))[ 0 ] elif isinstance ( value , str ): string . datatype = None elif isinstance ( value , bool ): string . datatype = XSD . boolean elif isinstance ( value , int ): string . datatype = XSD . integer elif isinstance ( value , float ): string . datatype = XSD . double elif isinstance ( value , ( bytes , bytearray )): # Re-initialize the value anew, similarly to what is done in the first # line of this method. string = super () . __new__ ( cls , value . hex ()) string . lang = None string . datatype = XSD . hexBinary elif isinstance ( value , datetime ): string . datatype = XSD . dateTime # TODO: # - XSD.base64Binary # - XSD.byte, XSD.unsignedByte else : string . datatype = None return string # These two methods are commeted out for now because they cause # the DLite example/mapping/mappingfunc.py example to fail. # # It seems that these methods cause the datatype be changed to # an \"h\" in some relations added by the add_function() method. # def __hash__(self): # return hash((str(self), self.lang, self.datatype)) # def __eq__(self, other): # if isinstance(other, Literal): # return ( # str(self) == str(other) # and self.lang == other.lang # and self.datatype == other.datatype # ) # return str(self) == str(other) def __repr__ ( self ) -> str : lang = f \", lang=' { self . lang } '\" if self . lang else \"\" datatype = f \", datatype=' { self . datatype } '\" if self . datatype else \"\" return f \"Literal(' { self } ' { lang }{ datatype } )\" value = property ( fget = lambda self : self . to_python (), doc = \"Appropriate python datatype derived from this RDF literal.\" , ) def to_python ( self ): \"\"\"Returns an appropriate python datatype derived from this RDF literal.\"\"\" value = str ( self ) if self . datatype == XSD . boolean : value = False if self == \"False\" else bool ( self ) elif self . datatype in self . datatypes [ int ]: value = int ( self ) elif self . datatype in self . datatypes [ float ]: value = float ( self ) elif self . datatype == XSD . hexBinary : value = self . encode () elif self . datatype == XSD . dateTime : value = datetime . fromisoformat ( self ) elif self . datatype and self . datatype not in self . datatypes [ str ]: warnings . warn ( f \"unknown datatype: { self . datatype } - assuming string\" ) return value def n3 ( self ) -> str : # pylint: disable=invalid-name \"\"\"Returns a representation in n3 format.\"\"\" if self . lang : return f '\" { self } \"@ { self . lang } ' if self . datatype : return f '\" { self } \"^^ { self . datatype } ' return f '\" { self } \"' value property readonly \u00b6 Appropriate python datatype derived from this RDF literal. __new__ ( cls , value , lang = None , datatype = None ) special staticmethod \u00b6 Create and return a new object. See help(type) for accurate signature. Source code in tripper/literal.py def __new__ ( cls , value : \"Union[datetime, bytes, bytearray, bool, int, float, str]\" , lang : \"Optional[str]\" = None , datatype : \"Optional[Any]\" = None , ): string = super () . __new__ ( cls , value ) if lang : if datatype : raise TypeError ( \"A literal can only have one of `lang` or `datatype`.\" ) string . lang = str ( lang ) string . datatype = None else : string . lang = None if datatype : string . datatype = cls . datatypes . get ( datatype , ( datatype ,))[ 0 ] elif isinstance ( value , str ): string . datatype = None elif isinstance ( value , bool ): string . datatype = XSD . boolean elif isinstance ( value , int ): string . datatype = XSD . integer elif isinstance ( value , float ): string . datatype = XSD . double elif isinstance ( value , ( bytes , bytearray )): # Re-initialize the value anew, similarly to what is done in the first # line of this method. string = super () . __new__ ( cls , value . hex ()) string . lang = None string . datatype = XSD . hexBinary elif isinstance ( value , datetime ): string . datatype = XSD . dateTime # TODO: # - XSD.base64Binary # - XSD.byte, XSD.unsignedByte else : string . datatype = None return string n3 ( self ) \u00b6 Returns a representation in n3 format. Source code in tripper/literal.py def n3 ( self ) -> str : # pylint: disable=invalid-name \"\"\"Returns a representation in n3 format.\"\"\" if self . lang : return f '\" { self } \"@ { self . lang } ' if self . datatype : return f '\" { self } \"^^ { self . datatype } ' return f '\" { self } \"' to_python ( self ) \u00b6 Returns an appropriate python datatype derived from this RDF literal. Source code in tripper/literal.py def to_python ( self ): \"\"\"Returns an appropriate python datatype derived from this RDF literal.\"\"\" value = str ( self ) if self . datatype == XSD . boolean : value = False if self == \"False\" else bool ( self ) elif self . datatype in self . datatypes [ int ]: value = int ( self ) elif self . datatype in self . datatypes [ float ]: value = float ( self ) elif self . datatype == XSD . hexBinary : value = self . encode () elif self . datatype == XSD . dateTime : value = datetime . fromisoformat ( self ) elif self . datatype and self . datatype not in self . datatypes [ str ]: warnings . warn ( f \"unknown datatype: { self . datatype } - assuming string\" ) return value","title":"literal"},{"location":"api_reference/literal/#literal","text":"Literal rdf values.","title":"literal"},{"location":"api_reference/literal/#tripper.literal.Literal","text":"A literal RDF value. Parameters: Name Type Description Default value Union[datetime, bytes, bytearray, bool, int, float, str] The literal value. See the datatypes class attribute for valid supported data types. A localised string is provided as a string with lang set to a language code. required lang Optional[str] A standard language code, like \"en\", \"no\", etc. Implies that the value is a localised string. required datatype Any Explicit specification of the type of value . Should not be combined with lang . required Source code in tripper/literal.py class Literal ( str ): \"\"\"A literal RDF value. Arguments: value (Union[datetime, bytes, bytearray, bool, int, float, str]): The literal value. See the `datatypes` class attribute for valid supported data types. A localised string is provided as a string with `lang` set to a language code. lang (Optional[str]): A standard language code, like \"en\", \"no\", etc. Implies that the `value` is a localised string. datatype (Any): Explicit specification of the type of `value`. Should not be combined with `lang`. \"\"\" lang : \"Union[str, None]\" datatype : \"Any\" # Note that the order of datatypes matters - it is used by # utils.parse_literal() when inferring the datatype of a literal. datatypes = { datetime : ( XSD . dateTime ,), bytes : ( XSD . hexBinary ,), bytearray : ( XSD . hexBinary ,), bool : ( XSD . boolean ,), int : ( XSD . integer , XSD . int , XSD . short , XSD . long , XSD . nonPositiveInteger , XSD . negativeInteger , XSD . unsignedInt , XSD . unsignedShort , XSD . unsignedLong , XSD . byte , XSD . unsignedByte , ), float : ( XSD . double , XSD . decimal , XSD . dateTimeStamp , XSD . real , XSD . rational ), str : ( XSD . string , RDF . PlainLiteral , RDF . XMLLiteral , RDFS . Literal , XSD . anyURI , XSD . language , XSD . Name , XSD . NMName , XSD . normalizedString , XSD . token , XSD . NMTOKEN , ), } def __new__ ( cls , value : \"Union[datetime, bytes, bytearray, bool, int, float, str]\" , lang : \"Optional[str]\" = None , datatype : \"Optional[Any]\" = None , ): string = super () . __new__ ( cls , value ) if lang : if datatype : raise TypeError ( \"A literal can only have one of `lang` or `datatype`.\" ) string . lang = str ( lang ) string . datatype = None else : string . lang = None if datatype : string . datatype = cls . datatypes . get ( datatype , ( datatype ,))[ 0 ] elif isinstance ( value , str ): string . datatype = None elif isinstance ( value , bool ): string . datatype = XSD . boolean elif isinstance ( value , int ): string . datatype = XSD . integer elif isinstance ( value , float ): string . datatype = XSD . double elif isinstance ( value , ( bytes , bytearray )): # Re-initialize the value anew, similarly to what is done in the first # line of this method. string = super () . __new__ ( cls , value . hex ()) string . lang = None string . datatype = XSD . hexBinary elif isinstance ( value , datetime ): string . datatype = XSD . dateTime # TODO: # - XSD.base64Binary # - XSD.byte, XSD.unsignedByte else : string . datatype = None return string # These two methods are commeted out for now because they cause # the DLite example/mapping/mappingfunc.py example to fail. # # It seems that these methods cause the datatype be changed to # an \"h\" in some relations added by the add_function() method. # def __hash__(self): # return hash((str(self), self.lang, self.datatype)) # def __eq__(self, other): # if isinstance(other, Literal): # return ( # str(self) == str(other) # and self.lang == other.lang # and self.datatype == other.datatype # ) # return str(self) == str(other) def __repr__ ( self ) -> str : lang = f \", lang=' { self . lang } '\" if self . lang else \"\" datatype = f \", datatype=' { self . datatype } '\" if self . datatype else \"\" return f \"Literal(' { self } ' { lang }{ datatype } )\" value = property ( fget = lambda self : self . to_python (), doc = \"Appropriate python datatype derived from this RDF literal.\" , ) def to_python ( self ): \"\"\"Returns an appropriate python datatype derived from this RDF literal.\"\"\" value = str ( self ) if self . datatype == XSD . boolean : value = False if self == \"False\" else bool ( self ) elif self . datatype in self . datatypes [ int ]: value = int ( self ) elif self . datatype in self . datatypes [ float ]: value = float ( self ) elif self . datatype == XSD . hexBinary : value = self . encode () elif self . datatype == XSD . dateTime : value = datetime . fromisoformat ( self ) elif self . datatype and self . datatype not in self . datatypes [ str ]: warnings . warn ( f \"unknown datatype: { self . datatype } - assuming string\" ) return value def n3 ( self ) -> str : # pylint: disable=invalid-name \"\"\"Returns a representation in n3 format.\"\"\" if self . lang : return f '\" { self } \"@ { self . lang } ' if self . datatype : return f '\" { self } \"^^ { self . datatype } ' return f '\" { self } \"'","title":"Literal"},{"location":"api_reference/literal/#tripper.literal.Literal.value","text":"Appropriate python datatype derived from this RDF literal.","title":"value"},{"location":"api_reference/literal/#tripper.literal.Literal.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in tripper/literal.py def __new__ ( cls , value : \"Union[datetime, bytes, bytearray, bool, int, float, str]\" , lang : \"Optional[str]\" = None , datatype : \"Optional[Any]\" = None , ): string = super () . __new__ ( cls , value ) if lang : if datatype : raise TypeError ( \"A literal can only have one of `lang` or `datatype`.\" ) string . lang = str ( lang ) string . datatype = None else : string . lang = None if datatype : string . datatype = cls . datatypes . get ( datatype , ( datatype ,))[ 0 ] elif isinstance ( value , str ): string . datatype = None elif isinstance ( value , bool ): string . datatype = XSD . boolean elif isinstance ( value , int ): string . datatype = XSD . integer elif isinstance ( value , float ): string . datatype = XSD . double elif isinstance ( value , ( bytes , bytearray )): # Re-initialize the value anew, similarly to what is done in the first # line of this method. string = super () . __new__ ( cls , value . hex ()) string . lang = None string . datatype = XSD . hexBinary elif isinstance ( value , datetime ): string . datatype = XSD . dateTime # TODO: # - XSD.base64Binary # - XSD.byte, XSD.unsignedByte else : string . datatype = None return string","title":"__new__()"},{"location":"api_reference/literal/#tripper.literal.Literal.n3","text":"Returns a representation in n3 format. Source code in tripper/literal.py def n3 ( self ) -> str : # pylint: disable=invalid-name \"\"\"Returns a representation in n3 format.\"\"\" if self . lang : return f '\" { self } \"@ { self . lang } ' if self . datatype : return f '\" { self } \"^^ { self . datatype } ' return f '\" { self } \"'","title":"n3()"},{"location":"api_reference/literal/#tripper.literal.Literal.to_python","text":"Returns an appropriate python datatype derived from this RDF literal. Source code in tripper/literal.py def to_python ( self ): \"\"\"Returns an appropriate python datatype derived from this RDF literal.\"\"\" value = str ( self ) if self . datatype == XSD . boolean : value = False if self == \"False\" else bool ( self ) elif self . datatype in self . datatypes [ int ]: value = int ( self ) elif self . datatype in self . datatypes [ float ]: value = float ( self ) elif self . datatype == XSD . hexBinary : value = self . encode () elif self . datatype == XSD . dateTime : value = datetime . fromisoformat ( self ) elif self . datatype and self . datatype not in self . datatypes [ str ]: warnings . warn ( f \"unknown datatype: { self . datatype } - assuming string\" ) return value","title":"to_python()"},{"location":"api_reference/namespace/","text":"namespace \u00b6 Provides a simple representation of namespaces. Namespace \u00b6 Represent a namespace. Parameters: Name Type Description Default iri IRI of namespace to represent. required label_annotations Sequence of label annotations. If given, check the underlying ontology during attribute access if the name correspond to a label. The label annotations should be ordered from highest to lowest precedense. If True is provided, label_annotations is set to (SKOS.prefLabel, RDF.label, SKOS.altLabel) . () check Whether to check underlying ontology if the IRI exists during attribute access. If true, NoSuchIRIError will be raised if the IRI does not exist in this namespace. False cachemode Should be one of: - Namespace.NO_CACHE: Turn off caching. - Namespace.USE_CACHE: Cache attributes as they are looked up. - Namespace.ONLY_CACHE: Cache all names at initialisation time. Do not access the triplestore after that. Default is NO_CACHE if neither label_annotations or check is given, otherwise USE_CACHE . -1 triplestore Use this triplestore for label lookup and checking. If not given, and either label_annotations or check are enabled, a new rdflib triplestore will be created. None triplestore_url Alternative URL to use for loading the underlying ontology if triplestore is not given. Defaults to iri . None Source code in tripper/namespace.py class Namespace : \"\"\"Represent a namespace. Arguments: iri: IRI of namespace to represent. label_annotations: Sequence of label annotations. If given, check the underlying ontology during attribute access if the name correspond to a label. The label annotations should be ordered from highest to lowest precedense. If True is provided, `label_annotations` is set to ``(SKOS.prefLabel, RDF.label, SKOS.altLabel)``. check: Whether to check underlying ontology if the IRI exists during attribute access. If true, NoSuchIRIError will be raised if the IRI does not exist in this namespace. cachemode: Should be one of: - Namespace.NO_CACHE: Turn off caching. - Namespace.USE_CACHE: Cache attributes as they are looked up. - Namespace.ONLY_CACHE: Cache all names at initialisation time. Do not access the triplestore after that. Default is `NO_CACHE` if neither `label_annotations` or `check` is given, otherwise `USE_CACHE`. triplestore: Use this triplestore for label lookup and checking. If not given, and either `label_annotations` or `check` are enabled, a new rdflib triplestore will be created. triplestore_url: Alternative URL to use for loading the underlying ontology if `triplestore` is not given. Defaults to `iri`. \"\"\" NO_CACHE = 0 USE_CACHE = 1 ONLY_CACHE = 2 __slots__ = ( \"_iri\" , \"_label_annotations\" , \"_check\" , \"_cache\" , \"_triplestore\" , ) def __init__ ( self , iri , label_annotations = (), check = False , cachemode =- 1 , triplestore = None , triplestore_url = None , ): if label_annotations is True : label_annotations = ( SKOS . prefLabel , RDF . label , SKOS . altLabel ) self . _iri = str ( iri ) self . _label_annotations = tuple ( label_annotations ) self . _check = bool ( check ) need_triplestore = bool ( check or label_annotations ) if cachemode == - 1 : cachemode = Namespace . ONLY_CACHE if need_triplestore else Namespace . NO_CACHE if need_triplestore and triplestore is None : # Import Triplestore here to break cyclic-import from .triplestore import ( # pylint: disable=import-outside-toplevel,cyclic-import Triplestore , ) triplestore = Triplestore ( \"rdflib\" , base_iri = iri , triplestore_url = triplestore_url ) self . _cache = {} if cachemode != Namespace . NO_CACHE else None # # FIXME: # Change this to only assigning the triplestore if cachemode is # ONLY_CACHE when we figure out a good way to pre-populate the # cache with IRIs from the triplestore. # # self._triplestore = ( # triplestore if cachemode != Namespace.ONLY_CACHE else None # ) self . _triplestore = triplestore if need_triplestore else None if cachemode != Namespace . NO_CACHE : self . _update_cache ( triplestore ) def _update_cache ( self , triplestore = None ): \"\"\"Update the internal cache from `triplestore`.\"\"\" if not triplestore : triplestore = self . _triplestore if not triplestore : raise NamespaceError ( \"`triplestore` argument needed for updating the cache\" ) if self . _cache is None : self . _cache = {} # Add (label, full_iri) pairs to cache for label in reversed ( self . _label_annotations ): self . _cache . update ( ( o , s ) for s , o in triplestore . subject_objects ( label ) if s . startswith ( self . _iri ) ) # Add (name, full_iri) pairs to cache # Currently we only check concepts that defines RDFS.isDefinedBy # relations. # Is there an efficient way to loop over all IRIs in this namespace? self . _cache . update ( ( s [ len ( self . _iri ) :], s ) for s in triplestore . subjects ( RDFS . isDefinedBy , self . _iri ) if s . startswith ( self . _iri ) ) def __getattr__ ( self , name ): if self . _cache and name in self . _cache : return self . _cache [ name ] if self . _triplestore : # Check if ``iri = self._iri + name`` is in the triplestore. # If so, add it to the cache. # We only need to check that generator returned by # `self._triplestore.predicate_objects(iri)` is non-empty. iri = self . _iri + name predicate_object = self . _triplestore . predicate_objects ( iri ) try : predicate_object . __next__ () except StopIteration : pass else : if self . _cache is not None : self . _cache [ name ] = iri return iri # Check for label annotations matching `name`. for label in self . _label_annotations : for s , o in self . _triplestore . subject_objects ( label ): if o == name and s . startswith ( self . _iri ): if self . _cache is not None : self . _cache [ name ] = s return s if self . _check : raise NoSuchIRIError ( self . _iri + name ) return self . _iri + name def __getitem__ ( self , key ): return self . __getattr__ ( key ) def __repr__ ( self ): return f \"Namespace( { self . _iri } )\" def __str__ ( self ): return self . _iri def __add__ ( self , other ): return self . _iri + str ( other ) def __hash__ ( self ): return hash ( self . _iri ) def __eq__ ( self , other ): return self . _iri == str ( other )","title":"namespace"},{"location":"api_reference/namespace/#namespace","text":"Provides a simple representation of namespaces.","title":"namespace"},{"location":"api_reference/namespace/#tripper.namespace.Namespace","text":"Represent a namespace. Parameters: Name Type Description Default iri IRI of namespace to represent. required label_annotations Sequence of label annotations. If given, check the underlying ontology during attribute access if the name correspond to a label. The label annotations should be ordered from highest to lowest precedense. If True is provided, label_annotations is set to (SKOS.prefLabel, RDF.label, SKOS.altLabel) . () check Whether to check underlying ontology if the IRI exists during attribute access. If true, NoSuchIRIError will be raised if the IRI does not exist in this namespace. False cachemode Should be one of: - Namespace.NO_CACHE: Turn off caching. - Namespace.USE_CACHE: Cache attributes as they are looked up. - Namespace.ONLY_CACHE: Cache all names at initialisation time. Do not access the triplestore after that. Default is NO_CACHE if neither label_annotations or check is given, otherwise USE_CACHE . -1 triplestore Use this triplestore for label lookup and checking. If not given, and either label_annotations or check are enabled, a new rdflib triplestore will be created. None triplestore_url Alternative URL to use for loading the underlying ontology if triplestore is not given. Defaults to iri . None Source code in tripper/namespace.py class Namespace : \"\"\"Represent a namespace. Arguments: iri: IRI of namespace to represent. label_annotations: Sequence of label annotations. If given, check the underlying ontology during attribute access if the name correspond to a label. The label annotations should be ordered from highest to lowest precedense. If True is provided, `label_annotations` is set to ``(SKOS.prefLabel, RDF.label, SKOS.altLabel)``. check: Whether to check underlying ontology if the IRI exists during attribute access. If true, NoSuchIRIError will be raised if the IRI does not exist in this namespace. cachemode: Should be one of: - Namespace.NO_CACHE: Turn off caching. - Namespace.USE_CACHE: Cache attributes as they are looked up. - Namespace.ONLY_CACHE: Cache all names at initialisation time. Do not access the triplestore after that. Default is `NO_CACHE` if neither `label_annotations` or `check` is given, otherwise `USE_CACHE`. triplestore: Use this triplestore for label lookup and checking. If not given, and either `label_annotations` or `check` are enabled, a new rdflib triplestore will be created. triplestore_url: Alternative URL to use for loading the underlying ontology if `triplestore` is not given. Defaults to `iri`. \"\"\" NO_CACHE = 0 USE_CACHE = 1 ONLY_CACHE = 2 __slots__ = ( \"_iri\" , \"_label_annotations\" , \"_check\" , \"_cache\" , \"_triplestore\" , ) def __init__ ( self , iri , label_annotations = (), check = False , cachemode =- 1 , triplestore = None , triplestore_url = None , ): if label_annotations is True : label_annotations = ( SKOS . prefLabel , RDF . label , SKOS . altLabel ) self . _iri = str ( iri ) self . _label_annotations = tuple ( label_annotations ) self . _check = bool ( check ) need_triplestore = bool ( check or label_annotations ) if cachemode == - 1 : cachemode = Namespace . ONLY_CACHE if need_triplestore else Namespace . NO_CACHE if need_triplestore and triplestore is None : # Import Triplestore here to break cyclic-import from .triplestore import ( # pylint: disable=import-outside-toplevel,cyclic-import Triplestore , ) triplestore = Triplestore ( \"rdflib\" , base_iri = iri , triplestore_url = triplestore_url ) self . _cache = {} if cachemode != Namespace . NO_CACHE else None # # FIXME: # Change this to only assigning the triplestore if cachemode is # ONLY_CACHE when we figure out a good way to pre-populate the # cache with IRIs from the triplestore. # # self._triplestore = ( # triplestore if cachemode != Namespace.ONLY_CACHE else None # ) self . _triplestore = triplestore if need_triplestore else None if cachemode != Namespace . NO_CACHE : self . _update_cache ( triplestore ) def _update_cache ( self , triplestore = None ): \"\"\"Update the internal cache from `triplestore`.\"\"\" if not triplestore : triplestore = self . _triplestore if not triplestore : raise NamespaceError ( \"`triplestore` argument needed for updating the cache\" ) if self . _cache is None : self . _cache = {} # Add (label, full_iri) pairs to cache for label in reversed ( self . _label_annotations ): self . _cache . update ( ( o , s ) for s , o in triplestore . subject_objects ( label ) if s . startswith ( self . _iri ) ) # Add (name, full_iri) pairs to cache # Currently we only check concepts that defines RDFS.isDefinedBy # relations. # Is there an efficient way to loop over all IRIs in this namespace? self . _cache . update ( ( s [ len ( self . _iri ) :], s ) for s in triplestore . subjects ( RDFS . isDefinedBy , self . _iri ) if s . startswith ( self . _iri ) ) def __getattr__ ( self , name ): if self . _cache and name in self . _cache : return self . _cache [ name ] if self . _triplestore : # Check if ``iri = self._iri + name`` is in the triplestore. # If so, add it to the cache. # We only need to check that generator returned by # `self._triplestore.predicate_objects(iri)` is non-empty. iri = self . _iri + name predicate_object = self . _triplestore . predicate_objects ( iri ) try : predicate_object . __next__ () except StopIteration : pass else : if self . _cache is not None : self . _cache [ name ] = iri return iri # Check for label annotations matching `name`. for label in self . _label_annotations : for s , o in self . _triplestore . subject_objects ( label ): if o == name and s . startswith ( self . _iri ): if self . _cache is not None : self . _cache [ name ] = s return s if self . _check : raise NoSuchIRIError ( self . _iri + name ) return self . _iri + name def __getitem__ ( self , key ): return self . __getattr__ ( key ) def __repr__ ( self ): return f \"Namespace( { self . _iri } )\" def __str__ ( self ): return self . _iri def __add__ ( self , other ): return self . _iri + str ( other ) def __hash__ ( self ): return hash ( self . _iri ) def __eq__ ( self , other ): return self . _iri == str ( other )","title":"Namespace"},{"location":"api_reference/triplestore/","text":"triplestore \u00b6 A module encapsulating different triplestores using the strategy design pattern. See https://raw.githubusercontent.com/EMMC-ASBL/tripper/master/README.md for an introduction. This module has no dependencies outside the standard library, but the triplestore backends may have. For developers: The usage of s , p , and o represent the different parts of an RDF Triple: subject, predicate, and object. Triplestore \u00b6 Provides a common frontend to a range of triplestore backends. Source code in tripper/triplestore.py class Triplestore : \"\"\"Provides a common frontend to a range of triplestore backends.\"\"\" default_namespaces = { \"xml\" : XML , \"rdf\" : RDF , \"rdfs\" : RDFS , \"xsd\" : XSD , \"owl\" : OWL , # \"skos\": SKOS, # \"dc\": DC, # \"dcterms\": DCTERMS, # \"foaf\": FOAF, # \"doap\": DOAP, # \"fno\": FNO, # \"emmo\": EMMO, # \"map\": MAP, # \"dm\": DM, } def __init__ ( self , backend : str , base_iri : \"Optional[str]\" = None , database : \"Optional[str]\" = None , ** kwargs , ) -> None : \"\"\"Initialise triplestore using the backend with the given name. Parameters: backend: Name of the backend module. base_iri: Base IRI used by the add_function() method when adding new triples. May also be used by the backend. database: Name of database to connect to (for backends that supports it). kwargs: Keyword arguments passed to the backend's __init__() method. \"\"\" module = import_module ( backend if \".\" in backend else f \"tripper.backends. { backend } \" ) cls = getattr ( module , f \" { backend . title () } Strategy\" ) self . base_iri = base_iri self . namespaces : \"Dict[str, Namespace]\" = {} self . closed = False self . backend_name = backend self . backend = cls ( base_iri = base_iri , database = database , ** kwargs ) # Keep functions in the triplestore for convienence even though # they usually do not belong to the triplestore per se. self . function_repo : \"Dict[str, Union[float, Callable[[], float], None]]\" = {} for prefix , namespace in self . default_namespaces . items (): self . bind ( prefix , namespace ) # Methods implemented by backend # ------------------------------ def triples ( # pylint: disable=redefined-builtin self , subject : \"Optional[Union[str, Triple]]\" = None , predicate : \"Optional[str]\" = None , object : \"Optional[Union[str, Literal]]\" = None , triple : \"Optional[Triple]\" = None , ) -> \"Generator[Triple, None, None]\" : \"\"\"Returns a generator over matching triples. Arguments: subject: If given, match triples with this subject. predicate: If given, match triples with this predicate. object: If given, match triples with this object. triple: Deprecated. A `(s, p, o)` tuple where `s`, `p` and `o` should either be None (matching anything) or an exact IRI to match. Returns: Generator over all matching triples. \"\"\" # __TODO__: Remove these lines when deprecated if triple or ( subject and not isinstance ( subject , str )): warnings . warn ( \"The `triple` argument is deprecated. Use `subject`, \" \"`predicate` and `object` arguments instead.\" , DeprecationWarning , stacklevel = 2 , ) if subject and not isinstance ( subject , str ): subject , predicate , object = subject elif triple : subject , predicate , object = triple return self . backend . triples (( subject , predicate , object )) def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples. Arguments: triples: A sequence of `(s, p, o)` tuples to add to the triplestore. \"\"\" self . backend . add_triples ( triples ) def remove ( # pylint: disable=redefined-builtin self , subject : \"Optional[Union[str, Triple]]\" = None , predicate : \"Optional[str]\" = None , object : \"Optional[Union[str, Literal]]\" = None , triple : \"Optional[Triple]\" = None , ) -> None : \"\"\"Remove all matching triples from the backend. Arguments: subject: If given, match triples with this subject. predicate: If given, match triples with this predicate. object: If given, match triples with this object. triple: Deprecated. A `(s, p, o)` tuple where `s`, `p` and `o` should either be None (matching anything) or an exact IRI to match. \"\"\" # __TODO__: Remove these lines when deprecated if triple or ( subject and not isinstance ( subject , str )): warnings . warn ( \"The `triple` argument is deprecated. Use `subject`, \" \"`predicate` and `object` arguments instead.\" , DeprecationWarning , stacklevel = 2 , ) if subject and not isinstance ( subject , str ): subject , predicate , object = subject elif triple : subject , predicate , object = triple return self . backend . remove (( subject , predicate , object )) # Methods optionally implemented by backend # ----------------------------------------- def close ( self ): \"\"\"Calls the backend close() method if it is implemented. Otherwise, this method has no effect. \"\"\" # It should be ok to call close() regardless of whether the backend # implements this method or not. Hence, don't call _check_method(). if not self . closed and hasattr ( self . backend , \"close\" ): self . backend . close () self . closed = True def parse ( self , source = None , format = None , ** kwargs # pylint: disable=redefined-builtin ) -> None : \"\"\"Parse source and add the resulting triples to triplestore. Parameters: source: File-like object or file name. format: Needed if format can not be inferred from source. kwargs: Keyword arguments passed to the backend. The rdflib backend supports e.g. `location` (absolute or relative URL) and `data` (string containing the data to be parsed) arguments. \"\"\" self . _check_method ( \"parse\" ) self . backend . parse ( source = source , format = format , ** kwargs ) if hasattr ( self . backend , \"namespaces\" ): for prefix , namespace in self . backend . namespaces () . items (): if prefix and prefix not in self . namespaces : self . namespaces [ prefix ] = Namespace ( namespace ) def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise triplestore. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the backend serialize() method. Returns: Serialized string if `destination` is None. \"\"\" self . _check_method ( \"serialize\" ) return self . backend . serialize ( destination = destination , format = format , ** kwargs ) def query ( self , query_object , ** kwargs ) -> \"List[Tuple[str, ...]]\" : \"\"\"SPARQL query. Parameters: query_object: String with the SPARQL query. kwargs: Keyword arguments passed to the backend query() method. Returns: List of tuples of IRIs for each matching row. Note: This method is intended for SELECT queries. Use the update() method for INSERT and DELETE queries. \"\"\" self . _check_method ( \"query\" ) return self . backend . query ( query_object = query_object , ** kwargs ) def update ( self , update_object , ** kwargs ) -> None : \"\"\"Update triplestore with SPARQL. Parameters: update_object: String with the SPARQL query. kwargs: Keyword arguments passed to the backend update() method. Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" self . _check_method ( \"update\" ) return self . backend . update ( update_object = update_object , ** kwargs ) def bind ( self , prefix : str , namespace : \"Union[str, Namespace]\" , ** kwargs ) -> Namespace : \"\"\"Bind prefix to namespace and return the new Namespace object. The new Namespace is created with `namespace` as IRI. Keyword arguments are passed to the Namespace() constructor. If `namespace` is None, the corresponding prefix is removed. \"\"\" if hasattr ( self . backend , \"bind\" ): self . backend . bind ( prefix , namespace ) if namespace is None : del self . namespaces [ prefix ] return None self . namespaces [ prefix ] = ( namespace if isinstance ( namespace , Namespace ) else Namespace ( namespace , ** kwargs ) ) return self . namespaces [ prefix ] @classmethod def create_database ( cls , backend : str , database : str , ** kwargs ): \"\"\"Create a new database in backend. Parameters: backend: Name of backend. database: Name of the new database. kwargs: Keyword arguments passed to the backend create_database() method. Note: This is a class method, which operates on the backend triplestore without connecting to it. \"\"\" cls . _check_backend_method ( backend , \"create_database\" ) backend_class = cls . _get_backend ( backend ) return backend_class . create_database ( database = database , ** kwargs ) @classmethod def remove_database ( cls , backend : str , database : str , ** kwargs ): \"\"\"Remove a database in backend. Parameters: backend: Name of backend. database: Name of the database to be removed. kwargs: Keyword arguments passed to the backend remove_database() method. Note: This is a class method, which operates on the backend triplestore without connecting to it. \"\"\" cls . _check_backend_method ( backend , \"remove_database\" ) backend_class = cls . _get_backend ( backend ) return backend_class . remove_database ( database = database , ** kwargs ) @classmethod def list_databases ( cls , backend : str , ** kwargs ): \"\"\"For backends that supports multiple databases, list of all databases. Parameters: backend: Name of backend. kwargs: Keyword arguments passed to the backend list_databases() method. Note: This is a class method, which operates on the backend triplestore without connecting to it. \"\"\" cls . _check_backend_method ( backend , \"list_databases\" ) backend_class = cls . _get_backend ( backend ) return backend_class . list_databases ( ** kwargs ) # Convenient methods # ------------------ # These methods are modelled after rdflib and provide some convinient # interfaces to the triples(), add_triples() and remove() methods # implemented by all backends. @classmethod def _get_backend ( cls , backend : str ): \"\"\"Returns the class implementing the given backend.\"\"\" module = import_module ( backend if \".\" in backend else f \"tripper.backends. { backend } \" ) return getattr ( module , f \" { backend . title () } Strategy\" ) @classmethod def _check_backend_method ( cls , backend : str , name : str ): \"\"\"Checks that `backend` has a method called `name`. Raises NotImplementedError if it hasn't. \"\"\" backend_class = cls . _get_backend ( backend ) if not hasattr ( backend_class , name ): raise NotImplementedError ( f 'Triplestore backend { backend !r} do not implement a \" { name } ()\" method.' ) def _check_method ( self , name ): \"\"\"Check that backend implements the given method.\"\"\" self . _check_backend_method ( self . backend_name , name ) def add ( self , triple : \"Triple\" ): \"\"\"Add `triple` to triplestore.\"\"\" self . add_triples ([ triple ]) def value ( # pylint: disable=redefined-builtin self , subject = None , predicate = None , object = None , default = None , any = False ): \"\"\"Return the value for a pair of two criteria. Useful if one knows that there may only be one value. Parameters: subject, predicate, object: Triple to match. default: Value to return if no matches are found. any: If true, return any matching value, otherwise raise UniquenessError. \"\"\" triple = self . triples (( subject , predicate , object )) try : value = next ( triple ) except StopIteration : return default if any : return value try : next ( triple ) except StopIteration : return value else : raise UniquenessError ( \"More than one match\" ) def subjects ( self , predicate = None , object = None # pylint: disable=redefined-builtin ): \"\"\"Returns a generator of subjects for given predicate and object.\"\"\" for s , _ , _ in self . triples ( predicate = predicate , object = object ): yield s def predicates ( self , subject = None , object = None # pylint: disable=redefined-builtin ): \"\"\"Returns a generator of predicates for given subject and object.\"\"\" for _ , p , _ in self . triples ( subject = subject , object = object ): yield p def objects ( self , subject = None , predicate = None ): \"\"\"Returns a generator of objects for given subject and predicate.\"\"\" for _ , _ , o in self . triples ( subject = subject , predicate = predicate ): yield o def subject_predicates ( self , object = None ): # pylint: disable=redefined-builtin \"\"\"Returns a generator of (subject, predicate) tuples for given object.\"\"\" for s , p , _ in self . triples ( object = object ): yield s , p def subject_objects ( self , predicate = None ): \"\"\"Returns a generator of (subject, object) tuples for given predicate.\"\"\" for s , _ , o in self . triples ( predicate = predicate ): yield s , o def predicate_objects ( self , subject = None ): \"\"\"Returns a generator of (predicate, object) tuples for given subject.\"\"\" for _ , p , o in self . triples ( subject = subject ): yield p , o def set ( self , triple ): \"\"\"Convenience method to update the value of object. Removes any existing triples for subject and predicate before adding the given `triple`. \"\"\" s , p , _ = triple self . remove (( s , p , None )) self . add ( triple ) def has ( self , subject = None , predicate = None , object = None ): # pylint: disable=redefined-builtin \"\"\"Returns true if the triplestore has any triple matching the give subject, predicate and/or object.\"\"\" triple = self . triples ( subject = subject , predicate = predicate , object = object ) try : next ( triple ) except StopIteration : return False return True # Methods providing additional functionality # ------------------------------------------ def expand_iri ( self , iri : str ): \"\"\"Return the full IRI if `iri` is prefixed. Otherwise `iri` is returned.\"\"\" match = re . match ( _MATCH_PREFIXED_IRI , iri ) if match : prefix , name = match . groups () if prefix not in self . namespaces : raise NamespaceError ( f \"unknown namespace: { prefix } \" ) return f \" { self . namespaces [ prefix ] }{ name } \" return iri def prefix_iri ( self , iri : str , require_prefixed : bool = False ): \"\"\"Return prefixed IRI. This is the reverse of expand_iri(). If `require_prefixed` is true, a NamespaceError exception is raised if no prefix can be found. \"\"\" if not re . match ( _MATCH_PREFIXED_IRI , iri ): for prefix , namespace in self . namespaces . items (): if iri . startswith ( str ( namespace )): return f \" { prefix } : { iri [ len ( str ( namespace )):] } \" if require_prefixed : raise NamespaceError ( f \"No prefix defined for IRI: { iri } \" ) return iri def map ( self , source : str , target : str , cost : \"Optional[Union[float, Callable]]\" = None , target_cost : bool = True , ): \"\"\"Add 'mapsTo' relation to the triplestore. Parameters: source: Source IRI. target: IRI of target ontological concept. cost: User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the value of the mapped quantity as input and returning the cost as a float. target_cost: Whether the cost is assigned to mapping steps that have `target` as output. \"\"\" return self . add_mapsTo ( target = target , source = source , cost = cost , target_cost = target_cost , ) def add_mapsTo ( self , target : str , source : str , property_name : \"Optional[str]\" = None , cost : \"Optional[Union[float, Callable]]\" = None , target_cost : bool = True , ): \"\"\"Add 'mapsTo' relation to triplestore. Parameters: target: IRI of target ontological concept. source: Source IRI (or entity object). property_name: Name of property if `source` is an entity or an entity IRI. cost: User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the value of the mapped quantity as input and returning the cost as a float. target_cost: Whether the cost is assigned to mapping steps that have `target` as output. Note: This is equivalent to the `map()` method, but reverts the two first arguments and adds the `property_name` argument. \"\"\" self . bind ( \"map\" , MAP ) if not property_name and not isinstance ( source , str ): raise TriplestoreError ( \"`property_name` is required when `target` is not a string.\" ) target = self . expand_iri ( target ) source = self . expand_iri ( infer_iri ( source )) if property_name : self . add (( f \" { source } # { property_name } \" , MAP . mapsTo , target )) else : self . add (( source , MAP . mapsTo , target )) if cost is not None : dest = target if target_cost else source self . _add_cost ( cost , dest ) def add_function ( self , func : \"Union[Callable, str]\" , expects : \"Union[str, Sequence, Mapping]\" = (), returns : \"Union[str, Sequence]\" = (), base_iri : \"Optional[str]\" = None , standard : str = \"fno\" , cost : \"Optional[Union[float, Callable]]\" = None , ): \"\"\"Inspect function and add triples describing it to the triplestore. Parameters: func: Function to describe. Should either be a callable or a string with a unique function IRI. expects: Sequence of IRIs to ontological concepts corresponding to positional arguments of `func`. May also be given as a dict mapping argument names to corresponding ontological IRIs. returns: IRI of return value. May also be given as a sequence of IRIs, if multiple values are returned. base_iri: Base of the IRI representing the function in the knowledge base. Defaults to the base IRI of the triplestore. standard: Name of ontology to use when describing the function. Valid values are: - \"emmo\": Elementary Multiperspective Material Ontology (EMMO) - \"fno\": Function Ontology (FnO) cost: User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the same arguments as `func` returning the cost as a float. Returns: func_iri: IRI of the added function. \"\"\" if isinstance ( expects , str ): expects = [ expects ] if isinstance ( returns , str ): returns = [ returns ] method = getattr ( self , f \"_add_function_ { standard } \" ) func_iri = method ( func , expects , returns , base_iri ) self . function_repo [ func_iri ] = func if callable ( func ) else None if cost is not None : self . _add_cost ( cost , func_iri ) return func_iri def _add_cost ( self , cost : \"Union[float, Callable[[], float]]\" , dest_iri ): \"\"\"Help function that adds `cost` to destination IRI `dest_iri`. `cost` should be either a float or a Callable returning a float. If `cost` is a callable it is just referred to with a literal id and is not ontologically described as a function. The expected input arguments depends on the context, which is why this function is not part of the public API. Use the add_mapsTo() and add_function() methods instead. \"\"\" if self . has ( dest_iri , DM . hasCost ): warnings . warn ( f \"A cost is already assigned to IRI: { dest_iri } \" ) elif callable ( cost ): cost_id = f \"cost_function { function_id ( cost ) } \" self . add (( dest_iri , DM . hasCost , Literal ( cost_id ))) self . function_repo [ cost_id ] = cost else : self . add (( dest_iri , DM . hasCost , Literal ( cost ))) def _add_function_fno ( self , func , expects , returns , base_iri ): \"\"\"Implementing add_function() for FnO.\"\"\" self . bind ( \"fno\" , FNO ) self . bind ( \"dcterms\" , DCTERMS ) self . bind ( \"map\" , MAP ) if base_iri is None : base_iri = self . base_iri if self . base_iri else \":\" if callable ( func ): fid = function_id ( func ) # Function id func_iri = f \" { base_iri }{ func . __name__ } _ { fid } \" doc_string = inspect . getdoc ( func ) parlist = f \"_: { func . __name__ }{ fid } _parlist\" outlist = f \"_: { func . __name__ }{ fid } _outlist\" if isinstance ( expects , Sequence ): pars = list ( zip ( expects , inspect . signature ( func ) . parameters )) else : pars = [ ( expects [ par ], par ) for par in inspect . signature ( func ) . parameters ] elif isinstance ( func , str ): func_iri = func doc_string = \"\" parlist = f \"_: { func_iri } _parlist\" outlist = f \"_: { func_iri } _outlist\" pariris = expects if isinstance ( expects , Sequence ) else expects . values () parnames = [ split_iri ( pariri )[ 1 ] for pariri in pariris ] pars = list ( zip ( pariris , parnames )) else : raise TypeError ( \"`func` should be either a callable or an IRI\" ) self . add (( func_iri , RDF . type , FNO . Function )) self . add (( func_iri , FNO . expects , parlist )) self . add (( func_iri , FNO . returns , outlist )) if doc_string : self . add (( func_iri , DCTERMS . description , en ( doc_string ))) lst = parlist for i , ( iri , parname ) in enumerate ( pars ): lst_next = f \" { parlist }{ i + 2 } \" if i < len ( pars ) - 1 else RDF . nil par = f \" { func_iri } _parameter { i + 1 } _ { parname } \" self . add (( par , RDF . type , FNO . Parameter )) self . add (( par , RDFS . label , en ( parname ))) self . add (( par , MAP . mapsTo , iri )) self . add (( lst , RDF . first , par )) self . add (( lst , RDF . rest , lst_next )) lst = lst_next lst = outlist for i , iri in enumerate ( returns ): lst_next = f \" { outlist }{ i + 2 } \" if i < len ( returns ) - 1 else RDF . nil val = f \" { func_iri } _output { i + 1 } \" self . add (( val , RDF . type , FNO . Output )) self . add (( val , MAP . mapsTo , iri )) self . add (( lst , RDF . first , val )) self . add (( lst , RDF . rest , lst_next )) lst = lst_next return func_iri def _add_function_emmo ( self , func , expects , returns , base_iri ): \"\"\"Implementing add_function() method for the \"emmo\" standard.\"\"\" # pylint: disable=too-many-locals self . bind ( \"emmo\" , EMMO ) self . bind ( \"dcterms\" , DCTERMS ) self . bind ( \"map\" , MAP ) # Hardcode EMMO IRIs to avoid slow lookup Task = EMMO . EMMO_4299e344_a321_4ef2_a744_bacfcce80afc DataSet = EMMO . EMMO_194e367c_9783_4bf5_96d0_9ad597d48d9a hasInput = EMMO . EMMO_36e69413_8c59_4799_946c_10b05d266e22 hasOutput = EMMO . EMMO_c4bace1d_4db0_4cd3_87e9_18122bae2840 # Software = EMMO.EMMO_8681074a_e225_4e38_b586_e85b0f43ce38 # hasSoftware = EMMO.Software # TODO: fix when EMMO has hasSoftware if base_iri is None : base_iri = self . base_iri if self . base_iri else \":\" if callable ( func ): fid = function_id ( func ) # Function id func_iri = f \" { base_iri }{ func . __name__ } _ { fid } \" doc_string = inspect . getdoc ( func ) if isinstance ( expects , Sequence ): pars = list ( zip ( inspect . signature ( func ) . parameters , expects )) else : pars = expects . items () elif isinstance ( func , str ): func_iri = func doc_string = \"\" pariris = expects if isinstance ( expects , Sequence ) else expects . values () parnames = [ split_iri ( pariri )[ 1 ] for pariri in pariris ] pars = list ( zip ( parnames , pariris )) else : raise TypeError ( \"`func` should be either a callable or an IRI\" ) self . add (( func_iri , RDF . type , Task )) for parname , iri in pars : par = f \" { func_iri } _input_ { parname } \" self . add (( par , RDF . type , DataSet )) self . add (( par , RDFS . label , en ( parname ))) self . add (( par , MAP . mapsTo , iri )) self . add (( func_iri , hasInput , par )) for i , iri in enumerate ( returns ): val = f \" { func_iri } _output { i + 1 } \" self . add (( val , RDF . type , DataSet )) self . add (( val , MAP . mapsTo , iri )) self . add (( func_iri , hasOutput , val )) if doc_string : self . add (( func_iri , DCTERMS . description , en ( doc_string ))) return func_iri __init__ ( self , backend , base_iri = None , database = None , ** kwargs ) special \u00b6 Initialise triplestore using the backend with the given name. Parameters: Name Type Description Default backend str Name of the backend module. required base_iri 'Optional[str]' Base IRI used by the add_function() method when adding new triples. May also be used by the backend. None database 'Optional[str]' Name of database to connect to (for backends that supports it). None kwargs Keyword arguments passed to the backend's init () method. {} Source code in tripper/triplestore.py def __init__ ( self , backend : str , base_iri : \"Optional[str]\" = None , database : \"Optional[str]\" = None , ** kwargs , ) -> None : \"\"\"Initialise triplestore using the backend with the given name. Parameters: backend: Name of the backend module. base_iri: Base IRI used by the add_function() method when adding new triples. May also be used by the backend. database: Name of database to connect to (for backends that supports it). kwargs: Keyword arguments passed to the backend's __init__() method. \"\"\" module = import_module ( backend if \".\" in backend else f \"tripper.backends. { backend } \" ) cls = getattr ( module , f \" { backend . title () } Strategy\" ) self . base_iri = base_iri self . namespaces : \"Dict[str, Namespace]\" = {} self . closed = False self . backend_name = backend self . backend = cls ( base_iri = base_iri , database = database , ** kwargs ) # Keep functions in the triplestore for convienence even though # they usually do not belong to the triplestore per se. self . function_repo : \"Dict[str, Union[float, Callable[[], float], None]]\" = {} for prefix , namespace in self . default_namespaces . items (): self . bind ( prefix , namespace ) add ( self , triple ) \u00b6 Add triple to triplestore. Source code in tripper/triplestore.py def add ( self , triple : \"Triple\" ): \"\"\"Add `triple` to triplestore.\"\"\" self . add_triples ([ triple ]) add_function ( self , func , expects = (), returns = (), base_iri = None , standard = 'fno' , cost = None ) \u00b6 Inspect function and add triples describing it to the triplestore. Parameters: Name Type Description Default func 'Union[Callable, str]' Function to describe. Should either be a callable or a string with a unique function IRI. required expects 'Union[str, Sequence, Mapping]' Sequence of IRIs to ontological concepts corresponding to positional arguments of func . May also be given as a dict mapping argument names to corresponding ontological IRIs. () returns 'Union[str, Sequence]' IRI of return value. May also be given as a sequence of IRIs, if multiple values are returned. () base_iri 'Optional[str]' Base of the IRI representing the function in the knowledge base. Defaults to the base IRI of the triplestore. None standard str Name of ontology to use when describing the function. Valid values are: - \"emmo\": Elementary Multiperspective Material Ontology (EMMO) - \"fno\": Function Ontology (FnO) 'fno' cost 'Optional[Union[float, Callable]]' User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the same arguments as func returning the cost as a float. None Returns: Type Description func_iri IRI of the added function. Source code in tripper/triplestore.py def add_function ( self , func : \"Union[Callable, str]\" , expects : \"Union[str, Sequence, Mapping]\" = (), returns : \"Union[str, Sequence]\" = (), base_iri : \"Optional[str]\" = None , standard : str = \"fno\" , cost : \"Optional[Union[float, Callable]]\" = None , ): \"\"\"Inspect function and add triples describing it to the triplestore. Parameters: func: Function to describe. Should either be a callable or a string with a unique function IRI. expects: Sequence of IRIs to ontological concepts corresponding to positional arguments of `func`. May also be given as a dict mapping argument names to corresponding ontological IRIs. returns: IRI of return value. May also be given as a sequence of IRIs, if multiple values are returned. base_iri: Base of the IRI representing the function in the knowledge base. Defaults to the base IRI of the triplestore. standard: Name of ontology to use when describing the function. Valid values are: - \"emmo\": Elementary Multiperspective Material Ontology (EMMO) - \"fno\": Function Ontology (FnO) cost: User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the same arguments as `func` returning the cost as a float. Returns: func_iri: IRI of the added function. \"\"\" if isinstance ( expects , str ): expects = [ expects ] if isinstance ( returns , str ): returns = [ returns ] method = getattr ( self , f \"_add_function_ { standard } \" ) func_iri = method ( func , expects , returns , base_iri ) self . function_repo [ func_iri ] = func if callable ( func ) else None if cost is not None : self . _add_cost ( cost , func_iri ) return func_iri add_mapsTo ( self , target , source , property_name = None , cost = None , target_cost = True ) \u00b6 Add 'mapsTo' relation to triplestore. Parameters: Name Type Description Default target str IRI of target ontological concept. required source str Source IRI (or entity object). required property_name 'Optional[str]' Name of property if source is an entity or an entity IRI. None cost 'Optional[Union[float, Callable]]' User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the value of the mapped quantity as input and returning the cost as a float. None target_cost bool Whether the cost is assigned to mapping steps that have target as output. True Note This is equivalent to the map() method, but reverts the two first arguments and adds the property_name argument. Source code in tripper/triplestore.py def add_mapsTo ( self , target : str , source : str , property_name : \"Optional[str]\" = None , cost : \"Optional[Union[float, Callable]]\" = None , target_cost : bool = True , ): \"\"\"Add 'mapsTo' relation to triplestore. Parameters: target: IRI of target ontological concept. source: Source IRI (or entity object). property_name: Name of property if `source` is an entity or an entity IRI. cost: User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the value of the mapped quantity as input and returning the cost as a float. target_cost: Whether the cost is assigned to mapping steps that have `target` as output. Note: This is equivalent to the `map()` method, but reverts the two first arguments and adds the `property_name` argument. \"\"\" self . bind ( \"map\" , MAP ) if not property_name and not isinstance ( source , str ): raise TriplestoreError ( \"`property_name` is required when `target` is not a string.\" ) target = self . expand_iri ( target ) source = self . expand_iri ( infer_iri ( source )) if property_name : self . add (( f \" { source } # { property_name } \" , MAP . mapsTo , target )) else : self . add (( source , MAP . mapsTo , target )) if cost is not None : dest = target if target_cost else source self . _add_cost ( cost , dest ) add_triples ( self , triples ) \u00b6 Add a sequence of triples. Parameters: Name Type Description Default triples 'Sequence[Triple]' A sequence of (s, p, o) tuples to add to the triplestore. required Source code in tripper/triplestore.py def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples. Arguments: triples: A sequence of `(s, p, o)` tuples to add to the triplestore. \"\"\" self . backend . add_triples ( triples ) bind ( self , prefix , namespace , ** kwargs ) \u00b6 Bind prefix to namespace and return the new Namespace object. The new Namespace is created with namespace as IRI. Keyword arguments are passed to the Namespace() constructor. If namespace is None, the corresponding prefix is removed. Source code in tripper/triplestore.py def bind ( self , prefix : str , namespace : \"Union[str, Namespace]\" , ** kwargs ) -> Namespace : \"\"\"Bind prefix to namespace and return the new Namespace object. The new Namespace is created with `namespace` as IRI. Keyword arguments are passed to the Namespace() constructor. If `namespace` is None, the corresponding prefix is removed. \"\"\" if hasattr ( self . backend , \"bind\" ): self . backend . bind ( prefix , namespace ) if namespace is None : del self . namespaces [ prefix ] return None self . namespaces [ prefix ] = ( namespace if isinstance ( namespace , Namespace ) else Namespace ( namespace , ** kwargs ) ) return self . namespaces [ prefix ] close ( self ) \u00b6 Calls the backend close() method if it is implemented. Otherwise, this method has no effect. Source code in tripper/triplestore.py def close ( self ): \"\"\"Calls the backend close() method if it is implemented. Otherwise, this method has no effect. \"\"\" # It should be ok to call close() regardless of whether the backend # implements this method or not. Hence, don't call _check_method(). if not self . closed and hasattr ( self . backend , \"close\" ): self . backend . close () self . closed = True create_database ( backend , database , ** kwargs ) classmethod \u00b6 Create a new database in backend. Parameters: Name Type Description Default backend str Name of backend. required database str Name of the new database. required kwargs Keyword arguments passed to the backend create_database() method. {} Note This is a class method, which operates on the backend triplestore without connecting to it. Source code in tripper/triplestore.py @classmethod def create_database ( cls , backend : str , database : str , ** kwargs ): \"\"\"Create a new database in backend. Parameters: backend: Name of backend. database: Name of the new database. kwargs: Keyword arguments passed to the backend create_database() method. Note: This is a class method, which operates on the backend triplestore without connecting to it. \"\"\" cls . _check_backend_method ( backend , \"create_database\" ) backend_class = cls . _get_backend ( backend ) return backend_class . create_database ( database = database , ** kwargs ) expand_iri ( self , iri ) \u00b6 Return the full IRI if iri is prefixed. Otherwise iri is returned. Source code in tripper/triplestore.py def expand_iri ( self , iri : str ): \"\"\"Return the full IRI if `iri` is prefixed. Otherwise `iri` is returned.\"\"\" match = re . match ( _MATCH_PREFIXED_IRI , iri ) if match : prefix , name = match . groups () if prefix not in self . namespaces : raise NamespaceError ( f \"unknown namespace: { prefix } \" ) return f \" { self . namespaces [ prefix ] }{ name } \" return iri has ( self , subject = None , predicate = None , object = None ) \u00b6 Returns true if the triplestore has any triple matching the give subject, predicate and/or object. Source code in tripper/triplestore.py def has ( self , subject = None , predicate = None , object = None ): # pylint: disable=redefined-builtin \"\"\"Returns true if the triplestore has any triple matching the give subject, predicate and/or object.\"\"\" triple = self . triples ( subject = subject , predicate = predicate , object = object ) try : next ( triple ) except StopIteration : return False return True list_databases ( backend , ** kwargs ) classmethod \u00b6 For backends that supports multiple databases, list of all databases. Parameters: Name Type Description Default backend str Name of backend. required kwargs Keyword arguments passed to the backend list_databases() method. {} Note This is a class method, which operates on the backend triplestore without connecting to it. Source code in tripper/triplestore.py @classmethod def list_databases ( cls , backend : str , ** kwargs ): \"\"\"For backends that supports multiple databases, list of all databases. Parameters: backend: Name of backend. kwargs: Keyword arguments passed to the backend list_databases() method. Note: This is a class method, which operates on the backend triplestore without connecting to it. \"\"\" cls . _check_backend_method ( backend , \"list_databases\" ) backend_class = cls . _get_backend ( backend ) return backend_class . list_databases ( ** kwargs ) map ( self , source , target , cost = None , target_cost = True ) \u00b6 Add 'mapsTo' relation to the triplestore. Parameters: Name Type Description Default source str Source IRI. required target str IRI of target ontological concept. required cost 'Optional[Union[float, Callable]]' User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the value of the mapped quantity as input and returning the cost as a float. None target_cost bool Whether the cost is assigned to mapping steps that have target as output. True Source code in tripper/triplestore.py def map ( self , source : str , target : str , cost : \"Optional[Union[float, Callable]]\" = None , target_cost : bool = True , ): \"\"\"Add 'mapsTo' relation to the triplestore. Parameters: source: Source IRI. target: IRI of target ontological concept. cost: User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the value of the mapped quantity as input and returning the cost as a float. target_cost: Whether the cost is assigned to mapping steps that have `target` as output. \"\"\" return self . add_mapsTo ( target = target , source = source , cost = cost , target_cost = target_cost , ) objects ( self , subject = None , predicate = None ) \u00b6 Returns a generator of objects for given subject and predicate. Source code in tripper/triplestore.py def objects ( self , subject = None , predicate = None ): \"\"\"Returns a generator of objects for given subject and predicate.\"\"\" for _ , _ , o in self . triples ( subject = subject , predicate = predicate ): yield o parse ( self , source = None , format = None , ** kwargs ) \u00b6 Parse source and add the resulting triples to triplestore. Parameters: Name Type Description Default source File-like object or file name. None format Needed if format can not be inferred from source. None kwargs Keyword arguments passed to the backend. The rdflib backend supports e.g. location (absolute or relative URL) and data (string containing the data to be parsed) arguments. {} Source code in tripper/triplestore.py def parse ( self , source = None , format = None , ** kwargs # pylint: disable=redefined-builtin ) -> None : \"\"\"Parse source and add the resulting triples to triplestore. Parameters: source: File-like object or file name. format: Needed if format can not be inferred from source. kwargs: Keyword arguments passed to the backend. The rdflib backend supports e.g. `location` (absolute or relative URL) and `data` (string containing the data to be parsed) arguments. \"\"\" self . _check_method ( \"parse\" ) self . backend . parse ( source = source , format = format , ** kwargs ) if hasattr ( self . backend , \"namespaces\" ): for prefix , namespace in self . backend . namespaces () . items (): if prefix and prefix not in self . namespaces : self . namespaces [ prefix ] = Namespace ( namespace ) predicate_objects ( self , subject = None ) \u00b6 Returns a generator of (predicate, object) tuples for given subject. Source code in tripper/triplestore.py def predicate_objects ( self , subject = None ): \"\"\"Returns a generator of (predicate, object) tuples for given subject.\"\"\" for _ , p , o in self . triples ( subject = subject ): yield p , o predicates ( self , subject = None , object = None ) \u00b6 Returns a generator of predicates for given subject and object. Source code in tripper/triplestore.py def predicates ( self , subject = None , object = None # pylint: disable=redefined-builtin ): \"\"\"Returns a generator of predicates for given subject and object.\"\"\" for _ , p , _ in self . triples ( subject = subject , object = object ): yield p prefix_iri ( self , iri , require_prefixed = False ) \u00b6 Return prefixed IRI. This is the reverse of expand_iri(). If require_prefixed is true, a NamespaceError exception is raised if no prefix can be found. Source code in tripper/triplestore.py def prefix_iri ( self , iri : str , require_prefixed : bool = False ): \"\"\"Return prefixed IRI. This is the reverse of expand_iri(). If `require_prefixed` is true, a NamespaceError exception is raised if no prefix can be found. \"\"\" if not re . match ( _MATCH_PREFIXED_IRI , iri ): for prefix , namespace in self . namespaces . items (): if iri . startswith ( str ( namespace )): return f \" { prefix } : { iri [ len ( str ( namespace )):] } \" if require_prefixed : raise NamespaceError ( f \"No prefix defined for IRI: { iri } \" ) return iri query ( self , query_object , ** kwargs ) \u00b6 SPARQL query. Parameters: Name Type Description Default query_object String with the SPARQL query. required kwargs Keyword arguments passed to the backend query() method. {} Returns: Type Description 'List[Tuple[str, ...]]' List of tuples of IRIs for each matching row. Note This method is intended for SELECT queries. Use the update() method for INSERT and DELETE queries. Source code in tripper/triplestore.py def query ( self , query_object , ** kwargs ) -> \"List[Tuple[str, ...]]\" : \"\"\"SPARQL query. Parameters: query_object: String with the SPARQL query. kwargs: Keyword arguments passed to the backend query() method. Returns: List of tuples of IRIs for each matching row. Note: This method is intended for SELECT queries. Use the update() method for INSERT and DELETE queries. \"\"\" self . _check_method ( \"query\" ) return self . backend . query ( query_object = query_object , ** kwargs ) remove ( self , subject = None , predicate = None , object = None , triple = None ) \u00b6 Remove all matching triples from the backend. Parameters: Name Type Description Default subject 'Optional[Union[str, Triple]]' If given, match triples with this subject. None predicate 'Optional[str]' If given, match triples with this predicate. None object 'Optional[Union[str, Literal]]' If given, match triples with this object. None triple 'Optional[Triple]' Deprecated. A (s, p, o) tuple where s , p and o should either be None (matching anything) or an exact IRI to match. None Source code in tripper/triplestore.py def remove ( # pylint: disable=redefined-builtin self , subject : \"Optional[Union[str, Triple]]\" = None , predicate : \"Optional[str]\" = None , object : \"Optional[Union[str, Literal]]\" = None , triple : \"Optional[Triple]\" = None , ) -> None : \"\"\"Remove all matching triples from the backend. Arguments: subject: If given, match triples with this subject. predicate: If given, match triples with this predicate. object: If given, match triples with this object. triple: Deprecated. A `(s, p, o)` tuple where `s`, `p` and `o` should either be None (matching anything) or an exact IRI to match. \"\"\" # __TODO__: Remove these lines when deprecated if triple or ( subject and not isinstance ( subject , str )): warnings . warn ( \"The `triple` argument is deprecated. Use `subject`, \" \"`predicate` and `object` arguments instead.\" , DeprecationWarning , stacklevel = 2 , ) if subject and not isinstance ( subject , str ): subject , predicate , object = subject elif triple : subject , predicate , object = triple return self . backend . remove (( subject , predicate , object )) remove_database ( backend , database , ** kwargs ) classmethod \u00b6 Remove a database in backend. Parameters: Name Type Description Default backend str Name of backend. required database str Name of the database to be removed. required kwargs Keyword arguments passed to the backend remove_database() method. {} Note This is a class method, which operates on the backend triplestore without connecting to it. Source code in tripper/triplestore.py @classmethod def remove_database ( cls , backend : str , database : str , ** kwargs ): \"\"\"Remove a database in backend. Parameters: backend: Name of backend. database: Name of the database to be removed. kwargs: Keyword arguments passed to the backend remove_database() method. Note: This is a class method, which operates on the backend triplestore without connecting to it. \"\"\" cls . _check_backend_method ( backend , \"remove_database\" ) backend_class = cls . _get_backend ( backend ) return backend_class . remove_database ( database = database , ** kwargs ) serialize ( self , destination = None , format = 'turtle' , ** kwargs ) \u00b6 Serialise triplestore. Parameters: Name Type Description Default destination File name or object to write to. If None, the serialisation is returned. None format Format to serialise as. Supported formats, depends on the backend. 'turtle' kwargs Passed to the backend serialize() method. {} Returns: Type Description 'Union[None, str]' Serialized string if destination is None. Source code in tripper/triplestore.py def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise triplestore. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the backend serialize() method. Returns: Serialized string if `destination` is None. \"\"\" self . _check_method ( \"serialize\" ) return self . backend . serialize ( destination = destination , format = format , ** kwargs ) set ( self , triple ) \u00b6 Convenience method to update the value of object. Removes any existing triples for subject and predicate before adding the given triple . Source code in tripper/triplestore.py def set ( self , triple ): \"\"\"Convenience method to update the value of object. Removes any existing triples for subject and predicate before adding the given `triple`. \"\"\" s , p , _ = triple self . remove (( s , p , None )) self . add ( triple ) subject_objects ( self , predicate = None ) \u00b6 Returns a generator of (subject, object) tuples for given predicate. Source code in tripper/triplestore.py def subject_objects ( self , predicate = None ): \"\"\"Returns a generator of (subject, object) tuples for given predicate.\"\"\" for s , _ , o in self . triples ( predicate = predicate ): yield s , o subject_predicates ( self , object = None ) \u00b6 Returns a generator of (subject, predicate) tuples for given object. Source code in tripper/triplestore.py def subject_predicates ( self , object = None ): # pylint: disable=redefined-builtin \"\"\"Returns a generator of (subject, predicate) tuples for given object.\"\"\" for s , p , _ in self . triples ( object = object ): yield s , p subjects ( self , predicate = None , object = None ) \u00b6 Returns a generator of subjects for given predicate and object. Source code in tripper/triplestore.py def subjects ( self , predicate = None , object = None # pylint: disable=redefined-builtin ): \"\"\"Returns a generator of subjects for given predicate and object.\"\"\" for s , _ , _ in self . triples ( predicate = predicate , object = object ): yield s triples ( self , subject = None , predicate = None , object = None , triple = None ) \u00b6 Returns a generator over matching triples. Parameters: Name Type Description Default subject 'Optional[Union[str, Triple]]' If given, match triples with this subject. None predicate 'Optional[str]' If given, match triples with this predicate. None object 'Optional[Union[str, Literal]]' If given, match triples with this object. None triple 'Optional[Triple]' Deprecated. A (s, p, o) tuple where s , p and o should either be None (matching anything) or an exact IRI to match. None Returns: Type Description 'Generator[Triple, None, None]' Generator over all matching triples. Source code in tripper/triplestore.py def triples ( # pylint: disable=redefined-builtin self , subject : \"Optional[Union[str, Triple]]\" = None , predicate : \"Optional[str]\" = None , object : \"Optional[Union[str, Literal]]\" = None , triple : \"Optional[Triple]\" = None , ) -> \"Generator[Triple, None, None]\" : \"\"\"Returns a generator over matching triples. Arguments: subject: If given, match triples with this subject. predicate: If given, match triples with this predicate. object: If given, match triples with this object. triple: Deprecated. A `(s, p, o)` tuple where `s`, `p` and `o` should either be None (matching anything) or an exact IRI to match. Returns: Generator over all matching triples. \"\"\" # __TODO__: Remove these lines when deprecated if triple or ( subject and not isinstance ( subject , str )): warnings . warn ( \"The `triple` argument is deprecated. Use `subject`, \" \"`predicate` and `object` arguments instead.\" , DeprecationWarning , stacklevel = 2 , ) if subject and not isinstance ( subject , str ): subject , predicate , object = subject elif triple : subject , predicate , object = triple return self . backend . triples (( subject , predicate , object )) update ( self , update_object , ** kwargs ) \u00b6 Update triplestore with SPARQL. Parameters: Name Type Description Default update_object String with the SPARQL query. required kwargs Keyword arguments passed to the backend update() method. {} Note This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. Source code in tripper/triplestore.py def update ( self , update_object , ** kwargs ) -> None : \"\"\"Update triplestore with SPARQL. Parameters: update_object: String with the SPARQL query. kwargs: Keyword arguments passed to the backend update() method. Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" self . _check_method ( \"update\" ) return self . backend . update ( update_object = update_object , ** kwargs ) value ( self , subject = None , predicate = None , object = None , default = None , any = False ) \u00b6 Return the value for a pair of two criteria. Useful if one knows that there may only be one value. Parameters: Name Type Description Default subject, predicate, object Triple to match. required default Value to return if no matches are found. None any If true, return any matching value, otherwise raise UniquenessError. False Source code in tripper/triplestore.py def value ( # pylint: disable=redefined-builtin self , subject = None , predicate = None , object = None , default = None , any = False ): \"\"\"Return the value for a pair of two criteria. Useful if one knows that there may only be one value. Parameters: subject, predicate, object: Triple to match. default: Value to return if no matches are found. any: If true, return any matching value, otherwise raise UniquenessError. \"\"\" triple = self . triples (( subject , predicate , object )) try : value = next ( triple ) except StopIteration : return default if any : return value try : next ( triple ) except StopIteration : return value else : raise UniquenessError ( \"More than one match\" )","title":"triplestore"},{"location":"api_reference/triplestore/#triplestore","text":"A module encapsulating different triplestores using the strategy design pattern. See https://raw.githubusercontent.com/EMMC-ASBL/tripper/master/README.md for an introduction. This module has no dependencies outside the standard library, but the triplestore backends may have. For developers: The usage of s , p , and o represent the different parts of an RDF Triple: subject, predicate, and object.","title":"triplestore"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore","text":"Provides a common frontend to a range of triplestore backends. Source code in tripper/triplestore.py class Triplestore : \"\"\"Provides a common frontend to a range of triplestore backends.\"\"\" default_namespaces = { \"xml\" : XML , \"rdf\" : RDF , \"rdfs\" : RDFS , \"xsd\" : XSD , \"owl\" : OWL , # \"skos\": SKOS, # \"dc\": DC, # \"dcterms\": DCTERMS, # \"foaf\": FOAF, # \"doap\": DOAP, # \"fno\": FNO, # \"emmo\": EMMO, # \"map\": MAP, # \"dm\": DM, } def __init__ ( self , backend : str , base_iri : \"Optional[str]\" = None , database : \"Optional[str]\" = None , ** kwargs , ) -> None : \"\"\"Initialise triplestore using the backend with the given name. Parameters: backend: Name of the backend module. base_iri: Base IRI used by the add_function() method when adding new triples. May also be used by the backend. database: Name of database to connect to (for backends that supports it). kwargs: Keyword arguments passed to the backend's __init__() method. \"\"\" module = import_module ( backend if \".\" in backend else f \"tripper.backends. { backend } \" ) cls = getattr ( module , f \" { backend . title () } Strategy\" ) self . base_iri = base_iri self . namespaces : \"Dict[str, Namespace]\" = {} self . closed = False self . backend_name = backend self . backend = cls ( base_iri = base_iri , database = database , ** kwargs ) # Keep functions in the triplestore for convienence even though # they usually do not belong to the triplestore per se. self . function_repo : \"Dict[str, Union[float, Callable[[], float], None]]\" = {} for prefix , namespace in self . default_namespaces . items (): self . bind ( prefix , namespace ) # Methods implemented by backend # ------------------------------ def triples ( # pylint: disable=redefined-builtin self , subject : \"Optional[Union[str, Triple]]\" = None , predicate : \"Optional[str]\" = None , object : \"Optional[Union[str, Literal]]\" = None , triple : \"Optional[Triple]\" = None , ) -> \"Generator[Triple, None, None]\" : \"\"\"Returns a generator over matching triples. Arguments: subject: If given, match triples with this subject. predicate: If given, match triples with this predicate. object: If given, match triples with this object. triple: Deprecated. A `(s, p, o)` tuple where `s`, `p` and `o` should either be None (matching anything) or an exact IRI to match. Returns: Generator over all matching triples. \"\"\" # __TODO__: Remove these lines when deprecated if triple or ( subject and not isinstance ( subject , str )): warnings . warn ( \"The `triple` argument is deprecated. Use `subject`, \" \"`predicate` and `object` arguments instead.\" , DeprecationWarning , stacklevel = 2 , ) if subject and not isinstance ( subject , str ): subject , predicate , object = subject elif triple : subject , predicate , object = triple return self . backend . triples (( subject , predicate , object )) def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples. Arguments: triples: A sequence of `(s, p, o)` tuples to add to the triplestore. \"\"\" self . backend . add_triples ( triples ) def remove ( # pylint: disable=redefined-builtin self , subject : \"Optional[Union[str, Triple]]\" = None , predicate : \"Optional[str]\" = None , object : \"Optional[Union[str, Literal]]\" = None , triple : \"Optional[Triple]\" = None , ) -> None : \"\"\"Remove all matching triples from the backend. Arguments: subject: If given, match triples with this subject. predicate: If given, match triples with this predicate. object: If given, match triples with this object. triple: Deprecated. A `(s, p, o)` tuple where `s`, `p` and `o` should either be None (matching anything) or an exact IRI to match. \"\"\" # __TODO__: Remove these lines when deprecated if triple or ( subject and not isinstance ( subject , str )): warnings . warn ( \"The `triple` argument is deprecated. Use `subject`, \" \"`predicate` and `object` arguments instead.\" , DeprecationWarning , stacklevel = 2 , ) if subject and not isinstance ( subject , str ): subject , predicate , object = subject elif triple : subject , predicate , object = triple return self . backend . remove (( subject , predicate , object )) # Methods optionally implemented by backend # ----------------------------------------- def close ( self ): \"\"\"Calls the backend close() method if it is implemented. Otherwise, this method has no effect. \"\"\" # It should be ok to call close() regardless of whether the backend # implements this method or not. Hence, don't call _check_method(). if not self . closed and hasattr ( self . backend , \"close\" ): self . backend . close () self . closed = True def parse ( self , source = None , format = None , ** kwargs # pylint: disable=redefined-builtin ) -> None : \"\"\"Parse source and add the resulting triples to triplestore. Parameters: source: File-like object or file name. format: Needed if format can not be inferred from source. kwargs: Keyword arguments passed to the backend. The rdflib backend supports e.g. `location` (absolute or relative URL) and `data` (string containing the data to be parsed) arguments. \"\"\" self . _check_method ( \"parse\" ) self . backend . parse ( source = source , format = format , ** kwargs ) if hasattr ( self . backend , \"namespaces\" ): for prefix , namespace in self . backend . namespaces () . items (): if prefix and prefix not in self . namespaces : self . namespaces [ prefix ] = Namespace ( namespace ) def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise triplestore. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the backend serialize() method. Returns: Serialized string if `destination` is None. \"\"\" self . _check_method ( \"serialize\" ) return self . backend . serialize ( destination = destination , format = format , ** kwargs ) def query ( self , query_object , ** kwargs ) -> \"List[Tuple[str, ...]]\" : \"\"\"SPARQL query. Parameters: query_object: String with the SPARQL query. kwargs: Keyword arguments passed to the backend query() method. Returns: List of tuples of IRIs for each matching row. Note: This method is intended for SELECT queries. Use the update() method for INSERT and DELETE queries. \"\"\" self . _check_method ( \"query\" ) return self . backend . query ( query_object = query_object , ** kwargs ) def update ( self , update_object , ** kwargs ) -> None : \"\"\"Update triplestore with SPARQL. Parameters: update_object: String with the SPARQL query. kwargs: Keyword arguments passed to the backend update() method. Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" self . _check_method ( \"update\" ) return self . backend . update ( update_object = update_object , ** kwargs ) def bind ( self , prefix : str , namespace : \"Union[str, Namespace]\" , ** kwargs ) -> Namespace : \"\"\"Bind prefix to namespace and return the new Namespace object. The new Namespace is created with `namespace` as IRI. Keyword arguments are passed to the Namespace() constructor. If `namespace` is None, the corresponding prefix is removed. \"\"\" if hasattr ( self . backend , \"bind\" ): self . backend . bind ( prefix , namespace ) if namespace is None : del self . namespaces [ prefix ] return None self . namespaces [ prefix ] = ( namespace if isinstance ( namespace , Namespace ) else Namespace ( namespace , ** kwargs ) ) return self . namespaces [ prefix ] @classmethod def create_database ( cls , backend : str , database : str , ** kwargs ): \"\"\"Create a new database in backend. Parameters: backend: Name of backend. database: Name of the new database. kwargs: Keyword arguments passed to the backend create_database() method. Note: This is a class method, which operates on the backend triplestore without connecting to it. \"\"\" cls . _check_backend_method ( backend , \"create_database\" ) backend_class = cls . _get_backend ( backend ) return backend_class . create_database ( database = database , ** kwargs ) @classmethod def remove_database ( cls , backend : str , database : str , ** kwargs ): \"\"\"Remove a database in backend. Parameters: backend: Name of backend. database: Name of the database to be removed. kwargs: Keyword arguments passed to the backend remove_database() method. Note: This is a class method, which operates on the backend triplestore without connecting to it. \"\"\" cls . _check_backend_method ( backend , \"remove_database\" ) backend_class = cls . _get_backend ( backend ) return backend_class . remove_database ( database = database , ** kwargs ) @classmethod def list_databases ( cls , backend : str , ** kwargs ): \"\"\"For backends that supports multiple databases, list of all databases. Parameters: backend: Name of backend. kwargs: Keyword arguments passed to the backend list_databases() method. Note: This is a class method, which operates on the backend triplestore without connecting to it. \"\"\" cls . _check_backend_method ( backend , \"list_databases\" ) backend_class = cls . _get_backend ( backend ) return backend_class . list_databases ( ** kwargs ) # Convenient methods # ------------------ # These methods are modelled after rdflib and provide some convinient # interfaces to the triples(), add_triples() and remove() methods # implemented by all backends. @classmethod def _get_backend ( cls , backend : str ): \"\"\"Returns the class implementing the given backend.\"\"\" module = import_module ( backend if \".\" in backend else f \"tripper.backends. { backend } \" ) return getattr ( module , f \" { backend . title () } Strategy\" ) @classmethod def _check_backend_method ( cls , backend : str , name : str ): \"\"\"Checks that `backend` has a method called `name`. Raises NotImplementedError if it hasn't. \"\"\" backend_class = cls . _get_backend ( backend ) if not hasattr ( backend_class , name ): raise NotImplementedError ( f 'Triplestore backend { backend !r} do not implement a \" { name } ()\" method.' ) def _check_method ( self , name ): \"\"\"Check that backend implements the given method.\"\"\" self . _check_backend_method ( self . backend_name , name ) def add ( self , triple : \"Triple\" ): \"\"\"Add `triple` to triplestore.\"\"\" self . add_triples ([ triple ]) def value ( # pylint: disable=redefined-builtin self , subject = None , predicate = None , object = None , default = None , any = False ): \"\"\"Return the value for a pair of two criteria. Useful if one knows that there may only be one value. Parameters: subject, predicate, object: Triple to match. default: Value to return if no matches are found. any: If true, return any matching value, otherwise raise UniquenessError. \"\"\" triple = self . triples (( subject , predicate , object )) try : value = next ( triple ) except StopIteration : return default if any : return value try : next ( triple ) except StopIteration : return value else : raise UniquenessError ( \"More than one match\" ) def subjects ( self , predicate = None , object = None # pylint: disable=redefined-builtin ): \"\"\"Returns a generator of subjects for given predicate and object.\"\"\" for s , _ , _ in self . triples ( predicate = predicate , object = object ): yield s def predicates ( self , subject = None , object = None # pylint: disable=redefined-builtin ): \"\"\"Returns a generator of predicates for given subject and object.\"\"\" for _ , p , _ in self . triples ( subject = subject , object = object ): yield p def objects ( self , subject = None , predicate = None ): \"\"\"Returns a generator of objects for given subject and predicate.\"\"\" for _ , _ , o in self . triples ( subject = subject , predicate = predicate ): yield o def subject_predicates ( self , object = None ): # pylint: disable=redefined-builtin \"\"\"Returns a generator of (subject, predicate) tuples for given object.\"\"\" for s , p , _ in self . triples ( object = object ): yield s , p def subject_objects ( self , predicate = None ): \"\"\"Returns a generator of (subject, object) tuples for given predicate.\"\"\" for s , _ , o in self . triples ( predicate = predicate ): yield s , o def predicate_objects ( self , subject = None ): \"\"\"Returns a generator of (predicate, object) tuples for given subject.\"\"\" for _ , p , o in self . triples ( subject = subject ): yield p , o def set ( self , triple ): \"\"\"Convenience method to update the value of object. Removes any existing triples for subject and predicate before adding the given `triple`. \"\"\" s , p , _ = triple self . remove (( s , p , None )) self . add ( triple ) def has ( self , subject = None , predicate = None , object = None ): # pylint: disable=redefined-builtin \"\"\"Returns true if the triplestore has any triple matching the give subject, predicate and/or object.\"\"\" triple = self . triples ( subject = subject , predicate = predicate , object = object ) try : next ( triple ) except StopIteration : return False return True # Methods providing additional functionality # ------------------------------------------ def expand_iri ( self , iri : str ): \"\"\"Return the full IRI if `iri` is prefixed. Otherwise `iri` is returned.\"\"\" match = re . match ( _MATCH_PREFIXED_IRI , iri ) if match : prefix , name = match . groups () if prefix not in self . namespaces : raise NamespaceError ( f \"unknown namespace: { prefix } \" ) return f \" { self . namespaces [ prefix ] }{ name } \" return iri def prefix_iri ( self , iri : str , require_prefixed : bool = False ): \"\"\"Return prefixed IRI. This is the reverse of expand_iri(). If `require_prefixed` is true, a NamespaceError exception is raised if no prefix can be found. \"\"\" if not re . match ( _MATCH_PREFIXED_IRI , iri ): for prefix , namespace in self . namespaces . items (): if iri . startswith ( str ( namespace )): return f \" { prefix } : { iri [ len ( str ( namespace )):] } \" if require_prefixed : raise NamespaceError ( f \"No prefix defined for IRI: { iri } \" ) return iri def map ( self , source : str , target : str , cost : \"Optional[Union[float, Callable]]\" = None , target_cost : bool = True , ): \"\"\"Add 'mapsTo' relation to the triplestore. Parameters: source: Source IRI. target: IRI of target ontological concept. cost: User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the value of the mapped quantity as input and returning the cost as a float. target_cost: Whether the cost is assigned to mapping steps that have `target` as output. \"\"\" return self . add_mapsTo ( target = target , source = source , cost = cost , target_cost = target_cost , ) def add_mapsTo ( self , target : str , source : str , property_name : \"Optional[str]\" = None , cost : \"Optional[Union[float, Callable]]\" = None , target_cost : bool = True , ): \"\"\"Add 'mapsTo' relation to triplestore. Parameters: target: IRI of target ontological concept. source: Source IRI (or entity object). property_name: Name of property if `source` is an entity or an entity IRI. cost: User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the value of the mapped quantity as input and returning the cost as a float. target_cost: Whether the cost is assigned to mapping steps that have `target` as output. Note: This is equivalent to the `map()` method, but reverts the two first arguments and adds the `property_name` argument. \"\"\" self . bind ( \"map\" , MAP ) if not property_name and not isinstance ( source , str ): raise TriplestoreError ( \"`property_name` is required when `target` is not a string.\" ) target = self . expand_iri ( target ) source = self . expand_iri ( infer_iri ( source )) if property_name : self . add (( f \" { source } # { property_name } \" , MAP . mapsTo , target )) else : self . add (( source , MAP . mapsTo , target )) if cost is not None : dest = target if target_cost else source self . _add_cost ( cost , dest ) def add_function ( self , func : \"Union[Callable, str]\" , expects : \"Union[str, Sequence, Mapping]\" = (), returns : \"Union[str, Sequence]\" = (), base_iri : \"Optional[str]\" = None , standard : str = \"fno\" , cost : \"Optional[Union[float, Callable]]\" = None , ): \"\"\"Inspect function and add triples describing it to the triplestore. Parameters: func: Function to describe. Should either be a callable or a string with a unique function IRI. expects: Sequence of IRIs to ontological concepts corresponding to positional arguments of `func`. May also be given as a dict mapping argument names to corresponding ontological IRIs. returns: IRI of return value. May also be given as a sequence of IRIs, if multiple values are returned. base_iri: Base of the IRI representing the function in the knowledge base. Defaults to the base IRI of the triplestore. standard: Name of ontology to use when describing the function. Valid values are: - \"emmo\": Elementary Multiperspective Material Ontology (EMMO) - \"fno\": Function Ontology (FnO) cost: User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the same arguments as `func` returning the cost as a float. Returns: func_iri: IRI of the added function. \"\"\" if isinstance ( expects , str ): expects = [ expects ] if isinstance ( returns , str ): returns = [ returns ] method = getattr ( self , f \"_add_function_ { standard } \" ) func_iri = method ( func , expects , returns , base_iri ) self . function_repo [ func_iri ] = func if callable ( func ) else None if cost is not None : self . _add_cost ( cost , func_iri ) return func_iri def _add_cost ( self , cost : \"Union[float, Callable[[], float]]\" , dest_iri ): \"\"\"Help function that adds `cost` to destination IRI `dest_iri`. `cost` should be either a float or a Callable returning a float. If `cost` is a callable it is just referred to with a literal id and is not ontologically described as a function. The expected input arguments depends on the context, which is why this function is not part of the public API. Use the add_mapsTo() and add_function() methods instead. \"\"\" if self . has ( dest_iri , DM . hasCost ): warnings . warn ( f \"A cost is already assigned to IRI: { dest_iri } \" ) elif callable ( cost ): cost_id = f \"cost_function { function_id ( cost ) } \" self . add (( dest_iri , DM . hasCost , Literal ( cost_id ))) self . function_repo [ cost_id ] = cost else : self . add (( dest_iri , DM . hasCost , Literal ( cost ))) def _add_function_fno ( self , func , expects , returns , base_iri ): \"\"\"Implementing add_function() for FnO.\"\"\" self . bind ( \"fno\" , FNO ) self . bind ( \"dcterms\" , DCTERMS ) self . bind ( \"map\" , MAP ) if base_iri is None : base_iri = self . base_iri if self . base_iri else \":\" if callable ( func ): fid = function_id ( func ) # Function id func_iri = f \" { base_iri }{ func . __name__ } _ { fid } \" doc_string = inspect . getdoc ( func ) parlist = f \"_: { func . __name__ }{ fid } _parlist\" outlist = f \"_: { func . __name__ }{ fid } _outlist\" if isinstance ( expects , Sequence ): pars = list ( zip ( expects , inspect . signature ( func ) . parameters )) else : pars = [ ( expects [ par ], par ) for par in inspect . signature ( func ) . parameters ] elif isinstance ( func , str ): func_iri = func doc_string = \"\" parlist = f \"_: { func_iri } _parlist\" outlist = f \"_: { func_iri } _outlist\" pariris = expects if isinstance ( expects , Sequence ) else expects . values () parnames = [ split_iri ( pariri )[ 1 ] for pariri in pariris ] pars = list ( zip ( pariris , parnames )) else : raise TypeError ( \"`func` should be either a callable or an IRI\" ) self . add (( func_iri , RDF . type , FNO . Function )) self . add (( func_iri , FNO . expects , parlist )) self . add (( func_iri , FNO . returns , outlist )) if doc_string : self . add (( func_iri , DCTERMS . description , en ( doc_string ))) lst = parlist for i , ( iri , parname ) in enumerate ( pars ): lst_next = f \" { parlist }{ i + 2 } \" if i < len ( pars ) - 1 else RDF . nil par = f \" { func_iri } _parameter { i + 1 } _ { parname } \" self . add (( par , RDF . type , FNO . Parameter )) self . add (( par , RDFS . label , en ( parname ))) self . add (( par , MAP . mapsTo , iri )) self . add (( lst , RDF . first , par )) self . add (( lst , RDF . rest , lst_next )) lst = lst_next lst = outlist for i , iri in enumerate ( returns ): lst_next = f \" { outlist }{ i + 2 } \" if i < len ( returns ) - 1 else RDF . nil val = f \" { func_iri } _output { i + 1 } \" self . add (( val , RDF . type , FNO . Output )) self . add (( val , MAP . mapsTo , iri )) self . add (( lst , RDF . first , val )) self . add (( lst , RDF . rest , lst_next )) lst = lst_next return func_iri def _add_function_emmo ( self , func , expects , returns , base_iri ): \"\"\"Implementing add_function() method for the \"emmo\" standard.\"\"\" # pylint: disable=too-many-locals self . bind ( \"emmo\" , EMMO ) self . bind ( \"dcterms\" , DCTERMS ) self . bind ( \"map\" , MAP ) # Hardcode EMMO IRIs to avoid slow lookup Task = EMMO . EMMO_4299e344_a321_4ef2_a744_bacfcce80afc DataSet = EMMO . EMMO_194e367c_9783_4bf5_96d0_9ad597d48d9a hasInput = EMMO . EMMO_36e69413_8c59_4799_946c_10b05d266e22 hasOutput = EMMO . EMMO_c4bace1d_4db0_4cd3_87e9_18122bae2840 # Software = EMMO.EMMO_8681074a_e225_4e38_b586_e85b0f43ce38 # hasSoftware = EMMO.Software # TODO: fix when EMMO has hasSoftware if base_iri is None : base_iri = self . base_iri if self . base_iri else \":\" if callable ( func ): fid = function_id ( func ) # Function id func_iri = f \" { base_iri }{ func . __name__ } _ { fid } \" doc_string = inspect . getdoc ( func ) if isinstance ( expects , Sequence ): pars = list ( zip ( inspect . signature ( func ) . parameters , expects )) else : pars = expects . items () elif isinstance ( func , str ): func_iri = func doc_string = \"\" pariris = expects if isinstance ( expects , Sequence ) else expects . values () parnames = [ split_iri ( pariri )[ 1 ] for pariri in pariris ] pars = list ( zip ( parnames , pariris )) else : raise TypeError ( \"`func` should be either a callable or an IRI\" ) self . add (( func_iri , RDF . type , Task )) for parname , iri in pars : par = f \" { func_iri } _input_ { parname } \" self . add (( par , RDF . type , DataSet )) self . add (( par , RDFS . label , en ( parname ))) self . add (( par , MAP . mapsTo , iri )) self . add (( func_iri , hasInput , par )) for i , iri in enumerate ( returns ): val = f \" { func_iri } _output { i + 1 } \" self . add (( val , RDF . type , DataSet )) self . add (( val , MAP . mapsTo , iri )) self . add (( func_iri , hasOutput , val )) if doc_string : self . add (( func_iri , DCTERMS . description , en ( doc_string ))) return func_iri","title":"Triplestore"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.__init__","text":"Initialise triplestore using the backend with the given name. Parameters: Name Type Description Default backend str Name of the backend module. required base_iri 'Optional[str]' Base IRI used by the add_function() method when adding new triples. May also be used by the backend. None database 'Optional[str]' Name of database to connect to (for backends that supports it). None kwargs Keyword arguments passed to the backend's init () method. {} Source code in tripper/triplestore.py def __init__ ( self , backend : str , base_iri : \"Optional[str]\" = None , database : \"Optional[str]\" = None , ** kwargs , ) -> None : \"\"\"Initialise triplestore using the backend with the given name. Parameters: backend: Name of the backend module. base_iri: Base IRI used by the add_function() method when adding new triples. May also be used by the backend. database: Name of database to connect to (for backends that supports it). kwargs: Keyword arguments passed to the backend's __init__() method. \"\"\" module = import_module ( backend if \".\" in backend else f \"tripper.backends. { backend } \" ) cls = getattr ( module , f \" { backend . title () } Strategy\" ) self . base_iri = base_iri self . namespaces : \"Dict[str, Namespace]\" = {} self . closed = False self . backend_name = backend self . backend = cls ( base_iri = base_iri , database = database , ** kwargs ) # Keep functions in the triplestore for convienence even though # they usually do not belong to the triplestore per se. self . function_repo : \"Dict[str, Union[float, Callable[[], float], None]]\" = {} for prefix , namespace in self . default_namespaces . items (): self . bind ( prefix , namespace )","title":"__init__()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.add","text":"Add triple to triplestore. Source code in tripper/triplestore.py def add ( self , triple : \"Triple\" ): \"\"\"Add `triple` to triplestore.\"\"\" self . add_triples ([ triple ])","title":"add()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.add_function","text":"Inspect function and add triples describing it to the triplestore. Parameters: Name Type Description Default func 'Union[Callable, str]' Function to describe. Should either be a callable or a string with a unique function IRI. required expects 'Union[str, Sequence, Mapping]' Sequence of IRIs to ontological concepts corresponding to positional arguments of func . May also be given as a dict mapping argument names to corresponding ontological IRIs. () returns 'Union[str, Sequence]' IRI of return value. May also be given as a sequence of IRIs, if multiple values are returned. () base_iri 'Optional[str]' Base of the IRI representing the function in the knowledge base. Defaults to the base IRI of the triplestore. None standard str Name of ontology to use when describing the function. Valid values are: - \"emmo\": Elementary Multiperspective Material Ontology (EMMO) - \"fno\": Function Ontology (FnO) 'fno' cost 'Optional[Union[float, Callable]]' User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the same arguments as func returning the cost as a float. None Returns: Type Description func_iri IRI of the added function. Source code in tripper/triplestore.py def add_function ( self , func : \"Union[Callable, str]\" , expects : \"Union[str, Sequence, Mapping]\" = (), returns : \"Union[str, Sequence]\" = (), base_iri : \"Optional[str]\" = None , standard : str = \"fno\" , cost : \"Optional[Union[float, Callable]]\" = None , ): \"\"\"Inspect function and add triples describing it to the triplestore. Parameters: func: Function to describe. Should either be a callable or a string with a unique function IRI. expects: Sequence of IRIs to ontological concepts corresponding to positional arguments of `func`. May also be given as a dict mapping argument names to corresponding ontological IRIs. returns: IRI of return value. May also be given as a sequence of IRIs, if multiple values are returned. base_iri: Base of the IRI representing the function in the knowledge base. Defaults to the base IRI of the triplestore. standard: Name of ontology to use when describing the function. Valid values are: - \"emmo\": Elementary Multiperspective Material Ontology (EMMO) - \"fno\": Function Ontology (FnO) cost: User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the same arguments as `func` returning the cost as a float. Returns: func_iri: IRI of the added function. \"\"\" if isinstance ( expects , str ): expects = [ expects ] if isinstance ( returns , str ): returns = [ returns ] method = getattr ( self , f \"_add_function_ { standard } \" ) func_iri = method ( func , expects , returns , base_iri ) self . function_repo [ func_iri ] = func if callable ( func ) else None if cost is not None : self . _add_cost ( cost , func_iri ) return func_iri","title":"add_function()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.add_mapsTo","text":"Add 'mapsTo' relation to triplestore. Parameters: Name Type Description Default target str IRI of target ontological concept. required source str Source IRI (or entity object). required property_name 'Optional[str]' Name of property if source is an entity or an entity IRI. None cost 'Optional[Union[float, Callable]]' User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the value of the mapped quantity as input and returning the cost as a float. None target_cost bool Whether the cost is assigned to mapping steps that have target as output. True Note This is equivalent to the map() method, but reverts the two first arguments and adds the property_name argument. Source code in tripper/triplestore.py def add_mapsTo ( self , target : str , source : str , property_name : \"Optional[str]\" = None , cost : \"Optional[Union[float, Callable]]\" = None , target_cost : bool = True , ): \"\"\"Add 'mapsTo' relation to triplestore. Parameters: target: IRI of target ontological concept. source: Source IRI (or entity object). property_name: Name of property if `source` is an entity or an entity IRI. cost: User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the value of the mapped quantity as input and returning the cost as a float. target_cost: Whether the cost is assigned to mapping steps that have `target` as output. Note: This is equivalent to the `map()` method, but reverts the two first arguments and adds the `property_name` argument. \"\"\" self . bind ( \"map\" , MAP ) if not property_name and not isinstance ( source , str ): raise TriplestoreError ( \"`property_name` is required when `target` is not a string.\" ) target = self . expand_iri ( target ) source = self . expand_iri ( infer_iri ( source )) if property_name : self . add (( f \" { source } # { property_name } \" , MAP . mapsTo , target )) else : self . add (( source , MAP . mapsTo , target )) if cost is not None : dest = target if target_cost else source self . _add_cost ( cost , dest )","title":"add_mapsTo()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.add_triples","text":"Add a sequence of triples. Parameters: Name Type Description Default triples 'Sequence[Triple]' A sequence of (s, p, o) tuples to add to the triplestore. required Source code in tripper/triplestore.py def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples. Arguments: triples: A sequence of `(s, p, o)` tuples to add to the triplestore. \"\"\" self . backend . add_triples ( triples )","title":"add_triples()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.bind","text":"Bind prefix to namespace and return the new Namespace object. The new Namespace is created with namespace as IRI. Keyword arguments are passed to the Namespace() constructor. If namespace is None, the corresponding prefix is removed. Source code in tripper/triplestore.py def bind ( self , prefix : str , namespace : \"Union[str, Namespace]\" , ** kwargs ) -> Namespace : \"\"\"Bind prefix to namespace and return the new Namespace object. The new Namespace is created with `namespace` as IRI. Keyword arguments are passed to the Namespace() constructor. If `namespace` is None, the corresponding prefix is removed. \"\"\" if hasattr ( self . backend , \"bind\" ): self . backend . bind ( prefix , namespace ) if namespace is None : del self . namespaces [ prefix ] return None self . namespaces [ prefix ] = ( namespace if isinstance ( namespace , Namespace ) else Namespace ( namespace , ** kwargs ) ) return self . namespaces [ prefix ]","title":"bind()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.close","text":"Calls the backend close() method if it is implemented. Otherwise, this method has no effect. Source code in tripper/triplestore.py def close ( self ): \"\"\"Calls the backend close() method if it is implemented. Otherwise, this method has no effect. \"\"\" # It should be ok to call close() regardless of whether the backend # implements this method or not. Hence, don't call _check_method(). if not self . closed and hasattr ( self . backend , \"close\" ): self . backend . close () self . closed = True","title":"close()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.create_database","text":"Create a new database in backend. Parameters: Name Type Description Default backend str Name of backend. required database str Name of the new database. required kwargs Keyword arguments passed to the backend create_database() method. {} Note This is a class method, which operates on the backend triplestore without connecting to it. Source code in tripper/triplestore.py @classmethod def create_database ( cls , backend : str , database : str , ** kwargs ): \"\"\"Create a new database in backend. Parameters: backend: Name of backend. database: Name of the new database. kwargs: Keyword arguments passed to the backend create_database() method. Note: This is a class method, which operates on the backend triplestore without connecting to it. \"\"\" cls . _check_backend_method ( backend , \"create_database\" ) backend_class = cls . _get_backend ( backend ) return backend_class . create_database ( database = database , ** kwargs )","title":"create_database()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.expand_iri","text":"Return the full IRI if iri is prefixed. Otherwise iri is returned. Source code in tripper/triplestore.py def expand_iri ( self , iri : str ): \"\"\"Return the full IRI if `iri` is prefixed. Otherwise `iri` is returned.\"\"\" match = re . match ( _MATCH_PREFIXED_IRI , iri ) if match : prefix , name = match . groups () if prefix not in self . namespaces : raise NamespaceError ( f \"unknown namespace: { prefix } \" ) return f \" { self . namespaces [ prefix ] }{ name } \" return iri","title":"expand_iri()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.has","text":"Returns true if the triplestore has any triple matching the give subject, predicate and/or object. Source code in tripper/triplestore.py def has ( self , subject = None , predicate = None , object = None ): # pylint: disable=redefined-builtin \"\"\"Returns true if the triplestore has any triple matching the give subject, predicate and/or object.\"\"\" triple = self . triples ( subject = subject , predicate = predicate , object = object ) try : next ( triple ) except StopIteration : return False return True","title":"has()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.list_databases","text":"For backends that supports multiple databases, list of all databases. Parameters: Name Type Description Default backend str Name of backend. required kwargs Keyword arguments passed to the backend list_databases() method. {} Note This is a class method, which operates on the backend triplestore without connecting to it. Source code in tripper/triplestore.py @classmethod def list_databases ( cls , backend : str , ** kwargs ): \"\"\"For backends that supports multiple databases, list of all databases. Parameters: backend: Name of backend. kwargs: Keyword arguments passed to the backend list_databases() method. Note: This is a class method, which operates on the backend triplestore without connecting to it. \"\"\" cls . _check_backend_method ( backend , \"list_databases\" ) backend_class = cls . _get_backend ( backend ) return backend_class . list_databases ( ** kwargs )","title":"list_databases()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.map","text":"Add 'mapsTo' relation to the triplestore. Parameters: Name Type Description Default source str Source IRI. required target str IRI of target ontological concept. required cost 'Optional[Union[float, Callable]]' User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the value of the mapped quantity as input and returning the cost as a float. None target_cost bool Whether the cost is assigned to mapping steps that have target as output. True Source code in tripper/triplestore.py def map ( self , source : str , target : str , cost : \"Optional[Union[float, Callable]]\" = None , target_cost : bool = True , ): \"\"\"Add 'mapsTo' relation to the triplestore. Parameters: source: Source IRI. target: IRI of target ontological concept. cost: User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the value of the mapped quantity as input and returning the cost as a float. target_cost: Whether the cost is assigned to mapping steps that have `target` as output. \"\"\" return self . add_mapsTo ( target = target , source = source , cost = cost , target_cost = target_cost , )","title":"map()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.objects","text":"Returns a generator of objects for given subject and predicate. Source code in tripper/triplestore.py def objects ( self , subject = None , predicate = None ): \"\"\"Returns a generator of objects for given subject and predicate.\"\"\" for _ , _ , o in self . triples ( subject = subject , predicate = predicate ): yield o","title":"objects()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.parse","text":"Parse source and add the resulting triples to triplestore. Parameters: Name Type Description Default source File-like object or file name. None format Needed if format can not be inferred from source. None kwargs Keyword arguments passed to the backend. The rdflib backend supports e.g. location (absolute or relative URL) and data (string containing the data to be parsed) arguments. {} Source code in tripper/triplestore.py def parse ( self , source = None , format = None , ** kwargs # pylint: disable=redefined-builtin ) -> None : \"\"\"Parse source and add the resulting triples to triplestore. Parameters: source: File-like object or file name. format: Needed if format can not be inferred from source. kwargs: Keyword arguments passed to the backend. The rdflib backend supports e.g. `location` (absolute or relative URL) and `data` (string containing the data to be parsed) arguments. \"\"\" self . _check_method ( \"parse\" ) self . backend . parse ( source = source , format = format , ** kwargs ) if hasattr ( self . backend , \"namespaces\" ): for prefix , namespace in self . backend . namespaces () . items (): if prefix and prefix not in self . namespaces : self . namespaces [ prefix ] = Namespace ( namespace )","title":"parse()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.predicate_objects","text":"Returns a generator of (predicate, object) tuples for given subject. Source code in tripper/triplestore.py def predicate_objects ( self , subject = None ): \"\"\"Returns a generator of (predicate, object) tuples for given subject.\"\"\" for _ , p , o in self . triples ( subject = subject ): yield p , o","title":"predicate_objects()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.predicates","text":"Returns a generator of predicates for given subject and object. Source code in tripper/triplestore.py def predicates ( self , subject = None , object = None # pylint: disable=redefined-builtin ): \"\"\"Returns a generator of predicates for given subject and object.\"\"\" for _ , p , _ in self . triples ( subject = subject , object = object ): yield p","title":"predicates()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.prefix_iri","text":"Return prefixed IRI. This is the reverse of expand_iri(). If require_prefixed is true, a NamespaceError exception is raised if no prefix can be found. Source code in tripper/triplestore.py def prefix_iri ( self , iri : str , require_prefixed : bool = False ): \"\"\"Return prefixed IRI. This is the reverse of expand_iri(). If `require_prefixed` is true, a NamespaceError exception is raised if no prefix can be found. \"\"\" if not re . match ( _MATCH_PREFIXED_IRI , iri ): for prefix , namespace in self . namespaces . items (): if iri . startswith ( str ( namespace )): return f \" { prefix } : { iri [ len ( str ( namespace )):] } \" if require_prefixed : raise NamespaceError ( f \"No prefix defined for IRI: { iri } \" ) return iri","title":"prefix_iri()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.query","text":"SPARQL query. Parameters: Name Type Description Default query_object String with the SPARQL query. required kwargs Keyword arguments passed to the backend query() method. {} Returns: Type Description 'List[Tuple[str, ...]]' List of tuples of IRIs for each matching row. Note This method is intended for SELECT queries. Use the update() method for INSERT and DELETE queries. Source code in tripper/triplestore.py def query ( self , query_object , ** kwargs ) -> \"List[Tuple[str, ...]]\" : \"\"\"SPARQL query. Parameters: query_object: String with the SPARQL query. kwargs: Keyword arguments passed to the backend query() method. Returns: List of tuples of IRIs for each matching row. Note: This method is intended for SELECT queries. Use the update() method for INSERT and DELETE queries. \"\"\" self . _check_method ( \"query\" ) return self . backend . query ( query_object = query_object , ** kwargs )","title":"query()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.remove","text":"Remove all matching triples from the backend. Parameters: Name Type Description Default subject 'Optional[Union[str, Triple]]' If given, match triples with this subject. None predicate 'Optional[str]' If given, match triples with this predicate. None object 'Optional[Union[str, Literal]]' If given, match triples with this object. None triple 'Optional[Triple]' Deprecated. A (s, p, o) tuple where s , p and o should either be None (matching anything) or an exact IRI to match. None Source code in tripper/triplestore.py def remove ( # pylint: disable=redefined-builtin self , subject : \"Optional[Union[str, Triple]]\" = None , predicate : \"Optional[str]\" = None , object : \"Optional[Union[str, Literal]]\" = None , triple : \"Optional[Triple]\" = None , ) -> None : \"\"\"Remove all matching triples from the backend. Arguments: subject: If given, match triples with this subject. predicate: If given, match triples with this predicate. object: If given, match triples with this object. triple: Deprecated. A `(s, p, o)` tuple where `s`, `p` and `o` should either be None (matching anything) or an exact IRI to match. \"\"\" # __TODO__: Remove these lines when deprecated if triple or ( subject and not isinstance ( subject , str )): warnings . warn ( \"The `triple` argument is deprecated. Use `subject`, \" \"`predicate` and `object` arguments instead.\" , DeprecationWarning , stacklevel = 2 , ) if subject and not isinstance ( subject , str ): subject , predicate , object = subject elif triple : subject , predicate , object = triple return self . backend . remove (( subject , predicate , object ))","title":"remove()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.remove_database","text":"Remove a database in backend. Parameters: Name Type Description Default backend str Name of backend. required database str Name of the database to be removed. required kwargs Keyword arguments passed to the backend remove_database() method. {} Note This is a class method, which operates on the backend triplestore without connecting to it. Source code in tripper/triplestore.py @classmethod def remove_database ( cls , backend : str , database : str , ** kwargs ): \"\"\"Remove a database in backend. Parameters: backend: Name of backend. database: Name of the database to be removed. kwargs: Keyword arguments passed to the backend remove_database() method. Note: This is a class method, which operates on the backend triplestore without connecting to it. \"\"\" cls . _check_backend_method ( backend , \"remove_database\" ) backend_class = cls . _get_backend ( backend ) return backend_class . remove_database ( database = database , ** kwargs )","title":"remove_database()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.serialize","text":"Serialise triplestore. Parameters: Name Type Description Default destination File name or object to write to. If None, the serialisation is returned. None format Format to serialise as. Supported formats, depends on the backend. 'turtle' kwargs Passed to the backend serialize() method. {} Returns: Type Description 'Union[None, str]' Serialized string if destination is None. Source code in tripper/triplestore.py def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise triplestore. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the backend serialize() method. Returns: Serialized string if `destination` is None. \"\"\" self . _check_method ( \"serialize\" ) return self . backend . serialize ( destination = destination , format = format , ** kwargs )","title":"serialize()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.set","text":"Convenience method to update the value of object. Removes any existing triples for subject and predicate before adding the given triple . Source code in tripper/triplestore.py def set ( self , triple ): \"\"\"Convenience method to update the value of object. Removes any existing triples for subject and predicate before adding the given `triple`. \"\"\" s , p , _ = triple self . remove (( s , p , None )) self . add ( triple )","title":"set()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.subject_objects","text":"Returns a generator of (subject, object) tuples for given predicate. Source code in tripper/triplestore.py def subject_objects ( self , predicate = None ): \"\"\"Returns a generator of (subject, object) tuples for given predicate.\"\"\" for s , _ , o in self . triples ( predicate = predicate ): yield s , o","title":"subject_objects()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.subject_predicates","text":"Returns a generator of (subject, predicate) tuples for given object. Source code in tripper/triplestore.py def subject_predicates ( self , object = None ): # pylint: disable=redefined-builtin \"\"\"Returns a generator of (subject, predicate) tuples for given object.\"\"\" for s , p , _ in self . triples ( object = object ): yield s , p","title":"subject_predicates()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.subjects","text":"Returns a generator of subjects for given predicate and object. Source code in tripper/triplestore.py def subjects ( self , predicate = None , object = None # pylint: disable=redefined-builtin ): \"\"\"Returns a generator of subjects for given predicate and object.\"\"\" for s , _ , _ in self . triples ( predicate = predicate , object = object ): yield s","title":"subjects()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.triples","text":"Returns a generator over matching triples. Parameters: Name Type Description Default subject 'Optional[Union[str, Triple]]' If given, match triples with this subject. None predicate 'Optional[str]' If given, match triples with this predicate. None object 'Optional[Union[str, Literal]]' If given, match triples with this object. None triple 'Optional[Triple]' Deprecated. A (s, p, o) tuple where s , p and o should either be None (matching anything) or an exact IRI to match. None Returns: Type Description 'Generator[Triple, None, None]' Generator over all matching triples. Source code in tripper/triplestore.py def triples ( # pylint: disable=redefined-builtin self , subject : \"Optional[Union[str, Triple]]\" = None , predicate : \"Optional[str]\" = None , object : \"Optional[Union[str, Literal]]\" = None , triple : \"Optional[Triple]\" = None , ) -> \"Generator[Triple, None, None]\" : \"\"\"Returns a generator over matching triples. Arguments: subject: If given, match triples with this subject. predicate: If given, match triples with this predicate. object: If given, match triples with this object. triple: Deprecated. A `(s, p, o)` tuple where `s`, `p` and `o` should either be None (matching anything) or an exact IRI to match. Returns: Generator over all matching triples. \"\"\" # __TODO__: Remove these lines when deprecated if triple or ( subject and not isinstance ( subject , str )): warnings . warn ( \"The `triple` argument is deprecated. Use `subject`, \" \"`predicate` and `object` arguments instead.\" , DeprecationWarning , stacklevel = 2 , ) if subject and not isinstance ( subject , str ): subject , predicate , object = subject elif triple : subject , predicate , object = triple return self . backend . triples (( subject , predicate , object ))","title":"triples()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.update","text":"Update triplestore with SPARQL. Parameters: Name Type Description Default update_object String with the SPARQL query. required kwargs Keyword arguments passed to the backend update() method. {} Note This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. Source code in tripper/triplestore.py def update ( self , update_object , ** kwargs ) -> None : \"\"\"Update triplestore with SPARQL. Parameters: update_object: String with the SPARQL query. kwargs: Keyword arguments passed to the backend update() method. Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" self . _check_method ( \"update\" ) return self . backend . update ( update_object = update_object , ** kwargs )","title":"update()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.value","text":"Return the value for a pair of two criteria. Useful if one knows that there may only be one value. Parameters: Name Type Description Default subject, predicate, object Triple to match. required default Value to return if no matches are found. None any If true, return any matching value, otherwise raise UniquenessError. False Source code in tripper/triplestore.py def value ( # pylint: disable=redefined-builtin self , subject = None , predicate = None , object = None , default = None , any = False ): \"\"\"Return the value for a pair of two criteria. Useful if one knows that there may only be one value. Parameters: subject, predicate, object: Triple to match. default: Value to return if no matches are found. any: If true, return any matching value, otherwise raise UniquenessError. \"\"\" triple = self . triples (( subject , predicate , object )) try : value = next ( triple ) except StopIteration : return default if any : return value try : next ( triple ) except StopIteration : return value else : raise UniquenessError ( \"More than one match\" )","title":"value()"},{"location":"api_reference/utils/","text":"utils \u00b6 Utility functions. UnusedArgumentWarning ( Warning ) \u00b6 Argument is unused. Source code in tripper/utils.py class UnusedArgumentWarning ( Warning ): \"\"\"Argument is unused.\"\"\" check ( func , s , exceptions ) \u00b6 Help function that returns true if func(s) does not raise an exception. False is returned if func(s) raises an exception listed in exceptions . Otherwise the exception is propagated. Source code in tripper/utils.py def check ( func : \"Callable\" , s : str , exceptions ) -> bool : \"\"\"Help function that returns true if `func(s)` does not raise an exception. False is returned if `func(s)` raises an exception listed in `exceptions`. Otherwise the exception is propagated. \"\"\" # Note that the missing type hint on `exceptions` is deliberately, see # https://peps.python.org/pep-0484/#exceptions try : func ( s ) except exceptions : return False return True en ( value ) \u00b6 Convenience function that returns value as a plain english literal. Equivalent to Literal(value, lang=\"en\") . Source code in tripper/utils.py def en ( value ) -> \"Literal\" : # pylint: disable=invalid-name \"\"\"Convenience function that returns value as a plain english literal. Equivalent to ``Literal(value, lang=\"en\")``. \"\"\" return Literal ( value , lang = \"en\" ) function_id ( func , length = 4 ) \u00b6 Return a checksum for function func . The returned object is a string of hexadecimal digits. length is the number of bytes in the returned checksum. Since the current implementation is based on the shake_128 algorithm, it make no sense to set length larger than 32 bytes. Source code in tripper/utils.py def function_id ( func : \"Callable\" , length : int = 4 ) -> str : \"\"\"Return a checksum for function `func`. The returned object is a string of hexadecimal digits. `length` is the number of bytes in the returned checksum. Since the current implementation is based on the shake_128 algorithm, it make no sense to set `length` larger than 32 bytes. \"\"\" return hashlib . shake_128 ( # pylint: disable=too-many-function-args inspect . getsource ( func ) . encode () ) . hexdigest ( length ) infer_iri ( obj ) \u00b6 Return IRI of the individual that stands for object obj . Source code in tripper/utils.py def infer_iri ( obj ): \"\"\"Return IRI of the individual that stands for object `obj`.\"\"\" if isinstance ( obj , str ): iri = obj elif hasattr ( obj , \"uri\" ) and isinstance ( obj . uri , str ): # dlite.Metadata or dataclass (or instance with uri) iri = obj . uri elif hasattr ( obj , \"uuid\" ) and obj . uuid : # dlite.Instance or dataclass iri = str ( obj . uuid ) elif hasattr ( obj , \"schema\" ) and callable ( obj . schema ): # pydantic.BaseModel if hasattr ( obj , \"identity\" ) and isinstance ( obj . identity , str ): # soft7 pydantic model iri = obj . identity else : # pydantic instance schema = obj . schema () properties = schema [ \"properties\" ] if \"uri\" in properties and isinstance ( properties [ \"uri\" ], str ): iri = properties [ \"uri\" ] if \"identity\" in properties and isinstance ( properties [ \"identity\" ], str ): iri = properties [ \"identity\" ] if \"uuid\" in properties and properties [ \"uuid\" ]: iri = str ( properties [ \"uuid\" ]) else : raise TypeError ( f \"cannot infer IRI from object: { obj !r} \" ) return str ( iri ) parse_literal ( literal ) \u00b6 Parse literal and return it as an instance of Literal. The main difference between this function and the Literal constructor, is that this function correctly interprets n3-encoded literal strings. Source code in tripper/utils.py def parse_literal ( literal : \"Any\" ) -> \"Literal\" : \"\"\"Parse `literal` and return it as an instance of Literal. The main difference between this function and the Literal constructor, is that this function correctly interprets n3-encoded literal strings. \"\"\" # pylint: disable=invalid-name,too-many-branches lang , datatype = None , None if isinstance ( literal , Literal ): return literal if not isinstance ( literal , str ): if isinstance ( literal , tuple ( Literal . datatypes )): return Literal ( literal , lang = lang , datatype = Literal . datatypes . get ( type ( literal ))[ 0 ], # type: ignore ) TypeError ( f \"unsupported literal type: { type ( literal ) } \" ) match = re . match ( r '^\\s*(\"\"\"(.*)\"\"\"|\"(.*)\")\\s*$' , literal , flags = re . DOTALL ) if match : _ , v1 , v2 = match . groups () value , datatype = v1 if v1 else v2 , XSD . string else : match = re . match ( r '^\\s*(\"\"\"(.*)\"\"\"|\"(.*)\")\\^\\^(.*)\\s*$' , literal , flags = re . DOTALL ) if match : _ , v1 , v2 , datatype = match . groups () value = v1 if v1 else v2 else : match = re . match ( r '^\\s*(\"\"\"(.*)\"\"\"|\"(.*)\")@(.*)\\s*$' , literal , flags = re . DOTALL ) if match : _ , v1 , v2 , lang = match . groups () value = v1 if v1 else v2 else : value = literal if lang or datatype : if datatype : types = {} for pytype , datatypes in Literal . datatypes . items (): types . update ({ t : pytype for t in datatypes }) type_ = types [ datatype ] try : value = type_ ( value ) except TypeError : pass return Literal ( value , lang = lang , datatype = datatype ) for type_ , datatypes in Literal . datatypes . items (): if type_ is not bool : try : return Literal ( type_ ( literal ), lang = lang , datatype = datatypes [ 0 ]) except ( ValueError , TypeError ): pass raise ValueError ( f 'cannot parse literal \" { literal } \"' ) parse_object ( obj ) \u00b6 Applies heuristics to parse RDF object obj to an IRI or literal. The following heuristics is performed (in the given order): - If obj is a Literal, it is returned. - If obj is a string and - starts with \"_:\", it is assumed to be a blank node and returned. - starts with a scheme, it is asumed to be an IRI and returned. - can be converted to a float, int or datetime, it is returned. converted to a literal of the corresponding type. - it is a valid n3 representation, return it as the given type. - otherwise, return it as a xsd:string literal. - Otherwise, raise an ValueError. Returns A string if obj is considered to be an IRI, otherwise a literal. Source code in tripper/utils.py def parse_object ( obj : \"Union[str, Literal]\" ) -> \"Union[str, Literal]\" : \"\"\"Applies heuristics to parse RDF object `obj` to an IRI or literal. The following heuristics is performed (in the given order): - If `obj` is a Literal, it is returned. - If `obj` is a string and - starts with \"_:\", it is assumed to be a blank node and returned. - starts with a scheme, it is asumed to be an IRI and returned. - can be converted to a float, int or datetime, it is returned. converted to a literal of the corresponding type. - it is a valid n3 representation, return it as the given type. - otherwise, return it as a xsd:string literal. - Otherwise, raise an ValueError. Returns A string if `obj` is considered to be an IRI, otherwise a literal. \"\"\" # pylint: disable=too-many-return-statements if isinstance ( obj , Literal ): return obj if isinstance ( obj , str ): if obj . startswith ( \"_:\" ) or re . match ( r \"^[a-z]+://\" , obj ): # IRI return obj if obj in ( \"true\" , \"false\" ): # boolean return Literal ( obj , datatype = XSD . boolean ) if re . match ( r \"^\\s*[+-]?\\d+\\s*$\" , obj ): # integer return Literal ( obj , datatype = XSD . integer ) if check ( float , obj , ValueError ): # float return Literal ( obj , datatype = XSD . double ) if check ( datetime . datetime . fromisoformat , obj , ValueError ): # datetime return Literal ( obj , datatype = XSD . dateTime ) return parse_literal ( obj ) raise ValueError ( \"`obj` should be a literal or a string.\" ) split_iri ( iri ) \u00b6 Split iri into namespace and name parts and return them as a tuple. Parameters: Name Type Description Default iri str The IRI to be split. required Returns: Type Description Tuple[str, str] A split IRI. Split into namespace and name. Source code in tripper/utils.py def split_iri ( iri : str ) -> \"Tuple[str, str]\" : \"\"\"Split iri into namespace and name parts and return them as a tuple. Parameters: iri: The IRI to be split. Returns: A split IRI. Split into namespace and name. \"\"\" if \"#\" in iri : namespace , name = iri . rsplit ( \"#\" , 1 ) return f \" { namespace } #\" , name if \"/\" in iri : namespace , name = iri . rsplit ( \"/\" , 1 ) return f \" { namespace } /\" , name raise ValueError ( \"all IRIs should contain a slash\" )","title":"utils"},{"location":"api_reference/utils/#utils","text":"Utility functions.","title":"utils"},{"location":"api_reference/utils/#tripper.utils.UnusedArgumentWarning","text":"Argument is unused. Source code in tripper/utils.py class UnusedArgumentWarning ( Warning ): \"\"\"Argument is unused.\"\"\"","title":"UnusedArgumentWarning"},{"location":"api_reference/utils/#tripper.utils.check","text":"Help function that returns true if func(s) does not raise an exception. False is returned if func(s) raises an exception listed in exceptions . Otherwise the exception is propagated. Source code in tripper/utils.py def check ( func : \"Callable\" , s : str , exceptions ) -> bool : \"\"\"Help function that returns true if `func(s)` does not raise an exception. False is returned if `func(s)` raises an exception listed in `exceptions`. Otherwise the exception is propagated. \"\"\" # Note that the missing type hint on `exceptions` is deliberately, see # https://peps.python.org/pep-0484/#exceptions try : func ( s ) except exceptions : return False return True","title":"check()"},{"location":"api_reference/utils/#tripper.utils.en","text":"Convenience function that returns value as a plain english literal. Equivalent to Literal(value, lang=\"en\") . Source code in tripper/utils.py def en ( value ) -> \"Literal\" : # pylint: disable=invalid-name \"\"\"Convenience function that returns value as a plain english literal. Equivalent to ``Literal(value, lang=\"en\")``. \"\"\" return Literal ( value , lang = \"en\" )","title":"en()"},{"location":"api_reference/utils/#tripper.utils.function_id","text":"Return a checksum for function func . The returned object is a string of hexadecimal digits. length is the number of bytes in the returned checksum. Since the current implementation is based on the shake_128 algorithm, it make no sense to set length larger than 32 bytes. Source code in tripper/utils.py def function_id ( func : \"Callable\" , length : int = 4 ) -> str : \"\"\"Return a checksum for function `func`. The returned object is a string of hexadecimal digits. `length` is the number of bytes in the returned checksum. Since the current implementation is based on the shake_128 algorithm, it make no sense to set `length` larger than 32 bytes. \"\"\" return hashlib . shake_128 ( # pylint: disable=too-many-function-args inspect . getsource ( func ) . encode () ) . hexdigest ( length )","title":"function_id()"},{"location":"api_reference/utils/#tripper.utils.infer_iri","text":"Return IRI of the individual that stands for object obj . Source code in tripper/utils.py def infer_iri ( obj ): \"\"\"Return IRI of the individual that stands for object `obj`.\"\"\" if isinstance ( obj , str ): iri = obj elif hasattr ( obj , \"uri\" ) and isinstance ( obj . uri , str ): # dlite.Metadata or dataclass (or instance with uri) iri = obj . uri elif hasattr ( obj , \"uuid\" ) and obj . uuid : # dlite.Instance or dataclass iri = str ( obj . uuid ) elif hasattr ( obj , \"schema\" ) and callable ( obj . schema ): # pydantic.BaseModel if hasattr ( obj , \"identity\" ) and isinstance ( obj . identity , str ): # soft7 pydantic model iri = obj . identity else : # pydantic instance schema = obj . schema () properties = schema [ \"properties\" ] if \"uri\" in properties and isinstance ( properties [ \"uri\" ], str ): iri = properties [ \"uri\" ] if \"identity\" in properties and isinstance ( properties [ \"identity\" ], str ): iri = properties [ \"identity\" ] if \"uuid\" in properties and properties [ \"uuid\" ]: iri = str ( properties [ \"uuid\" ]) else : raise TypeError ( f \"cannot infer IRI from object: { obj !r} \" ) return str ( iri )","title":"infer_iri()"},{"location":"api_reference/utils/#tripper.utils.parse_literal","text":"Parse literal and return it as an instance of Literal. The main difference between this function and the Literal constructor, is that this function correctly interprets n3-encoded literal strings. Source code in tripper/utils.py def parse_literal ( literal : \"Any\" ) -> \"Literal\" : \"\"\"Parse `literal` and return it as an instance of Literal. The main difference between this function and the Literal constructor, is that this function correctly interprets n3-encoded literal strings. \"\"\" # pylint: disable=invalid-name,too-many-branches lang , datatype = None , None if isinstance ( literal , Literal ): return literal if not isinstance ( literal , str ): if isinstance ( literal , tuple ( Literal . datatypes )): return Literal ( literal , lang = lang , datatype = Literal . datatypes . get ( type ( literal ))[ 0 ], # type: ignore ) TypeError ( f \"unsupported literal type: { type ( literal ) } \" ) match = re . match ( r '^\\s*(\"\"\"(.*)\"\"\"|\"(.*)\")\\s*$' , literal , flags = re . DOTALL ) if match : _ , v1 , v2 = match . groups () value , datatype = v1 if v1 else v2 , XSD . string else : match = re . match ( r '^\\s*(\"\"\"(.*)\"\"\"|\"(.*)\")\\^\\^(.*)\\s*$' , literal , flags = re . DOTALL ) if match : _ , v1 , v2 , datatype = match . groups () value = v1 if v1 else v2 else : match = re . match ( r '^\\s*(\"\"\"(.*)\"\"\"|\"(.*)\")@(.*)\\s*$' , literal , flags = re . DOTALL ) if match : _ , v1 , v2 , lang = match . groups () value = v1 if v1 else v2 else : value = literal if lang or datatype : if datatype : types = {} for pytype , datatypes in Literal . datatypes . items (): types . update ({ t : pytype for t in datatypes }) type_ = types [ datatype ] try : value = type_ ( value ) except TypeError : pass return Literal ( value , lang = lang , datatype = datatype ) for type_ , datatypes in Literal . datatypes . items (): if type_ is not bool : try : return Literal ( type_ ( literal ), lang = lang , datatype = datatypes [ 0 ]) except ( ValueError , TypeError ): pass raise ValueError ( f 'cannot parse literal \" { literal } \"' )","title":"parse_literal()"},{"location":"api_reference/utils/#tripper.utils.parse_object","text":"Applies heuristics to parse RDF object obj to an IRI or literal. The following heuristics is performed (in the given order): - If obj is a Literal, it is returned. - If obj is a string and - starts with \"_:\", it is assumed to be a blank node and returned. - starts with a scheme, it is asumed to be an IRI and returned. - can be converted to a float, int or datetime, it is returned. converted to a literal of the corresponding type. - it is a valid n3 representation, return it as the given type. - otherwise, return it as a xsd:string literal. - Otherwise, raise an ValueError. Returns A string if obj is considered to be an IRI, otherwise a literal. Source code in tripper/utils.py def parse_object ( obj : \"Union[str, Literal]\" ) -> \"Union[str, Literal]\" : \"\"\"Applies heuristics to parse RDF object `obj` to an IRI or literal. The following heuristics is performed (in the given order): - If `obj` is a Literal, it is returned. - If `obj` is a string and - starts with \"_:\", it is assumed to be a blank node and returned. - starts with a scheme, it is asumed to be an IRI and returned. - can be converted to a float, int or datetime, it is returned. converted to a literal of the corresponding type. - it is a valid n3 representation, return it as the given type. - otherwise, return it as a xsd:string literal. - Otherwise, raise an ValueError. Returns A string if `obj` is considered to be an IRI, otherwise a literal. \"\"\" # pylint: disable=too-many-return-statements if isinstance ( obj , Literal ): return obj if isinstance ( obj , str ): if obj . startswith ( \"_:\" ) or re . match ( r \"^[a-z]+://\" , obj ): # IRI return obj if obj in ( \"true\" , \"false\" ): # boolean return Literal ( obj , datatype = XSD . boolean ) if re . match ( r \"^\\s*[+-]?\\d+\\s*$\" , obj ): # integer return Literal ( obj , datatype = XSD . integer ) if check ( float , obj , ValueError ): # float return Literal ( obj , datatype = XSD . double ) if check ( datetime . datetime . fromisoformat , obj , ValueError ): # datetime return Literal ( obj , datatype = XSD . dateTime ) return parse_literal ( obj ) raise ValueError ( \"`obj` should be a literal or a string.\" )","title":"parse_object()"},{"location":"api_reference/utils/#tripper.utils.split_iri","text":"Split iri into namespace and name parts and return them as a tuple. Parameters: Name Type Description Default iri str The IRI to be split. required Returns: Type Description Tuple[str, str] A split IRI. Split into namespace and name. Source code in tripper/utils.py def split_iri ( iri : str ) -> \"Tuple[str, str]\" : \"\"\"Split iri into namespace and name parts and return them as a tuple. Parameters: iri: The IRI to be split. Returns: A split IRI. Split into namespace and name. \"\"\" if \"#\" in iri : namespace , name = iri . rsplit ( \"#\" , 1 ) return f \" { namespace } #\" , name if \"/\" in iri : namespace , name = iri . rsplit ( \"/\" , 1 ) return f \" { namespace } /\" , name raise ValueError ( \"all IRIs should contain a slash\" )","title":"split_iri()"},{"location":"api_reference/backends/collection/","text":"collection \u00b6 Backend for DLite collections. CollectionStrategy \u00b6 Triplestore strategy for DLite collections. Parameters: Name Type Description Default base_iri Optional[str] Unused. None database Optional[str] Unused - collection does not support multiple databases. None collection Optional[Union[dlite.Collection, str]] Optional collection from which to initialise the triplestore from. None Source code in tripper/backends/collection.py class CollectionStrategy : \"\"\"Triplestore strategy for DLite collections. Arguments: base_iri: Unused. database: Unused - collection does not support multiple databases. collection: Optional collection from which to initialise the triplestore from. \"\"\" def __init__ ( self , base_iri : \"Optional[str]\" = None , database : \"Optional[str]\" = None , collection : \"Optional[Union[dlite.Collection, str]]\" = None , ): # pylint: disable=unused-argument if collection is None : self . collection = dlite . Collection () elif isinstance ( collection , str ): self . collection = dlite . get_instance ( collection ) if self . collection . meta . uri != dlite . COLLECTION_ENTITY : raise TypeError ( f \"expected ' { collection } ' to be a collection, was a \" f \" { self . collection . meta . uri } \" ) elif isinstance ( collection , dlite . Collection ): self . collection = collection else : raise TypeError ( \"`collection` should be None, string or a collection\" ) def triples ( self , triple : \"Triple\" ) -> \"Generator[Triple, None, None]\" : \"\"\"Returns a generator over matching triples.\"\"\" for s , p , o in self . collection . get_relations ( * triple ): yield s , p , parse_object ( o ) def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" for s , p , o in triples : v = parse_object ( o ) v_str = v . n3 () if isinstance ( v , Literal ) else v self . collection . add_relation ( s , p , v_str ) def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" s , p , o = triple v = parse_object ( o ) v_str = v . n3 () if isinstance ( v , Literal ) else v self . collection . remove_relations ( s , p , v_str ) add_triples ( self , triples ) \u00b6 Add a sequence of triples. Source code in tripper/backends/collection.py def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" for s , p , o in triples : v = parse_object ( o ) v_str = v . n3 () if isinstance ( v , Literal ) else v self . collection . add_relation ( s , p , v_str ) remove ( self , triple ) \u00b6 Remove all matching triples from the backend. Source code in tripper/backends/collection.py def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" s , p , o = triple v = parse_object ( o ) v_str = v . n3 () if isinstance ( v , Literal ) else v self . collection . remove_relations ( s , p , v_str ) triples ( self , triple ) \u00b6 Returns a generator over matching triples. Source code in tripper/backends/collection.py def triples ( self , triple : \"Triple\" ) -> \"Generator[Triple, None, None]\" : \"\"\"Returns a generator over matching triples.\"\"\" for s , p , o in self . collection . get_relations ( * triple ): yield s , p , parse_object ( o )","title":"collection"},{"location":"api_reference/backends/collection/#collection","text":"Backend for DLite collections.","title":"collection"},{"location":"api_reference/backends/collection/#tripper.backends.collection.CollectionStrategy","text":"Triplestore strategy for DLite collections. Parameters: Name Type Description Default base_iri Optional[str] Unused. None database Optional[str] Unused - collection does not support multiple databases. None collection Optional[Union[dlite.Collection, str]] Optional collection from which to initialise the triplestore from. None Source code in tripper/backends/collection.py class CollectionStrategy : \"\"\"Triplestore strategy for DLite collections. Arguments: base_iri: Unused. database: Unused - collection does not support multiple databases. collection: Optional collection from which to initialise the triplestore from. \"\"\" def __init__ ( self , base_iri : \"Optional[str]\" = None , database : \"Optional[str]\" = None , collection : \"Optional[Union[dlite.Collection, str]]\" = None , ): # pylint: disable=unused-argument if collection is None : self . collection = dlite . Collection () elif isinstance ( collection , str ): self . collection = dlite . get_instance ( collection ) if self . collection . meta . uri != dlite . COLLECTION_ENTITY : raise TypeError ( f \"expected ' { collection } ' to be a collection, was a \" f \" { self . collection . meta . uri } \" ) elif isinstance ( collection , dlite . Collection ): self . collection = collection else : raise TypeError ( \"`collection` should be None, string or a collection\" ) def triples ( self , triple : \"Triple\" ) -> \"Generator[Triple, None, None]\" : \"\"\"Returns a generator over matching triples.\"\"\" for s , p , o in self . collection . get_relations ( * triple ): yield s , p , parse_object ( o ) def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" for s , p , o in triples : v = parse_object ( o ) v_str = v . n3 () if isinstance ( v , Literal ) else v self . collection . add_relation ( s , p , v_str ) def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" s , p , o = triple v = parse_object ( o ) v_str = v . n3 () if isinstance ( v , Literal ) else v self . collection . remove_relations ( s , p , v_str )","title":"CollectionStrategy"},{"location":"api_reference/backends/collection/#tripper.backends.collection.CollectionStrategy.add_triples","text":"Add a sequence of triples. Source code in tripper/backends/collection.py def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" for s , p , o in triples : v = parse_object ( o ) v_str = v . n3 () if isinstance ( v , Literal ) else v self . collection . add_relation ( s , p , v_str )","title":"add_triples()"},{"location":"api_reference/backends/collection/#tripper.backends.collection.CollectionStrategy.remove","text":"Remove all matching triples from the backend. Source code in tripper/backends/collection.py def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" s , p , o = triple v = parse_object ( o ) v_str = v . n3 () if isinstance ( v , Literal ) else v self . collection . remove_relations ( s , p , v_str )","title":"remove()"},{"location":"api_reference/backends/collection/#tripper.backends.collection.CollectionStrategy.triples","text":"Returns a generator over matching triples. Source code in tripper/backends/collection.py def triples ( self , triple : \"Triple\" ) -> \"Generator[Triple, None, None]\" : \"\"\"Returns a generator over matching triples.\"\"\" for s , p , o in self . collection . get_relations ( * triple ): yield s , p , parse_object ( o )","title":"triples()"},{"location":"api_reference/backends/ontopy/","text":"ontopy \u00b6 Backend for EMMOntoPy. For developers: The usage of s , p , and o represent the different parts of an RDF Triple: subject, predicate, and object. OntopyStrategy \u00b6 Triplestore strategy for EMMOntoPy. Parameters: Name Type Description Default base_iri Optional[str] The base iri of the ontology. Default to \"http://example.com/onto#\" if onto is not given. None database Optional[str] Unused - ontopy does not support multiple databases. None onto Optional[Ontology] Ontology to initiate the triplestore from. Defaults to an new ontology with the given base_iri . None load bool Whether to load the ontology. False kwargs Keyword arguments passed to the ontology load() method. {} Either the base_iri or onto argument must be provided. Source code in tripper/backends/ontopy.py class OntopyStrategy : \"\"\"Triplestore strategy for EMMOntoPy. Arguments: base_iri: The base iri of the ontology. Default to \"http://example.com/onto#\" if `onto` is not given. database: Unused - ontopy does not support multiple databases. onto: Ontology to initiate the triplestore from. Defaults to an new ontology with the given `base_iri`. load: Whether to load the ontology. kwargs: Keyword arguments passed to the ontology load() method. Either the `base_iri` or `onto` argument must be provided. \"\"\" def __init__ ( self , base_iri : \"Optional[str]\" = None , database : \"Optional[str]\" = None , onto : \"Optional[Ontology]\" = None , load : bool = False , ** kwargs , ): # pylint: disable=unused-argument if onto is None : if base_iri is None : base_iri = \"http://example.com/onto#\" self . onto = get_ontology ( base_iri ) elif isinstance ( onto , Ontology ): self . onto = onto else : raise TypeError ( \"`onto` must be either an ontology or None\" ) if load : self . onto . load ( ** kwargs ) def triples ( self , triple : \"Triple\" ) -> \"Generator[Triple, None, None]\" : \"\"\"Returns a generator over matching triples.\"\"\" def to_literal ( o , datatype ) -> Literal : \"\"\"Returns a literal from (o, datatype).\"\"\" if isinstance ( datatype , str ) and datatype . startswith ( \"@\" ): return Literal ( o , lang = datatype [ 1 :], datatype = None ) return Literal ( o , lang = None , datatype = datatype ) s , p , o = triple abb = ( None if ( s ) is None else self . onto . _abbreviate ( s ), None if ( p ) is None else self . onto . _abbreviate ( p ), None if ( o ) is None else self . onto . _abbreviate ( o ), ) for s , p , o in self . onto . _get_obj_triples_spo_spo ( * abb ): yield ( _unabbreviate ( self . onto , s ), _unabbreviate ( self . onto , p ), _unabbreviate ( self . onto , o ), ) for s , p , o , datatype in self . onto . _get_data_triples_spod_spod ( * abb , d = \"\" ): yield ( _unabbreviate ( self . onto , s ), _unabbreviate ( self . onto , p ), to_literal ( o , datatype ), ) def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" if TYPE_CHECKING : # pragma: no cover datatype : \"Union[int, str]\" for s , p , o in triples : if isinstance ( o , Literal ): if o . lang : datatype = f \"@ { o . lang } \" elif o . datatype : datatype = f \"^^ { o . datatype } \" else : datatype = 0 self . onto . _add_data_triple_spod ( self . onto . _abbreviate ( s ), self . onto . _abbreviate ( p ), self . onto . _abbreviate ( o ), datatype , ) else : self . onto . _add_obj_triple_spo ( self . onto . _abbreviate ( s ), self . onto . _abbreviate ( p ), self . onto . _abbreviate ( o ), ) def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" s , p , o = triple to_remove = list ( self . onto . _get_triples_spod_spod ( self . onto . _abbreviate ( s ) if ( s ) is not None else None , self . onto . _abbreviate ( p ) if ( s ) is not None else None , self . onto . _abbreviate ( o ) if ( s ) is not None else None , ) ) for s , p , o , datatype in to_remove : if datatype : self . onto . _del_data_triple_spod ( s , p , o , datatype ) else : self . onto . _del_obj_triple_spo ( s , p , o ) # Optional methods def parse ( self , source = None , location = None , data = None , format = None , # pylint: disable=redefined-builtin encoding = None , ** kwargs , ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Parameters: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. encoding: Encoding argument to io.open(). kwargs: Additional keyword arguments passed to Ontology.load(). \"\"\" if source : self . onto . load ( filename = source , format = format , ** kwargs ) elif location : self . onto . load ( filename = location , format = format , ** kwargs ) elif data : # s = io.StringIO(data) # self.onto.load(filename=s, format=format, **kwargs) # Could have been done much nicer if it hasn't been for Windows filename = None try : tmpfile_options = { \"delete\" : False } if isinstance ( data , str ): tmpfile_options . update ( mode = \"w+t\" , encoding = encoding ) with tempfile . NamedTemporaryFile ( ** tmpfile_options ) as handle : handle . write ( data ) filename = handle . name self . onto . load ( filename = filename , format = format , ** kwargs ) finally : if filename : os . remove ( filename ) else : raise ValueError ( \"either `source`, `location` or `data` must be given\" ) def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise to destination. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the Ontology.save() method. Returns: Serialised string if `destination` is None. \"\"\" if destination : self . onto . save ( destination , format = format , ** kwargs ) else : # Clumsy implementation due to Windows file locking... filename = None try : with tempfile . NamedTemporaryFile ( delete = False ) as handle : filename = handle . name self . onto . save ( filename , format = format , ** kwargs ) with open ( filename , \"rt\" , encoding = \"utf8\" ) as handle : return handle . read () finally : if filename : os . remove ( filename ) return None def query ( self , query_object , native = True , ** kwargs ) -> \"Union[List, Result]\" : \"\"\"SPARQL query. Parameters: query_object: String with the SPARQL query. native: Whether or not to use EMMOntoPy/Owlready2 or RDFLib. kwargs: Keyword arguments passed to rdflib.Graph.query(). Returns: SPARQL query results. \"\"\" if TYPE_CHECKING : # pragma: no cover res : \"Union[List, Result]\" if native : res = self . onto . world . sparql ( query_object ) else : graph = self . onto . world . as_rdflib_graph () res = graph . query ( query_object , ** kwargs ) # TODO: Convert result to expected type return res def update ( self , update_object , native = True , ** kwargs ) -> None : \"\"\"Update triplestore with SPARQL. Parameters: update_object: String with the SPARQL query. native: Whether or not to use EMMOntoPy/Owlready2 or RDFLib. kwargs: Keyword arguments passed to rdflib.Graph.update(). Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" if native : self . onto . world . sparql ( update_object ) else : graph = self . onto . world . as_rdflib_graph () graph . update ( update_object , ** kwargs ) add_triples ( self , triples ) \u00b6 Add a sequence of triples. Source code in tripper/backends/ontopy.py def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" if TYPE_CHECKING : # pragma: no cover datatype : \"Union[int, str]\" for s , p , o in triples : if isinstance ( o , Literal ): if o . lang : datatype = f \"@ { o . lang } \" elif o . datatype : datatype = f \"^^ { o . datatype } \" else : datatype = 0 self . onto . _add_data_triple_spod ( self . onto . _abbreviate ( s ), self . onto . _abbreviate ( p ), self . onto . _abbreviate ( o ), datatype , ) else : self . onto . _add_obj_triple_spo ( self . onto . _abbreviate ( s ), self . onto . _abbreviate ( p ), self . onto . _abbreviate ( o ), ) parse ( self , source = None , location = None , data = None , format = None , encoding = None , ** kwargs ) \u00b6 Parse source and add the resulting triples to triplestore. The source is specified using one of source , location or data . Parameters: Name Type Description Default source File-like object or file name. None location String with relative or absolute URL to source. None data String containing the data to be parsed. None format Needed if format can not be inferred from source. None encoding Encoding argument to io.open(). None kwargs Additional keyword arguments passed to Ontology.load(). {} Source code in tripper/backends/ontopy.py def parse ( self , source = None , location = None , data = None , format = None , # pylint: disable=redefined-builtin encoding = None , ** kwargs , ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Parameters: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. encoding: Encoding argument to io.open(). kwargs: Additional keyword arguments passed to Ontology.load(). \"\"\" if source : self . onto . load ( filename = source , format = format , ** kwargs ) elif location : self . onto . load ( filename = location , format = format , ** kwargs ) elif data : # s = io.StringIO(data) # self.onto.load(filename=s, format=format, **kwargs) # Could have been done much nicer if it hasn't been for Windows filename = None try : tmpfile_options = { \"delete\" : False } if isinstance ( data , str ): tmpfile_options . update ( mode = \"w+t\" , encoding = encoding ) with tempfile . NamedTemporaryFile ( ** tmpfile_options ) as handle : handle . write ( data ) filename = handle . name self . onto . load ( filename = filename , format = format , ** kwargs ) finally : if filename : os . remove ( filename ) else : raise ValueError ( \"either `source`, `location` or `data` must be given\" ) query ( self , query_object , native = True , ** kwargs ) \u00b6 SPARQL query. Parameters: Name Type Description Default query_object String with the SPARQL query. required native Whether or not to use EMMOntoPy/Owlready2 or RDFLib. True kwargs Keyword arguments passed to rdflib.Graph.query(). {} Returns: Type Description Union[List, Result] SPARQL query results. Source code in tripper/backends/ontopy.py def query ( self , query_object , native = True , ** kwargs ) -> \"Union[List, Result]\" : \"\"\"SPARQL query. Parameters: query_object: String with the SPARQL query. native: Whether or not to use EMMOntoPy/Owlready2 or RDFLib. kwargs: Keyword arguments passed to rdflib.Graph.query(). Returns: SPARQL query results. \"\"\" if TYPE_CHECKING : # pragma: no cover res : \"Union[List, Result]\" if native : res = self . onto . world . sparql ( query_object ) else : graph = self . onto . world . as_rdflib_graph () res = graph . query ( query_object , ** kwargs ) # TODO: Convert result to expected type return res remove ( self , triple ) \u00b6 Remove all matching triples from the backend. Source code in tripper/backends/ontopy.py def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" s , p , o = triple to_remove = list ( self . onto . _get_triples_spod_spod ( self . onto . _abbreviate ( s ) if ( s ) is not None else None , self . onto . _abbreviate ( p ) if ( s ) is not None else None , self . onto . _abbreviate ( o ) if ( s ) is not None else None , ) ) for s , p , o , datatype in to_remove : if datatype : self . onto . _del_data_triple_spod ( s , p , o , datatype ) else : self . onto . _del_obj_triple_spo ( s , p , o ) serialize ( self , destination = None , format = 'turtle' , ** kwargs ) \u00b6 Serialise to destination. Parameters: Name Type Description Default destination File name or object to write to. If None, the serialisation is returned. None format Format to serialise as. Supported formats, depends on the backend. 'turtle' kwargs Passed to the Ontology.save() method. {} Returns: Type Description Union[None, str] Serialised string if destination is None. Source code in tripper/backends/ontopy.py def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise to destination. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the Ontology.save() method. Returns: Serialised string if `destination` is None. \"\"\" if destination : self . onto . save ( destination , format = format , ** kwargs ) else : # Clumsy implementation due to Windows file locking... filename = None try : with tempfile . NamedTemporaryFile ( delete = False ) as handle : filename = handle . name self . onto . save ( filename , format = format , ** kwargs ) with open ( filename , \"rt\" , encoding = \"utf8\" ) as handle : return handle . read () finally : if filename : os . remove ( filename ) return None triples ( self , triple ) \u00b6 Returns a generator over matching triples. Source code in tripper/backends/ontopy.py def triples ( self , triple : \"Triple\" ) -> \"Generator[Triple, None, None]\" : \"\"\"Returns a generator over matching triples.\"\"\" def to_literal ( o , datatype ) -> Literal : \"\"\"Returns a literal from (o, datatype).\"\"\" if isinstance ( datatype , str ) and datatype . startswith ( \"@\" ): return Literal ( o , lang = datatype [ 1 :], datatype = None ) return Literal ( o , lang = None , datatype = datatype ) s , p , o = triple abb = ( None if ( s ) is None else self . onto . _abbreviate ( s ), None if ( p ) is None else self . onto . _abbreviate ( p ), None if ( o ) is None else self . onto . _abbreviate ( o ), ) for s , p , o in self . onto . _get_obj_triples_spo_spo ( * abb ): yield ( _unabbreviate ( self . onto , s ), _unabbreviate ( self . onto , p ), _unabbreviate ( self . onto , o ), ) for s , p , o , datatype in self . onto . _get_data_triples_spod_spod ( * abb , d = \"\" ): yield ( _unabbreviate ( self . onto , s ), _unabbreviate ( self . onto , p ), to_literal ( o , datatype ), ) update ( self , update_object , native = True , ** kwargs ) \u00b6 Update triplestore with SPARQL. Parameters: Name Type Description Default update_object String with the SPARQL query. required native Whether or not to use EMMOntoPy/Owlready2 or RDFLib. True kwargs Keyword arguments passed to rdflib.Graph.update(). {} Note This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. Source code in tripper/backends/ontopy.py def update ( self , update_object , native = True , ** kwargs ) -> None : \"\"\"Update triplestore with SPARQL. Parameters: update_object: String with the SPARQL query. native: Whether or not to use EMMOntoPy/Owlready2 or RDFLib. kwargs: Keyword arguments passed to rdflib.Graph.update(). Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" if native : self . onto . world . sparql ( update_object ) else : graph = self . onto . world . as_rdflib_graph () graph . update ( update_object , ** kwargs )","title":"ontopy"},{"location":"api_reference/backends/ontopy/#ontopy","text":"Backend for EMMOntoPy. For developers: The usage of s , p , and o represent the different parts of an RDF Triple: subject, predicate, and object.","title":"ontopy"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy","text":"Triplestore strategy for EMMOntoPy. Parameters: Name Type Description Default base_iri Optional[str] The base iri of the ontology. Default to \"http://example.com/onto#\" if onto is not given. None database Optional[str] Unused - ontopy does not support multiple databases. None onto Optional[Ontology] Ontology to initiate the triplestore from. Defaults to an new ontology with the given base_iri . None load bool Whether to load the ontology. False kwargs Keyword arguments passed to the ontology load() method. {} Either the base_iri or onto argument must be provided. Source code in tripper/backends/ontopy.py class OntopyStrategy : \"\"\"Triplestore strategy for EMMOntoPy. Arguments: base_iri: The base iri of the ontology. Default to \"http://example.com/onto#\" if `onto` is not given. database: Unused - ontopy does not support multiple databases. onto: Ontology to initiate the triplestore from. Defaults to an new ontology with the given `base_iri`. load: Whether to load the ontology. kwargs: Keyword arguments passed to the ontology load() method. Either the `base_iri` or `onto` argument must be provided. \"\"\" def __init__ ( self , base_iri : \"Optional[str]\" = None , database : \"Optional[str]\" = None , onto : \"Optional[Ontology]\" = None , load : bool = False , ** kwargs , ): # pylint: disable=unused-argument if onto is None : if base_iri is None : base_iri = \"http://example.com/onto#\" self . onto = get_ontology ( base_iri ) elif isinstance ( onto , Ontology ): self . onto = onto else : raise TypeError ( \"`onto` must be either an ontology or None\" ) if load : self . onto . load ( ** kwargs ) def triples ( self , triple : \"Triple\" ) -> \"Generator[Triple, None, None]\" : \"\"\"Returns a generator over matching triples.\"\"\" def to_literal ( o , datatype ) -> Literal : \"\"\"Returns a literal from (o, datatype).\"\"\" if isinstance ( datatype , str ) and datatype . startswith ( \"@\" ): return Literal ( o , lang = datatype [ 1 :], datatype = None ) return Literal ( o , lang = None , datatype = datatype ) s , p , o = triple abb = ( None if ( s ) is None else self . onto . _abbreviate ( s ), None if ( p ) is None else self . onto . _abbreviate ( p ), None if ( o ) is None else self . onto . _abbreviate ( o ), ) for s , p , o in self . onto . _get_obj_triples_spo_spo ( * abb ): yield ( _unabbreviate ( self . onto , s ), _unabbreviate ( self . onto , p ), _unabbreviate ( self . onto , o ), ) for s , p , o , datatype in self . onto . _get_data_triples_spod_spod ( * abb , d = \"\" ): yield ( _unabbreviate ( self . onto , s ), _unabbreviate ( self . onto , p ), to_literal ( o , datatype ), ) def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" if TYPE_CHECKING : # pragma: no cover datatype : \"Union[int, str]\" for s , p , o in triples : if isinstance ( o , Literal ): if o . lang : datatype = f \"@ { o . lang } \" elif o . datatype : datatype = f \"^^ { o . datatype } \" else : datatype = 0 self . onto . _add_data_triple_spod ( self . onto . _abbreviate ( s ), self . onto . _abbreviate ( p ), self . onto . _abbreviate ( o ), datatype , ) else : self . onto . _add_obj_triple_spo ( self . onto . _abbreviate ( s ), self . onto . _abbreviate ( p ), self . onto . _abbreviate ( o ), ) def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" s , p , o = triple to_remove = list ( self . onto . _get_triples_spod_spod ( self . onto . _abbreviate ( s ) if ( s ) is not None else None , self . onto . _abbreviate ( p ) if ( s ) is not None else None , self . onto . _abbreviate ( o ) if ( s ) is not None else None , ) ) for s , p , o , datatype in to_remove : if datatype : self . onto . _del_data_triple_spod ( s , p , o , datatype ) else : self . onto . _del_obj_triple_spo ( s , p , o ) # Optional methods def parse ( self , source = None , location = None , data = None , format = None , # pylint: disable=redefined-builtin encoding = None , ** kwargs , ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Parameters: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. encoding: Encoding argument to io.open(). kwargs: Additional keyword arguments passed to Ontology.load(). \"\"\" if source : self . onto . load ( filename = source , format = format , ** kwargs ) elif location : self . onto . load ( filename = location , format = format , ** kwargs ) elif data : # s = io.StringIO(data) # self.onto.load(filename=s, format=format, **kwargs) # Could have been done much nicer if it hasn't been for Windows filename = None try : tmpfile_options = { \"delete\" : False } if isinstance ( data , str ): tmpfile_options . update ( mode = \"w+t\" , encoding = encoding ) with tempfile . NamedTemporaryFile ( ** tmpfile_options ) as handle : handle . write ( data ) filename = handle . name self . onto . load ( filename = filename , format = format , ** kwargs ) finally : if filename : os . remove ( filename ) else : raise ValueError ( \"either `source`, `location` or `data` must be given\" ) def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise to destination. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the Ontology.save() method. Returns: Serialised string if `destination` is None. \"\"\" if destination : self . onto . save ( destination , format = format , ** kwargs ) else : # Clumsy implementation due to Windows file locking... filename = None try : with tempfile . NamedTemporaryFile ( delete = False ) as handle : filename = handle . name self . onto . save ( filename , format = format , ** kwargs ) with open ( filename , \"rt\" , encoding = \"utf8\" ) as handle : return handle . read () finally : if filename : os . remove ( filename ) return None def query ( self , query_object , native = True , ** kwargs ) -> \"Union[List, Result]\" : \"\"\"SPARQL query. Parameters: query_object: String with the SPARQL query. native: Whether or not to use EMMOntoPy/Owlready2 or RDFLib. kwargs: Keyword arguments passed to rdflib.Graph.query(). Returns: SPARQL query results. \"\"\" if TYPE_CHECKING : # pragma: no cover res : \"Union[List, Result]\" if native : res = self . onto . world . sparql ( query_object ) else : graph = self . onto . world . as_rdflib_graph () res = graph . query ( query_object , ** kwargs ) # TODO: Convert result to expected type return res def update ( self , update_object , native = True , ** kwargs ) -> None : \"\"\"Update triplestore with SPARQL. Parameters: update_object: String with the SPARQL query. native: Whether or not to use EMMOntoPy/Owlready2 or RDFLib. kwargs: Keyword arguments passed to rdflib.Graph.update(). Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" if native : self . onto . world . sparql ( update_object ) else : graph = self . onto . world . as_rdflib_graph () graph . update ( update_object , ** kwargs )","title":"OntopyStrategy"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.add_triples","text":"Add a sequence of triples. Source code in tripper/backends/ontopy.py def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" if TYPE_CHECKING : # pragma: no cover datatype : \"Union[int, str]\" for s , p , o in triples : if isinstance ( o , Literal ): if o . lang : datatype = f \"@ { o . lang } \" elif o . datatype : datatype = f \"^^ { o . datatype } \" else : datatype = 0 self . onto . _add_data_triple_spod ( self . onto . _abbreviate ( s ), self . onto . _abbreviate ( p ), self . onto . _abbreviate ( o ), datatype , ) else : self . onto . _add_obj_triple_spo ( self . onto . _abbreviate ( s ), self . onto . _abbreviate ( p ), self . onto . _abbreviate ( o ), )","title":"add_triples()"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.parse","text":"Parse source and add the resulting triples to triplestore. The source is specified using one of source , location or data . Parameters: Name Type Description Default source File-like object or file name. None location String with relative or absolute URL to source. None data String containing the data to be parsed. None format Needed if format can not be inferred from source. None encoding Encoding argument to io.open(). None kwargs Additional keyword arguments passed to Ontology.load(). {} Source code in tripper/backends/ontopy.py def parse ( self , source = None , location = None , data = None , format = None , # pylint: disable=redefined-builtin encoding = None , ** kwargs , ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Parameters: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. encoding: Encoding argument to io.open(). kwargs: Additional keyword arguments passed to Ontology.load(). \"\"\" if source : self . onto . load ( filename = source , format = format , ** kwargs ) elif location : self . onto . load ( filename = location , format = format , ** kwargs ) elif data : # s = io.StringIO(data) # self.onto.load(filename=s, format=format, **kwargs) # Could have been done much nicer if it hasn't been for Windows filename = None try : tmpfile_options = { \"delete\" : False } if isinstance ( data , str ): tmpfile_options . update ( mode = \"w+t\" , encoding = encoding ) with tempfile . NamedTemporaryFile ( ** tmpfile_options ) as handle : handle . write ( data ) filename = handle . name self . onto . load ( filename = filename , format = format , ** kwargs ) finally : if filename : os . remove ( filename ) else : raise ValueError ( \"either `source`, `location` or `data` must be given\" )","title":"parse()"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.query","text":"SPARQL query. Parameters: Name Type Description Default query_object String with the SPARQL query. required native Whether or not to use EMMOntoPy/Owlready2 or RDFLib. True kwargs Keyword arguments passed to rdflib.Graph.query(). {} Returns: Type Description Union[List, Result] SPARQL query results. Source code in tripper/backends/ontopy.py def query ( self , query_object , native = True , ** kwargs ) -> \"Union[List, Result]\" : \"\"\"SPARQL query. Parameters: query_object: String with the SPARQL query. native: Whether or not to use EMMOntoPy/Owlready2 or RDFLib. kwargs: Keyword arguments passed to rdflib.Graph.query(). Returns: SPARQL query results. \"\"\" if TYPE_CHECKING : # pragma: no cover res : \"Union[List, Result]\" if native : res = self . onto . world . sparql ( query_object ) else : graph = self . onto . world . as_rdflib_graph () res = graph . query ( query_object , ** kwargs ) # TODO: Convert result to expected type return res","title":"query()"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.remove","text":"Remove all matching triples from the backend. Source code in tripper/backends/ontopy.py def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" s , p , o = triple to_remove = list ( self . onto . _get_triples_spod_spod ( self . onto . _abbreviate ( s ) if ( s ) is not None else None , self . onto . _abbreviate ( p ) if ( s ) is not None else None , self . onto . _abbreviate ( o ) if ( s ) is not None else None , ) ) for s , p , o , datatype in to_remove : if datatype : self . onto . _del_data_triple_spod ( s , p , o , datatype ) else : self . onto . _del_obj_triple_spo ( s , p , o )","title":"remove()"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.serialize","text":"Serialise to destination. Parameters: Name Type Description Default destination File name or object to write to. If None, the serialisation is returned. None format Format to serialise as. Supported formats, depends on the backend. 'turtle' kwargs Passed to the Ontology.save() method. {} Returns: Type Description Union[None, str] Serialised string if destination is None. Source code in tripper/backends/ontopy.py def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise to destination. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the Ontology.save() method. Returns: Serialised string if `destination` is None. \"\"\" if destination : self . onto . save ( destination , format = format , ** kwargs ) else : # Clumsy implementation due to Windows file locking... filename = None try : with tempfile . NamedTemporaryFile ( delete = False ) as handle : filename = handle . name self . onto . save ( filename , format = format , ** kwargs ) with open ( filename , \"rt\" , encoding = \"utf8\" ) as handle : return handle . read () finally : if filename : os . remove ( filename ) return None","title":"serialize()"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.triples","text":"Returns a generator over matching triples. Source code in tripper/backends/ontopy.py def triples ( self , triple : \"Triple\" ) -> \"Generator[Triple, None, None]\" : \"\"\"Returns a generator over matching triples.\"\"\" def to_literal ( o , datatype ) -> Literal : \"\"\"Returns a literal from (o, datatype).\"\"\" if isinstance ( datatype , str ) and datatype . startswith ( \"@\" ): return Literal ( o , lang = datatype [ 1 :], datatype = None ) return Literal ( o , lang = None , datatype = datatype ) s , p , o = triple abb = ( None if ( s ) is None else self . onto . _abbreviate ( s ), None if ( p ) is None else self . onto . _abbreviate ( p ), None if ( o ) is None else self . onto . _abbreviate ( o ), ) for s , p , o in self . onto . _get_obj_triples_spo_spo ( * abb ): yield ( _unabbreviate ( self . onto , s ), _unabbreviate ( self . onto , p ), _unabbreviate ( self . onto , o ), ) for s , p , o , datatype in self . onto . _get_data_triples_spod_spod ( * abb , d = \"\" ): yield ( _unabbreviate ( self . onto , s ), _unabbreviate ( self . onto , p ), to_literal ( o , datatype ), )","title":"triples()"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.update","text":"Update triplestore with SPARQL. Parameters: Name Type Description Default update_object String with the SPARQL query. required native Whether or not to use EMMOntoPy/Owlready2 or RDFLib. True kwargs Keyword arguments passed to rdflib.Graph.update(). {} Note This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. Source code in tripper/backends/ontopy.py def update ( self , update_object , native = True , ** kwargs ) -> None : \"\"\"Update triplestore with SPARQL. Parameters: update_object: String with the SPARQL query. native: Whether or not to use EMMOntoPy/Owlready2 or RDFLib. kwargs: Keyword arguments passed to rdflib.Graph.update(). Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" if native : self . onto . world . sparql ( update_object ) else : graph = self . onto . world . as_rdflib_graph () graph . update ( update_object , ** kwargs )","title":"update()"},{"location":"api_reference/backends/rdflib/","text":"rdflib \u00b6 Backend for RDFLib. For developers: The usage of s , p , and o represent the different parts of an RDF Triple: subject, predicate, and object. RdflibStrategy \u00b6 Triplestore strategy for rdflib. Parameters: Name Type Description Default base_iri Optional[str] Unused by this backend. None database Optional[str] Unused - rdflib does not support multiple databases. None triplestore_url Optional[str] If given, initialise the triplestore from this storage. When close() is called, the storage will be overwritten with the current content of the triplestore. None format Optional[str] Format of storage specified with base_iri . None Source code in tripper/backends/rdflib.py class RdflibStrategy : \"\"\"Triplestore strategy for rdflib. Arguments: base_iri: Unused by this backend. database: Unused - rdflib does not support multiple databases. triplestore_url: If given, initialise the triplestore from this storage. When `close()` is called, the storage will be overwritten with the current content of the triplestore. format: Format of storage specified with `base_iri`. \"\"\" def __init__ ( self , base_iri : \"Optional[str]\" = None , database : \"Optional[str]\" = None , triplestore_url : \"Optional[str]\" = None , format : \"Optional[str]\" = None , # pylint: disable=redefined-builtin ) -> None : if base_iri : warnings . warn ( \"base_iri\" , UnusedArgumentWarning , stacklevel = 2 ) if database : warnings . warn ( \"database\" , UnusedArgumentWarning , stacklevel = 2 ) self . graph = Graph () self . triplestore_url = triplestore_url if self . triplestore_url is not None : if format is None : format = guess_format ( self . triplestore_url ) self . parse ( location = self . triplestore_url , format = format ) self . base_format = format def triples ( self , triple : \"Triple\" ) -> \"Generator[Triple, None, None]\" : \"\"\"Returns a generator over matching triples.\"\"\" for s , p , o in self . graph . triples ( # pylint: disable=not-an-iterable astriple ( triple ) ): yield ( str ( s ), str ( p ), Literal ( o . value , lang = o . language , datatype = o . datatype ) if isinstance ( o , rdflibLiteral ) else str ( o ), ) def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" for triple in triples : self . graph . add ( astriple ( triple )) def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" self . graph . remove ( astriple ( triple )) # Optional methods def close ( self ): \"\"\"Close the internal RDFLib graph.\"\"\" if self . triplestore_url : self . serialize ( destination = self . triplestore_url , format = self . base_format ) self . graph . close () def parse ( self , source = None , location = None , data = None , format = None , # pylint: disable=redefined-builtin ** kwargs , ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Parameters: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. kwargs: Additional less used keyword arguments. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.parse \"\"\" self . graph . parse ( source = source , location = location , data = data , format = format , ** kwargs ) def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise to destination. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the rdflib.Graph.serialize() method. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.serialize Returns: Serialised string if `destination` is None. \"\"\" result = self . graph . serialize ( destination = destination , format = format , ** kwargs ) if destination is None : # Depending on the version of rdflib the return value of # graph.serialize() man either be a string or a bytes object... return result if isinstance ( result , str ) else result . decode () return None def query ( self , query_object , ** kwargs ) -> \"List[Tuple[str, ...]]\" : \"\"\"SPARQL query. Parameters: query_object: String with the SPARQL query. kwargs: Keyword arguments passed to rdflib.Graph.query(). Returns: List of tuples of IRIs for each matching row. \"\"\" rows = self . graph . query ( query_object = query_object , ** kwargs ) return [ tuple ( str ( v ) for v in row ) for row in rows ] def update ( self , update_object , ** kwargs ) -> None : \"\"\"Update triplestore with SPARQL. Parameters: update_object: String with the SPARQL query. kwargs: Keyword arguments passed to rdflib.Graph.update(). Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" return self . graph . update ( update_object = update_object , ** kwargs ) def bind ( self , prefix : str , namespace : str ): \"\"\"Bind prefix to namespace. Should only be defined if the backend supports namespaces. Called by triplestore.bind(). \"\"\" if namespace : self . graph . bind ( prefix , namespace , replace = True ) else : warnings . warn ( \"rdflib does not support removing namespace prefixes\" ) def namespaces ( self ) -> dict : \"\"\"Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. \"\"\" return { prefix : str ( namespace ) for prefix , namespace in self . graph . namespaces ()} add_triples ( self , triples ) \u00b6 Add a sequence of triples. Source code in tripper/backends/rdflib.py def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" for triple in triples : self . graph . add ( astriple ( triple )) bind ( self , prefix , namespace ) \u00b6 Bind prefix to namespace. Should only be defined if the backend supports namespaces. Called by triplestore.bind(). Source code in tripper/backends/rdflib.py def bind ( self , prefix : str , namespace : str ): \"\"\"Bind prefix to namespace. Should only be defined if the backend supports namespaces. Called by triplestore.bind(). \"\"\" if namespace : self . graph . bind ( prefix , namespace , replace = True ) else : warnings . warn ( \"rdflib does not support removing namespace prefixes\" ) close ( self ) \u00b6 Close the internal RDFLib graph. Source code in tripper/backends/rdflib.py def close ( self ): \"\"\"Close the internal RDFLib graph.\"\"\" if self . triplestore_url : self . serialize ( destination = self . triplestore_url , format = self . base_format ) self . graph . close () namespaces ( self ) \u00b6 Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. Source code in tripper/backends/rdflib.py def namespaces ( self ) -> dict : \"\"\"Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. \"\"\" return { prefix : str ( namespace ) for prefix , namespace in self . graph . namespaces ()} parse ( self , source = None , location = None , data = None , format = None , ** kwargs ) \u00b6 Parse source and add the resulting triples to triplestore. The source is specified using one of source , location or data . Parameters: Name Type Description Default source File-like object or file name. None location String with relative or absolute URL to source. None data String containing the data to be parsed. None format Needed if format can not be inferred from source. None kwargs Additional less used keyword arguments. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.parse {} Source code in tripper/backends/rdflib.py def parse ( self , source = None , location = None , data = None , format = None , # pylint: disable=redefined-builtin ** kwargs , ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Parameters: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. kwargs: Additional less used keyword arguments. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.parse \"\"\" self . graph . parse ( source = source , location = location , data = data , format = format , ** kwargs ) query ( self , query_object , ** kwargs ) \u00b6 SPARQL query. Parameters: Name Type Description Default query_object String with the SPARQL query. required kwargs Keyword arguments passed to rdflib.Graph.query(). {} Returns: Type Description List[Tuple[str, ...]] List of tuples of IRIs for each matching row. Source code in tripper/backends/rdflib.py def query ( self , query_object , ** kwargs ) -> \"List[Tuple[str, ...]]\" : \"\"\"SPARQL query. Parameters: query_object: String with the SPARQL query. kwargs: Keyword arguments passed to rdflib.Graph.query(). Returns: List of tuples of IRIs for each matching row. \"\"\" rows = self . graph . query ( query_object = query_object , ** kwargs ) return [ tuple ( str ( v ) for v in row ) for row in rows ] remove ( self , triple ) \u00b6 Remove all matching triples from the backend. Source code in tripper/backends/rdflib.py def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" self . graph . remove ( astriple ( triple )) serialize ( self , destination = None , format = 'turtle' , ** kwargs ) \u00b6 Serialise to destination. Parameters: Name Type Description Default destination File name or object to write to. If None, the serialisation is returned. None format Format to serialise as. Supported formats, depends on the backend. 'turtle' kwargs Passed to the rdflib.Graph.serialize() method. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.serialize {} Returns: Type Description Union[None, str] Serialised string if destination is None. Source code in tripper/backends/rdflib.py def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise to destination. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the rdflib.Graph.serialize() method. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.serialize Returns: Serialised string if `destination` is None. \"\"\" result = self . graph . serialize ( destination = destination , format = format , ** kwargs ) if destination is None : # Depending on the version of rdflib the return value of # graph.serialize() man either be a string or a bytes object... return result if isinstance ( result , str ) else result . decode () return None triples ( self , triple ) \u00b6 Returns a generator over matching triples. Source code in tripper/backends/rdflib.py def triples ( self , triple : \"Triple\" ) -> \"Generator[Triple, None, None]\" : \"\"\"Returns a generator over matching triples.\"\"\" for s , p , o in self . graph . triples ( # pylint: disable=not-an-iterable astriple ( triple ) ): yield ( str ( s ), str ( p ), Literal ( o . value , lang = o . language , datatype = o . datatype ) if isinstance ( o , rdflibLiteral ) else str ( o ), ) update ( self , update_object , ** kwargs ) \u00b6 Update triplestore with SPARQL. Parameters: Name Type Description Default update_object String with the SPARQL query. required kwargs Keyword arguments passed to rdflib.Graph.update(). {} Note This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. Source code in tripper/backends/rdflib.py def update ( self , update_object , ** kwargs ) -> None : \"\"\"Update triplestore with SPARQL. Parameters: update_object: String with the SPARQL query. kwargs: Keyword arguments passed to rdflib.Graph.update(). Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" return self . graph . update ( update_object = update_object , ** kwargs ) astriple ( triple ) \u00b6 Help function converting a triple to rdflib triple. Source code in tripper/backends/rdflib.py def astriple ( triple : \"Triple\" ): \"\"\"Help function converting a triple to rdflib triple.\"\"\" s , p , o = triple return asuri ( s ), asuri ( p ), asuri ( o ) asuri ( value ) \u00b6 Help function converting a spo-value to proper rdflib type. Source code in tripper/backends/rdflib.py def asuri ( value : \"Union[None, Literal, str]\" ): \"\"\"Help function converting a spo-value to proper rdflib type.\"\"\" if value is None : return None if isinstance ( value , Literal ): return rdflibLiteral ( value . value , lang = value . lang , datatype = value . datatype ) if value . startswith ( \"_:\" ): return BNode ( value ) return URIRef ( value )","title":"rdflib"},{"location":"api_reference/backends/rdflib/#rdflib","text":"Backend for RDFLib. For developers: The usage of s , p , and o represent the different parts of an RDF Triple: subject, predicate, and object.","title":"rdflib"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy","text":"Triplestore strategy for rdflib. Parameters: Name Type Description Default base_iri Optional[str] Unused by this backend. None database Optional[str] Unused - rdflib does not support multiple databases. None triplestore_url Optional[str] If given, initialise the triplestore from this storage. When close() is called, the storage will be overwritten with the current content of the triplestore. None format Optional[str] Format of storage specified with base_iri . None Source code in tripper/backends/rdflib.py class RdflibStrategy : \"\"\"Triplestore strategy for rdflib. Arguments: base_iri: Unused by this backend. database: Unused - rdflib does not support multiple databases. triplestore_url: If given, initialise the triplestore from this storage. When `close()` is called, the storage will be overwritten with the current content of the triplestore. format: Format of storage specified with `base_iri`. \"\"\" def __init__ ( self , base_iri : \"Optional[str]\" = None , database : \"Optional[str]\" = None , triplestore_url : \"Optional[str]\" = None , format : \"Optional[str]\" = None , # pylint: disable=redefined-builtin ) -> None : if base_iri : warnings . warn ( \"base_iri\" , UnusedArgumentWarning , stacklevel = 2 ) if database : warnings . warn ( \"database\" , UnusedArgumentWarning , stacklevel = 2 ) self . graph = Graph () self . triplestore_url = triplestore_url if self . triplestore_url is not None : if format is None : format = guess_format ( self . triplestore_url ) self . parse ( location = self . triplestore_url , format = format ) self . base_format = format def triples ( self , triple : \"Triple\" ) -> \"Generator[Triple, None, None]\" : \"\"\"Returns a generator over matching triples.\"\"\" for s , p , o in self . graph . triples ( # pylint: disable=not-an-iterable astriple ( triple ) ): yield ( str ( s ), str ( p ), Literal ( o . value , lang = o . language , datatype = o . datatype ) if isinstance ( o , rdflibLiteral ) else str ( o ), ) def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" for triple in triples : self . graph . add ( astriple ( triple )) def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" self . graph . remove ( astriple ( triple )) # Optional methods def close ( self ): \"\"\"Close the internal RDFLib graph.\"\"\" if self . triplestore_url : self . serialize ( destination = self . triplestore_url , format = self . base_format ) self . graph . close () def parse ( self , source = None , location = None , data = None , format = None , # pylint: disable=redefined-builtin ** kwargs , ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Parameters: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. kwargs: Additional less used keyword arguments. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.parse \"\"\" self . graph . parse ( source = source , location = location , data = data , format = format , ** kwargs ) def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise to destination. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the rdflib.Graph.serialize() method. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.serialize Returns: Serialised string if `destination` is None. \"\"\" result = self . graph . serialize ( destination = destination , format = format , ** kwargs ) if destination is None : # Depending on the version of rdflib the return value of # graph.serialize() man either be a string or a bytes object... return result if isinstance ( result , str ) else result . decode () return None def query ( self , query_object , ** kwargs ) -> \"List[Tuple[str, ...]]\" : \"\"\"SPARQL query. Parameters: query_object: String with the SPARQL query. kwargs: Keyword arguments passed to rdflib.Graph.query(). Returns: List of tuples of IRIs for each matching row. \"\"\" rows = self . graph . query ( query_object = query_object , ** kwargs ) return [ tuple ( str ( v ) for v in row ) for row in rows ] def update ( self , update_object , ** kwargs ) -> None : \"\"\"Update triplestore with SPARQL. Parameters: update_object: String with the SPARQL query. kwargs: Keyword arguments passed to rdflib.Graph.update(). Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" return self . graph . update ( update_object = update_object , ** kwargs ) def bind ( self , prefix : str , namespace : str ): \"\"\"Bind prefix to namespace. Should only be defined if the backend supports namespaces. Called by triplestore.bind(). \"\"\" if namespace : self . graph . bind ( prefix , namespace , replace = True ) else : warnings . warn ( \"rdflib does not support removing namespace prefixes\" ) def namespaces ( self ) -> dict : \"\"\"Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. \"\"\" return { prefix : str ( namespace ) for prefix , namespace in self . graph . namespaces ()}","title":"RdflibStrategy"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.add_triples","text":"Add a sequence of triples. Source code in tripper/backends/rdflib.py def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" for triple in triples : self . graph . add ( astriple ( triple ))","title":"add_triples()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.bind","text":"Bind prefix to namespace. Should only be defined if the backend supports namespaces. Called by triplestore.bind(). Source code in tripper/backends/rdflib.py def bind ( self , prefix : str , namespace : str ): \"\"\"Bind prefix to namespace. Should only be defined if the backend supports namespaces. Called by triplestore.bind(). \"\"\" if namespace : self . graph . bind ( prefix , namespace , replace = True ) else : warnings . warn ( \"rdflib does not support removing namespace prefixes\" )","title":"bind()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.close","text":"Close the internal RDFLib graph. Source code in tripper/backends/rdflib.py def close ( self ): \"\"\"Close the internal RDFLib graph.\"\"\" if self . triplestore_url : self . serialize ( destination = self . triplestore_url , format = self . base_format ) self . graph . close ()","title":"close()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.namespaces","text":"Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. Source code in tripper/backends/rdflib.py def namespaces ( self ) -> dict : \"\"\"Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. \"\"\" return { prefix : str ( namespace ) for prefix , namespace in self . graph . namespaces ()}","title":"namespaces()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.parse","text":"Parse source and add the resulting triples to triplestore. The source is specified using one of source , location or data . Parameters: Name Type Description Default source File-like object or file name. None location String with relative or absolute URL to source. None data String containing the data to be parsed. None format Needed if format can not be inferred from source. None kwargs Additional less used keyword arguments. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.parse {} Source code in tripper/backends/rdflib.py def parse ( self , source = None , location = None , data = None , format = None , # pylint: disable=redefined-builtin ** kwargs , ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Parameters: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. kwargs: Additional less used keyword arguments. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.parse \"\"\" self . graph . parse ( source = source , location = location , data = data , format = format , ** kwargs )","title":"parse()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.query","text":"SPARQL query. Parameters: Name Type Description Default query_object String with the SPARQL query. required kwargs Keyword arguments passed to rdflib.Graph.query(). {} Returns: Type Description List[Tuple[str, ...]] List of tuples of IRIs for each matching row. Source code in tripper/backends/rdflib.py def query ( self , query_object , ** kwargs ) -> \"List[Tuple[str, ...]]\" : \"\"\"SPARQL query. Parameters: query_object: String with the SPARQL query. kwargs: Keyword arguments passed to rdflib.Graph.query(). Returns: List of tuples of IRIs for each matching row. \"\"\" rows = self . graph . query ( query_object = query_object , ** kwargs ) return [ tuple ( str ( v ) for v in row ) for row in rows ]","title":"query()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.remove","text":"Remove all matching triples from the backend. Source code in tripper/backends/rdflib.py def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" self . graph . remove ( astriple ( triple ))","title":"remove()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.serialize","text":"Serialise to destination. Parameters: Name Type Description Default destination File name or object to write to. If None, the serialisation is returned. None format Format to serialise as. Supported formats, depends on the backend. 'turtle' kwargs Passed to the rdflib.Graph.serialize() method. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.serialize {} Returns: Type Description Union[None, str] Serialised string if destination is None. Source code in tripper/backends/rdflib.py def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise to destination. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the rdflib.Graph.serialize() method. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.serialize Returns: Serialised string if `destination` is None. \"\"\" result = self . graph . serialize ( destination = destination , format = format , ** kwargs ) if destination is None : # Depending on the version of rdflib the return value of # graph.serialize() man either be a string or a bytes object... return result if isinstance ( result , str ) else result . decode () return None","title":"serialize()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.triples","text":"Returns a generator over matching triples. Source code in tripper/backends/rdflib.py def triples ( self , triple : \"Triple\" ) -> \"Generator[Triple, None, None]\" : \"\"\"Returns a generator over matching triples.\"\"\" for s , p , o in self . graph . triples ( # pylint: disable=not-an-iterable astriple ( triple ) ): yield ( str ( s ), str ( p ), Literal ( o . value , lang = o . language , datatype = o . datatype ) if isinstance ( o , rdflibLiteral ) else str ( o ), )","title":"triples()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.update","text":"Update triplestore with SPARQL. Parameters: Name Type Description Default update_object String with the SPARQL query. required kwargs Keyword arguments passed to rdflib.Graph.update(). {} Note This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. Source code in tripper/backends/rdflib.py def update ( self , update_object , ** kwargs ) -> None : \"\"\"Update triplestore with SPARQL. Parameters: update_object: String with the SPARQL query. kwargs: Keyword arguments passed to rdflib.Graph.update(). Note: This method is intended for INSERT and DELETE queries. Use the query() method for SELECT queries. \"\"\" return self . graph . update ( update_object = update_object , ** kwargs )","title":"update()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.astriple","text":"Help function converting a triple to rdflib triple. Source code in tripper/backends/rdflib.py def astriple ( triple : \"Triple\" ): \"\"\"Help function converting a triple to rdflib triple.\"\"\" s , p , o = triple return asuri ( s ), asuri ( p ), asuri ( o )","title":"astriple()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.asuri","text":"Help function converting a spo-value to proper rdflib type. Source code in tripper/backends/rdflib.py def asuri ( value : \"Union[None, Literal, str]\" ): \"\"\"Help function converting a spo-value to proper rdflib type.\"\"\" if value is None : return None if isinstance ( value , Literal ): return rdflibLiteral ( value . value , lang = value . lang , datatype = value . datatype ) if value . startswith ( \"_:\" ): return BNode ( value ) return URIRef ( value )","title":"asuri()"},{"location":"api_reference/backends/sparqlwrapper/","text":"sparqlwrapper \u00b6 Backend for SPARQLWrapper SparqlwrapperStrategy \u00b6 Triplestore strategy for SPARQLWrapper. Parameters: Name Type Description Default base_iri str URI of SPARQL endpoint. required kwargs Additional arguments passed to the SPARQLWrapper constructor. {} Source code in tripper/backends/sparqlwrapper.py class SparqlwrapperStrategy : \"\"\"Triplestore strategy for SPARQLWrapper. Arguments: base_iri: URI of SPARQL endpoint. kwargs: Additional arguments passed to the SPARQLWrapper constructor. \"\"\" def __init__ ( self , base_iri : str , ** kwargs ) -> None : kwargs . pop ( \"database\" , None ) # database is not used in the SPARQLWrapper backend self . sparql = SPARQLWrapper ( endpoint = base_iri , ** kwargs ) def triples ( self , triple : \"Triple\" ) -> \"Generator[Triple, None, None]\" : \"\"\"Returns a generator over matching triples.\"\"\" variables = [ f \"? { triple_name } \" for triple_name , triple_value in zip ( \"spo\" , triple ) if triple_value is None ] where_spec = \" \" . join ( f \"? { triple_name } \" if triple_value is None else triple_value if triple_value . startswith ( \"<\" ) else f \"< { triple_value } >\" for triple_name , triple_value in zip ( \"spo\" , triple ) ) query = \" \\n \" . join ( [ f \"SELECT { ' ' . join ( variables ) } WHERE {{ \" , f \" { where_spec } .\" , \"}\" , ] ) self . sparql . setReturnFormat ( JSON ) self . sparql . setMethod ( GET ) self . sparql . setQuery ( query ) ret = self . sparql . queryAndConvert () for binding in ret [ \"results\" ][ \"bindings\" ]: yield tuple ( convert_json_entrydict ( binding [ name ]) if name in binding else value for name , value in zip ( \"spo\" , triple ) ) def add_triples ( self , triples : \"Sequence[Triple]\" ) -> \"QueryResult\" : \"\"\"Add a sequence of triples.\"\"\" spec = \" \\n \" . join ( \" \" + \" \" . join ( value . n3 () if isinstance ( value , Literal ) else value if value . startswith ( \"<\" ) else f \"< { value } >\" for value in triple ) + \" .\" for triple in triples ) query = f \"INSERT DATA {{\\n { spec } \\n}} \" self . sparql . setReturnFormat ( RDFXML ) self . sparql . setMethod ( POST ) self . sparql . setQuery ( query ) return self . sparql . query () def remove ( self , triple : \"Triple\" ) -> \"QueryResult\" : \"\"\"Remove all matching triples from the backend.\"\"\" spec = \" \" . join ( f \"? { name } \" if value is None else value . n3 () if isinstance ( value , Literal ) else value if value . startswith ( \"<\" ) else f \"< { value } >\" for name , value in zip ( \"spo\" , triple ) ) query = f \"DELETE {{ { spec } }} \" self . sparql . setReturnFormat ( RDFXML ) self . sparql . setMethod ( POST ) self . sparql . setQuery ( query ) return self . sparql . query () add_triples ( self , triples ) \u00b6 Add a sequence of triples. Source code in tripper/backends/sparqlwrapper.py def add_triples ( self , triples : \"Sequence[Triple]\" ) -> \"QueryResult\" : \"\"\"Add a sequence of triples.\"\"\" spec = \" \\n \" . join ( \" \" + \" \" . join ( value . n3 () if isinstance ( value , Literal ) else value if value . startswith ( \"<\" ) else f \"< { value } >\" for value in triple ) + \" .\" for triple in triples ) query = f \"INSERT DATA {{\\n { spec } \\n}} \" self . sparql . setReturnFormat ( RDFXML ) self . sparql . setMethod ( POST ) self . sparql . setQuery ( query ) return self . sparql . query () remove ( self , triple ) \u00b6 Remove all matching triples from the backend. Source code in tripper/backends/sparqlwrapper.py def remove ( self , triple : \"Triple\" ) -> \"QueryResult\" : \"\"\"Remove all matching triples from the backend.\"\"\" spec = \" \" . join ( f \"? { name } \" if value is None else value . n3 () if isinstance ( value , Literal ) else value if value . startswith ( \"<\" ) else f \"< { value } >\" for name , value in zip ( \"spo\" , triple ) ) query = f \"DELETE {{ { spec } }} \" self . sparql . setReturnFormat ( RDFXML ) self . sparql . setMethod ( POST ) self . sparql . setQuery ( query ) return self . sparql . query () triples ( self , triple ) \u00b6 Returns a generator over matching triples. Source code in tripper/backends/sparqlwrapper.py def triples ( self , triple : \"Triple\" ) -> \"Generator[Triple, None, None]\" : \"\"\"Returns a generator over matching triples.\"\"\" variables = [ f \"? { triple_name } \" for triple_name , triple_value in zip ( \"spo\" , triple ) if triple_value is None ] where_spec = \" \" . join ( f \"? { triple_name } \" if triple_value is None else triple_value if triple_value . startswith ( \"<\" ) else f \"< { triple_value } >\" for triple_name , triple_value in zip ( \"spo\" , triple ) ) query = \" \\n \" . join ( [ f \"SELECT { ' ' . join ( variables ) } WHERE {{ \" , f \" { where_spec } .\" , \"}\" , ] ) self . sparql . setReturnFormat ( JSON ) self . sparql . setMethod ( GET ) self . sparql . setQuery ( query ) ret = self . sparql . queryAndConvert () for binding in ret [ \"results\" ][ \"bindings\" ]: yield tuple ( convert_json_entrydict ( binding [ name ]) if name in binding else value for name , value in zip ( \"spo\" , triple ) ) convert_json_entrydict ( entrydict ) \u00b6 Convert SPARQLWrapper json entry dict (representing a single IRI or literal) to a tripper type. Source code in tripper/backends/sparqlwrapper.py def convert_json_entrydict ( entrydict : \"Dict[str, str]\" ) -> str : \"\"\"Convert SPARQLWrapper json entry dict (representing a single IRI or literal) to a tripper type.\"\"\" if entrydict [ \"type\" ] == \"uri\" : return entrydict [ \"value\" ] if entrydict [ \"type\" ] == \"literal\" : return Literal ( entrydict [ \"value\" ], lang = entrydict . get ( \"xml:lang\" ), datatype = entrydict . get ( \"datatype\" ), ) if entrydict [ \"type\" ] == \"bnode\" : return ( entrydict [ \"value\" ] if entrydict [ \"value\" ] . startswith ( \"_:\" ) else f \"_: { entrydict [ 'value' ] } \" ) raise ValueError ( f \"unexpected type in entrydict: { entrydict } \" )","title":"sparqlwrapper"},{"location":"api_reference/backends/sparqlwrapper/#sparqlwrapper","text":"Backend for SPARQLWrapper","title":"sparqlwrapper"},{"location":"api_reference/backends/sparqlwrapper/#tripper.backends.sparqlwrapper.SparqlwrapperStrategy","text":"Triplestore strategy for SPARQLWrapper. Parameters: Name Type Description Default base_iri str URI of SPARQL endpoint. required kwargs Additional arguments passed to the SPARQLWrapper constructor. {} Source code in tripper/backends/sparqlwrapper.py class SparqlwrapperStrategy : \"\"\"Triplestore strategy for SPARQLWrapper. Arguments: base_iri: URI of SPARQL endpoint. kwargs: Additional arguments passed to the SPARQLWrapper constructor. \"\"\" def __init__ ( self , base_iri : str , ** kwargs ) -> None : kwargs . pop ( \"database\" , None ) # database is not used in the SPARQLWrapper backend self . sparql = SPARQLWrapper ( endpoint = base_iri , ** kwargs ) def triples ( self , triple : \"Triple\" ) -> \"Generator[Triple, None, None]\" : \"\"\"Returns a generator over matching triples.\"\"\" variables = [ f \"? { triple_name } \" for triple_name , triple_value in zip ( \"spo\" , triple ) if triple_value is None ] where_spec = \" \" . join ( f \"? { triple_name } \" if triple_value is None else triple_value if triple_value . startswith ( \"<\" ) else f \"< { triple_value } >\" for triple_name , triple_value in zip ( \"spo\" , triple ) ) query = \" \\n \" . join ( [ f \"SELECT { ' ' . join ( variables ) } WHERE {{ \" , f \" { where_spec } .\" , \"}\" , ] ) self . sparql . setReturnFormat ( JSON ) self . sparql . setMethod ( GET ) self . sparql . setQuery ( query ) ret = self . sparql . queryAndConvert () for binding in ret [ \"results\" ][ \"bindings\" ]: yield tuple ( convert_json_entrydict ( binding [ name ]) if name in binding else value for name , value in zip ( \"spo\" , triple ) ) def add_triples ( self , triples : \"Sequence[Triple]\" ) -> \"QueryResult\" : \"\"\"Add a sequence of triples.\"\"\" spec = \" \\n \" . join ( \" \" + \" \" . join ( value . n3 () if isinstance ( value , Literal ) else value if value . startswith ( \"<\" ) else f \"< { value } >\" for value in triple ) + \" .\" for triple in triples ) query = f \"INSERT DATA {{\\n { spec } \\n}} \" self . sparql . setReturnFormat ( RDFXML ) self . sparql . setMethod ( POST ) self . sparql . setQuery ( query ) return self . sparql . query () def remove ( self , triple : \"Triple\" ) -> \"QueryResult\" : \"\"\"Remove all matching triples from the backend.\"\"\" spec = \" \" . join ( f \"? { name } \" if value is None else value . n3 () if isinstance ( value , Literal ) else value if value . startswith ( \"<\" ) else f \"< { value } >\" for name , value in zip ( \"spo\" , triple ) ) query = f \"DELETE {{ { spec } }} \" self . sparql . setReturnFormat ( RDFXML ) self . sparql . setMethod ( POST ) self . sparql . setQuery ( query ) return self . sparql . query ()","title":"SparqlwrapperStrategy"},{"location":"api_reference/backends/sparqlwrapper/#tripper.backends.sparqlwrapper.SparqlwrapperStrategy.add_triples","text":"Add a sequence of triples. Source code in tripper/backends/sparqlwrapper.py def add_triples ( self , triples : \"Sequence[Triple]\" ) -> \"QueryResult\" : \"\"\"Add a sequence of triples.\"\"\" spec = \" \\n \" . join ( \" \" + \" \" . join ( value . n3 () if isinstance ( value , Literal ) else value if value . startswith ( \"<\" ) else f \"< { value } >\" for value in triple ) + \" .\" for triple in triples ) query = f \"INSERT DATA {{\\n { spec } \\n}} \" self . sparql . setReturnFormat ( RDFXML ) self . sparql . setMethod ( POST ) self . sparql . setQuery ( query ) return self . sparql . query ()","title":"add_triples()"},{"location":"api_reference/backends/sparqlwrapper/#tripper.backends.sparqlwrapper.SparqlwrapperStrategy.remove","text":"Remove all matching triples from the backend. Source code in tripper/backends/sparqlwrapper.py def remove ( self , triple : \"Triple\" ) -> \"QueryResult\" : \"\"\"Remove all matching triples from the backend.\"\"\" spec = \" \" . join ( f \"? { name } \" if value is None else value . n3 () if isinstance ( value , Literal ) else value if value . startswith ( \"<\" ) else f \"< { value } >\" for name , value in zip ( \"spo\" , triple ) ) query = f \"DELETE {{ { spec } }} \" self . sparql . setReturnFormat ( RDFXML ) self . sparql . setMethod ( POST ) self . sparql . setQuery ( query ) return self . sparql . query ()","title":"remove()"},{"location":"api_reference/backends/sparqlwrapper/#tripper.backends.sparqlwrapper.SparqlwrapperStrategy.triples","text":"Returns a generator over matching triples. Source code in tripper/backends/sparqlwrapper.py def triples ( self , triple : \"Triple\" ) -> \"Generator[Triple, None, None]\" : \"\"\"Returns a generator over matching triples.\"\"\" variables = [ f \"? { triple_name } \" for triple_name , triple_value in zip ( \"spo\" , triple ) if triple_value is None ] where_spec = \" \" . join ( f \"? { triple_name } \" if triple_value is None else triple_value if triple_value . startswith ( \"<\" ) else f \"< { triple_value } >\" for triple_name , triple_value in zip ( \"spo\" , triple ) ) query = \" \\n \" . join ( [ f \"SELECT { ' ' . join ( variables ) } WHERE {{ \" , f \" { where_spec } .\" , \"}\" , ] ) self . sparql . setReturnFormat ( JSON ) self . sparql . setMethod ( GET ) self . sparql . setQuery ( query ) ret = self . sparql . queryAndConvert () for binding in ret [ \"results\" ][ \"bindings\" ]: yield tuple ( convert_json_entrydict ( binding [ name ]) if name in binding else value for name , value in zip ( \"spo\" , triple ) )","title":"triples()"},{"location":"api_reference/backends/sparqlwrapper/#tripper.backends.sparqlwrapper.convert_json_entrydict","text":"Convert SPARQLWrapper json entry dict (representing a single IRI or literal) to a tripper type. Source code in tripper/backends/sparqlwrapper.py def convert_json_entrydict ( entrydict : \"Dict[str, str]\" ) -> str : \"\"\"Convert SPARQLWrapper json entry dict (representing a single IRI or literal) to a tripper type.\"\"\" if entrydict [ \"type\" ] == \"uri\" : return entrydict [ \"value\" ] if entrydict [ \"type\" ] == \"literal\" : return Literal ( entrydict [ \"value\" ], lang = entrydict . get ( \"xml:lang\" ), datatype = entrydict . get ( \"datatype\" ), ) if entrydict [ \"type\" ] == \"bnode\" : return ( entrydict [ \"value\" ] if entrydict [ \"value\" ] . startswith ( \"_:\" ) else f \"_: { entrydict [ 'value' ] } \" ) raise ValueError ( f \"unexpected type in entrydict: { entrydict } \" )","title":"convert_json_entrydict()"},{"location":"api_reference/mappings/mappings/","text":"mappings \u00b6 Implements mappings between entities. Units are currently handled with pint.Quantity. The benefit of this compared to explicit unit conversions, is that units will be handled transparently by mapping functions, without any need to specify units of input and output parameters. Shapes are automatically handled by expressing non-scalar quantities with numpy. AmbiguousMappingError ( MappingError ) \u00b6 A property maps to more than one value. Source code in tripper/mappings/mappings.py class AmbiguousMappingError ( MappingError ): \"\"\"A property maps to more than one value.\"\"\" InconsistentDimensionError ( MappingError ) \u00b6 The size of a dimension is assigned to more than one value. Source code in tripper/mappings/mappings.py class InconsistentDimensionError ( MappingError ): \"\"\"The size of a dimension is assigned to more than one value.\"\"\" InconsistentTriplesError ( MappingError ) \u00b6 Inconsistcy in RDF triples. Source code in tripper/mappings/mappings.py class InconsistentTriplesError ( MappingError ): \"\"\"Inconsistcy in RDF triples.\"\"\" InsufficientMappingError ( MappingError ) \u00b6 There are properties or dimensions that are not mapped. Source code in tripper/mappings/mappings.py class InsufficientMappingError ( MappingError ): \"\"\"There are properties or dimensions that are not mapped.\"\"\" MappingError ( Exception ) \u00b6 Base class for mapping errors. Source code in tripper/mappings/mappings.py class MappingError ( Exception ): \"\"\"Base class for mapping errors.\"\"\" MappingStep \u00b6 A step in a mapping route from a target to one or more sources. A mapping step corresponds to one or more RDF triples. In the simple case of a mo:mapsTo or rdfs:isSubclassOf relation, it is only one triple. For transformations that has several input and output, a set of triples are expected. Parameters: Name Type Description Default output_iri 'Optional[str]' IRI of the output concept. None steptype 'Optional[StepType]' One of the step types from the StepType enum. None function 'Optional[Callable]' Callable that evaluates the output from the input. None cost 'Union[float, Callable]' The cost related to this mapping step. Should be either a float or a callable taking three arguments ( triplestore , input_iris and output_iri ) and return the cost as a float. 1.0 output_unit 'Optional[str]' Output unit. None triplestore 'Optional[Triplestore]' Triplestore instance containing the knowledge base that this mapping step was created from. None The arguments can also be assigned as attributes. Source code in tripper/mappings/mappings.py class MappingStep : \"\"\"A step in a mapping route from a target to one or more sources. A mapping step corresponds to one or more RDF triples. In the simple case of a `mo:mapsTo` or `rdfs:isSubclassOf` relation, it is only one triple. For transformations that has several input and output, a set of triples are expected. Arguments: output_iri: IRI of the output concept. steptype: One of the step types from the StepType enum. function: Callable that evaluates the output from the input. cost: The cost related to this mapping step. Should be either a float or a callable taking three arguments (`triplestore`, `input_iris` and `output_iri`) and return the cost as a float. output_unit: Output unit. triplestore: Triplestore instance containing the knowledge base that this mapping step was created from. The arguments can also be assigned as attributes. \"\"\" # pylint: disable=too-many-instance-attributes def __init__ ( self , output_iri : \"Optional[str]\" = None , steptype : \"Optional[StepType]\" = None , function : \"Optional[Callable]\" = None , cost : \"Union[float, Callable]\" = 1.0 , output_unit : \"Optional[str]\" = None , triplestore : \"Optional[Triplestore]\" = None , ) -> None : self . output_iri = output_iri self . steptype = steptype self . function = function self . cost = cost self . triplestore = triplestore self . output_unit = output_unit self . input_routes : \"List[dict]\" = [] # list of inputs dicts self . join_mode = False # whether to join upcoming input self . joined_input : \"Inputs\" = {} def add_inputs ( self , inputs : \"Inputs\" ) -> None : \"\"\"Add input dict for an input route.\"\"\" assert isinstance ( inputs , dict ) # nosec B101 self . input_routes . append ( inputs ) def add_input ( self , input : \"Input\" , name : \"Optional[str]\" = None ) -> None : \"\"\"Add an input (MappingStep or Value), where `name` is the name assigned to the argument. If the `join_mode` attribute is false, a new route is created with only one input. If the `join_mode` attribute is true, the input is remembered, but first added when join_input() is called. \"\"\" assert isinstance ( input , ( MappingStep , Value )) # nosec B101 argname = name if name else f \"arg { len ( self . joined_input ) + 1 } \" if self . join_mode : self . joined_input [ argname ] = input else : self . add_inputs ({ argname : input }) def join_input ( self ) -> None : \"\"\"Join all input added with add_input() since `join_mode` was set true. Resets `join_mode` to false.\"\"\" if not self . join_mode : raise MappingError ( \"Calling join_input() when join_mode is false.\" ) self . join_mode = False self . add_inputs ( self . joined_input ) self . joined_input = {} def eval ( self , routeno : \"Optional[int]\" = None , unit : \"Optional[str]\" = None , magnitude : bool = False , quantity : \"Type[Quantity]\" = Quantity , ) -> \"Any\" : \"\"\"Returns the evaluated value of given input route number. Arguments: routeno: The route number to evaluate. If None (default) the route with the lowest cost is evalueated. unit: return the result in the given unit. Implies `magnitude=True`. magnitude: Whether to only return the magnitude of the evaluated value (with no unit). quantity: Quantity class to use for evaluation. Defaults to pint. Returns: Evaluation result. \"\"\" if routeno is None : (( _ , routeno ),) = self . lowest_costs ( nresults = 1 ) inputs , idx = self . get_inputs ( routeno ) values = get_values ( inputs , idx , quantity = quantity ) if self . function : value = self . function ( ** values ) elif len ( values ) == 1 : ( value ,) = values . values () else : raise TypeError ( f \"Expected inputs to be a single argument: { values } \" ) if isinstance ( value , quantity ) and unit : return value . m_as ( unit ) if isinstance ( value , quantity ) and magnitude : return value . m return value def get_inputs ( self , routeno : int ) -> \"Tuple[Inputs, int]\" : \"\"\"Returns input and input index `(inputs, idx)` for route number `routeno`. Arguments: routeno: The route number to return inputs for. Returns: Inputs and difference between route number and number of routes for an input dictioary. \"\"\" n = 0 for inputs in self . input_routes : n0 = n n += get_nroutes ( inputs ) if n > routeno : return inputs , routeno - n0 raise ValueError ( f \"routeno= { routeno } exceeds number of routes\" ) def get_input_iris ( self , routeno : int ) -> \"Dict[str, Optional[str]]\" : \"\"\"Returns a dict mapping input names to iris for the given route number. Arguments: routeno: The route number to return a mapping for. Returns: Mapping of input names to IRIs. \"\"\" inputs , _ = self . get_inputs ( routeno ) return { k : v . output_iri if isinstance ( v , MappingStep ) else v . output_iri for k , v in inputs . items () } def number_of_routes ( self ) -> int : \"\"\"Total number of routes to this mapping step. Returns: Total number of routes to this mapping step. \"\"\" n = 0 for inputs in self . input_routes : n += get_nroutes ( inputs ) return n def lowest_costs ( self , nresults : int = 5 ) -> \"List[Tuple[float, int]]\" : \"\"\"Returns a list of `(cost, routeno)` tuples with up to the `nresult` lowest costs and their corresponding route numbers. Arguments: nresults: Number of results to return. Returns: A list of `(cost, routeno)` tuples. \"\"\" result = [] n = 0 # total number of routes # Loop over all toplevel routes leading into this mapping step for inputs in self . input_routes : # For each route, loop over all input arguments of this step # The number of permutations we must consider is the product # of the total number of routes to each input argument. # # We (potentially drastic) limit the possibilities by only # considering the `nresults` routes with lowest costs into # each argument. This gives at maximum # # nresults * number_of_input_arguments # # possibilities. We calculate the costs for all of them and # store them in an array with two columns: `cost` and `routeno`. # The `results` list is extended with the cost array # for each toplevel route leading into this step. base = np . rec . fromrecords ([( 0.0 , 0 )], names = \"cost,routeno\" , formats = \"f8,i8\" ) m = 1 for input in inputs . values (): if isinstance ( input , MappingStep ): nroutes = input . number_of_routes () res = np . rec . fromrecords ( sorted ( input . lowest_costs ( nresults = nresults ), key = lambda x : x [ 1 ], ), # [ # row # for row in sorted( # input.lowest_costs(nresults=nresults), # key=lambda x: x[1], # ) # ], dtype = base . dtype , ) res1 = res . repeat ( len ( base )) base = np . tile ( base , len ( res )) base . cost += res1 . cost base . routeno += res1 . routeno * m m *= nroutes else : base . cost += input . cost # Reduce the length of base (makes probably only sense in # the case self.cost is a callable, but it doesn't hurt...) base . sort () base = base [: nresults ] base . routeno += n n += m # Add the cost for this step to `res`. If `self.cost` is # a callable, we call it with the input for each routeno # as arguments. Otherwise `self.cost` is the cost of this # mapping step. if callable ( self . cost ): for i , rno in enumerate ( base . routeno ): inputs , _ = self . get_inputs ( rno ) input_iris = [ input . output_iri for input in inputs . values ()] owncost = self . cost ( self . triplestore , input_iris , self . output_iri ) base . cost [ i ] += owncost else : owncost = self . cost base . cost += owncost result . extend ( base . tolist ()) # Finally sort the results according to cost and return the # `nresults` rows with lowest cost. return sorted ( result )[: nresults ] def show ( self , routeno : \"Optional[int]\" = None , name : \"Optional[str]\" = None , indent : int = 0 , ) -> str : \"\"\"Returns a string representation of the mapping routes to this step. Arguments: routeno: show given route. The default is to show all routes. name: Name of the last mapping step (mainly for internal use). indent: How of blanks to prepend each line with (mainly for internal use). Returns: String representation of the mapping routes. \"\"\" strings = [] ind = \" \" * indent strings . append ( ind + f ' { name if name else \"Step\" } :' ) strings . append ( ind + f \" steptype: \" f \" { self . steptype . name if self . steptype else None } \" ) strings . append ( ind + f \" output_iri: { self . output_iri } \" ) strings . append ( ind + f \" output_unit: { self . output_unit } \" ) strings . append ( ind + f \" cost: { self . cost } \" ) if routeno is None : strings . append ( ind + \" routes:\" ) for inputs in self . input_routes : t = \" \\n \" . join ( [ input_ . show ( name = name_ , indent = indent + 6 ) for name_ , input_ in inputs . items () ] ) strings . append ( ind + \" - \" + t [ indent + 6 :]) else : strings . append ( ind + \" inputs:\" ) inputs , idx = self . get_inputs ( routeno ) t = \" \\n \" . join ( [ input_ . show ( routeno = idx , name = name_ , indent = indent + 6 ) for name_ , input_ in inputs . items () ] ) strings . append ( ind + \" - \" + t [ indent + 6 :]) return \" \\n \" . join ( strings ) add_input ( self , input , name = None ) \u00b6 Add an input (MappingStep or Value), where name is the name assigned to the argument. If the join_mode attribute is false, a new route is created with only one input. If the join_mode attribute is true, the input is remembered, but first added when join_input() is called. Source code in tripper/mappings/mappings.py def add_input ( self , input : \"Input\" , name : \"Optional[str]\" = None ) -> None : \"\"\"Add an input (MappingStep or Value), where `name` is the name assigned to the argument. If the `join_mode` attribute is false, a new route is created with only one input. If the `join_mode` attribute is true, the input is remembered, but first added when join_input() is called. \"\"\" assert isinstance ( input , ( MappingStep , Value )) # nosec B101 argname = name if name else f \"arg { len ( self . joined_input ) + 1 } \" if self . join_mode : self . joined_input [ argname ] = input else : self . add_inputs ({ argname : input }) add_inputs ( self , inputs ) \u00b6 Add input dict for an input route. Source code in tripper/mappings/mappings.py def add_inputs ( self , inputs : \"Inputs\" ) -> None : \"\"\"Add input dict for an input route.\"\"\" assert isinstance ( inputs , dict ) # nosec B101 self . input_routes . append ( inputs ) eval ( self , routeno = None , unit = None , magnitude = False , quantity =< class ' pint . quantity . Quantity '>) \u00b6 Returns the evaluated value of given input route number. Parameters: Name Type Description Default routeno 'Optional[int]' The route number to evaluate. If None (default) the route with the lowest cost is evalueated. None unit 'Optional[str]' return the result in the given unit. Implies magnitude=True . None magnitude bool Whether to only return the magnitude of the evaluated value (with no unit). False quantity 'Type[Quantity]' Quantity class to use for evaluation. Defaults to pint. <class 'pint.quantity.Quantity'> Returns: Type Description 'Any' Evaluation result. Source code in tripper/mappings/mappings.py def eval ( self , routeno : \"Optional[int]\" = None , unit : \"Optional[str]\" = None , magnitude : bool = False , quantity : \"Type[Quantity]\" = Quantity , ) -> \"Any\" : \"\"\"Returns the evaluated value of given input route number. Arguments: routeno: The route number to evaluate. If None (default) the route with the lowest cost is evalueated. unit: return the result in the given unit. Implies `magnitude=True`. magnitude: Whether to only return the magnitude of the evaluated value (with no unit). quantity: Quantity class to use for evaluation. Defaults to pint. Returns: Evaluation result. \"\"\" if routeno is None : (( _ , routeno ),) = self . lowest_costs ( nresults = 1 ) inputs , idx = self . get_inputs ( routeno ) values = get_values ( inputs , idx , quantity = quantity ) if self . function : value = self . function ( ** values ) elif len ( values ) == 1 : ( value ,) = values . values () else : raise TypeError ( f \"Expected inputs to be a single argument: { values } \" ) if isinstance ( value , quantity ) and unit : return value . m_as ( unit ) if isinstance ( value , quantity ) and magnitude : return value . m return value get_input_iris ( self , routeno ) \u00b6 Returns a dict mapping input names to iris for the given route number. Parameters: Name Type Description Default routeno int The route number to return a mapping for. required Returns: Type Description 'Dict[str, Optional[str]]' Mapping of input names to IRIs. Source code in tripper/mappings/mappings.py def get_input_iris ( self , routeno : int ) -> \"Dict[str, Optional[str]]\" : \"\"\"Returns a dict mapping input names to iris for the given route number. Arguments: routeno: The route number to return a mapping for. Returns: Mapping of input names to IRIs. \"\"\" inputs , _ = self . get_inputs ( routeno ) return { k : v . output_iri if isinstance ( v , MappingStep ) else v . output_iri for k , v in inputs . items () } get_inputs ( self , routeno ) \u00b6 Returns input and input index (inputs, idx) for route number routeno . Parameters: Name Type Description Default routeno int The route number to return inputs for. required Returns: Type Description 'Tuple[Inputs, int]' Inputs and difference between route number and number of routes for an input dictioary. Source code in tripper/mappings/mappings.py def get_inputs ( self , routeno : int ) -> \"Tuple[Inputs, int]\" : \"\"\"Returns input and input index `(inputs, idx)` for route number `routeno`. Arguments: routeno: The route number to return inputs for. Returns: Inputs and difference between route number and number of routes for an input dictioary. \"\"\" n = 0 for inputs in self . input_routes : n0 = n n += get_nroutes ( inputs ) if n > routeno : return inputs , routeno - n0 raise ValueError ( f \"routeno= { routeno } exceeds number of routes\" ) join_input ( self ) \u00b6 Join all input added with add_input() since join_mode was set true. Resets join_mode to false. Source code in tripper/mappings/mappings.py def join_input ( self ) -> None : \"\"\"Join all input added with add_input() since `join_mode` was set true. Resets `join_mode` to false.\"\"\" if not self . join_mode : raise MappingError ( \"Calling join_input() when join_mode is false.\" ) self . join_mode = False self . add_inputs ( self . joined_input ) self . joined_input = {} lowest_costs ( self , nresults = 5 ) \u00b6 Returns a list of (cost, routeno) tuples with up to the nresult lowest costs and their corresponding route numbers. Parameters: Name Type Description Default nresults int Number of results to return. 5 Returns: Type Description 'List[Tuple[float, int]]' A list of (cost, routeno) tuples. Source code in tripper/mappings/mappings.py def lowest_costs ( self , nresults : int = 5 ) -> \"List[Tuple[float, int]]\" : \"\"\"Returns a list of `(cost, routeno)` tuples with up to the `nresult` lowest costs and their corresponding route numbers. Arguments: nresults: Number of results to return. Returns: A list of `(cost, routeno)` tuples. \"\"\" result = [] n = 0 # total number of routes # Loop over all toplevel routes leading into this mapping step for inputs in self . input_routes : # For each route, loop over all input arguments of this step # The number of permutations we must consider is the product # of the total number of routes to each input argument. # # We (potentially drastic) limit the possibilities by only # considering the `nresults` routes with lowest costs into # each argument. This gives at maximum # # nresults * number_of_input_arguments # # possibilities. We calculate the costs for all of them and # store them in an array with two columns: `cost` and `routeno`. # The `results` list is extended with the cost array # for each toplevel route leading into this step. base = np . rec . fromrecords ([( 0.0 , 0 )], names = \"cost,routeno\" , formats = \"f8,i8\" ) m = 1 for input in inputs . values (): if isinstance ( input , MappingStep ): nroutes = input . number_of_routes () res = np . rec . fromrecords ( sorted ( input . lowest_costs ( nresults = nresults ), key = lambda x : x [ 1 ], ), # [ # row # for row in sorted( # input.lowest_costs(nresults=nresults), # key=lambda x: x[1], # ) # ], dtype = base . dtype , ) res1 = res . repeat ( len ( base )) base = np . tile ( base , len ( res )) base . cost += res1 . cost base . routeno += res1 . routeno * m m *= nroutes else : base . cost += input . cost # Reduce the length of base (makes probably only sense in # the case self.cost is a callable, but it doesn't hurt...) base . sort () base = base [: nresults ] base . routeno += n n += m # Add the cost for this step to `res`. If `self.cost` is # a callable, we call it with the input for each routeno # as arguments. Otherwise `self.cost` is the cost of this # mapping step. if callable ( self . cost ): for i , rno in enumerate ( base . routeno ): inputs , _ = self . get_inputs ( rno ) input_iris = [ input . output_iri for input in inputs . values ()] owncost = self . cost ( self . triplestore , input_iris , self . output_iri ) base . cost [ i ] += owncost else : owncost = self . cost base . cost += owncost result . extend ( base . tolist ()) # Finally sort the results according to cost and return the # `nresults` rows with lowest cost. return sorted ( result )[: nresults ] number_of_routes ( self ) \u00b6 Total number of routes to this mapping step. Returns: Type Description int Total number of routes to this mapping step. Source code in tripper/mappings/mappings.py def number_of_routes ( self ) -> int : \"\"\"Total number of routes to this mapping step. Returns: Total number of routes to this mapping step. \"\"\" n = 0 for inputs in self . input_routes : n += get_nroutes ( inputs ) return n show ( self , routeno = None , name = None , indent = 0 ) \u00b6 Returns a string representation of the mapping routes to this step. Parameters: Name Type Description Default routeno 'Optional[int]' show given route. The default is to show all routes. None name 'Optional[str]' Name of the last mapping step (mainly for internal use). None indent int How of blanks to prepend each line with (mainly for internal use). 0 Returns: Type Description str String representation of the mapping routes. Source code in tripper/mappings/mappings.py def show ( self , routeno : \"Optional[int]\" = None , name : \"Optional[str]\" = None , indent : int = 0 , ) -> str : \"\"\"Returns a string representation of the mapping routes to this step. Arguments: routeno: show given route. The default is to show all routes. name: Name of the last mapping step (mainly for internal use). indent: How of blanks to prepend each line with (mainly for internal use). Returns: String representation of the mapping routes. \"\"\" strings = [] ind = \" \" * indent strings . append ( ind + f ' { name if name else \"Step\" } :' ) strings . append ( ind + f \" steptype: \" f \" { self . steptype . name if self . steptype else None } \" ) strings . append ( ind + f \" output_iri: { self . output_iri } \" ) strings . append ( ind + f \" output_unit: { self . output_unit } \" ) strings . append ( ind + f \" cost: { self . cost } \" ) if routeno is None : strings . append ( ind + \" routes:\" ) for inputs in self . input_routes : t = \" \\n \" . join ( [ input_ . show ( name = name_ , indent = indent + 6 ) for name_ , input_ in inputs . items () ] ) strings . append ( ind + \" - \" + t [ indent + 6 :]) else : strings . append ( ind + \" inputs:\" ) inputs , idx = self . get_inputs ( routeno ) t = \" \\n \" . join ( [ input_ . show ( routeno = idx , name = name_ , indent = indent + 6 ) for name_ , input_ in inputs . items () ] ) strings . append ( ind + \" - \" + t [ indent + 6 :]) return \" \\n \" . join ( strings ) MissingRelationError ( MappingError ) \u00b6 There are missing relations in RDF triples. Source code in tripper/mappings/mappings.py class MissingRelationError ( MappingError ): \"\"\"There are missing relations in RDF triples.\"\"\" StepType ( Enum ) \u00b6 Type of mapping step when going from the output to the inputs. Source code in tripper/mappings/mappings.py class StepType ( Enum ): \"\"\"Type of mapping step when going from the output to the inputs.\"\"\" MAPSTO = 1 INV_MAPSTO = - 1 INSTANCEOF = 2 INV_INSTANCEOF = - 2 SUBCLASSOF = 3 INV_SUBCLASSOF = - 3 FUNCTION = 4 Value \u00b6 Represents the value of an instance property. Parameters: Name Type Description Default value 'Any' Property value. None unit 'Optional[str]' Property unit. None iri 'Optional[str]' IRI of ontological concept that this value is an instance of. None property_iri 'Optional[str]' IRI of datamodel property that this value is an instance of. None cost 'Union[float, Callable]' Cost of accessing this value. 0.0 Source code in tripper/mappings/mappings.py class Value : \"\"\"Represents the value of an instance property. Arguments: value: Property value. unit: Property unit. iri: IRI of ontological concept that this value is an instance of. property_iri: IRI of datamodel property that this value is an instance of. cost: Cost of accessing this value. \"\"\" # pylint: disable=too-few-public-methods def __init__ ( self , value : \"Any\" = None , unit : \"Optional[str]\" = None , iri : \"Optional[str]\" = None , property_iri : \"Optional[str]\" = None , cost : \"Union[float, Callable]\" = 0.0 , ): self . value = value self . unit = unit self . output_iri = iri self . property_iri = property_iri self . cost = cost def show ( self , routeno : \"Optional[int]\" = None , name : \"Optional[str]\" = None , indent : int = 0 , ) -> str : # pylint: disable=unused-argument \"\"\"Returns a string representation of the Value. Arguments: routeno: Unused. The argument exists for consistency with the corresponding method in Step. name: Name of value. indent: Indentation level. Returns: String representation of the value. \"\"\" strings = [] ind = \" \" * indent strings . append ( ind + f ' { name if name else \"Value\" } :' ) strings . append ( ind + f \" iri: { self . output_iri } \" ) strings . append ( ind + f \" property_iri: { self . property_iri } \" ) strings . append ( ind + f \" unit: { self . unit } \" ) strings . append ( ind + f \" cost: { self . cost } \" ) strings . append ( ind + f \" value: { self . value } \" ) return \" \\n \" . join ( strings ) show ( self , routeno = None , name = None , indent = 0 ) \u00b6 Returns a string representation of the Value. Parameters: Name Type Description Default routeno 'Optional[int]' Unused. The argument exists for consistency with the corresponding method in Step. None name 'Optional[str]' Name of value. None indent int Indentation level. 0 Returns: Type Description str String representation of the value. Source code in tripper/mappings/mappings.py def show ( self , routeno : \"Optional[int]\" = None , name : \"Optional[str]\" = None , indent : int = 0 , ) -> str : # pylint: disable=unused-argument \"\"\"Returns a string representation of the Value. Arguments: routeno: Unused. The argument exists for consistency with the corresponding method in Step. name: Name of value. indent: Indentation level. Returns: String representation of the value. \"\"\" strings = [] ind = \" \" * indent strings . append ( ind + f ' { name if name else \"Value\" } :' ) strings . append ( ind + f \" iri: { self . output_iri } \" ) strings . append ( ind + f \" property_iri: { self . property_iri } \" ) strings . append ( ind + f \" unit: { self . unit } \" ) strings . append ( ind + f \" cost: { self . cost } \" ) strings . append ( ind + f \" value: { self . value } \" ) return \" \\n \" . join ( strings ) emmo_mapper ( triplestore ) \u00b6 Finds all function definitions in triplestore based on EMMO. Return a dict mapping output IRIs to a list of (function_iri, [input_iris, ...]) tuples. Source code in tripper/mappings/mappings.py def emmo_mapper ( triplestore : \"Triplestore\" ) -> \"Dict[str, list]\" : \"\"\"Finds all function definitions in `triplestore` based on EMMO. Return a dict mapping output IRIs to a list of (function_iri, [input_iris, ...]) tuples. \"\"\" Task = EMMO . EMMO_4299e344_a321_4ef2_a744_bacfcce80afc hasInput = EMMO . EMMO_36e69413_8c59_4799_946c_10b05d266e22 hasOutput = EMMO . EMMO_c4bace1d_4db0_4cd3_87e9_18122bae2840 d = defaultdict ( list ) for task in triplestore . subjects ( RDF . type , Task ): inputs = list ( triplestore . objects ( task , hasInput )) for output in triplestore . objects ( task , hasOutput ): d [ output ] . append (( task , inputs )) return d fno_mapper ( triplestore ) \u00b6 Finds all function definitions in triplestore based on the function ontololy (FNO). Parameters: Name Type Description Default triplestore 'Triplestore' The triplestore to investigate. required Returns: Type Description 'Dict[str, list]' A mapping of output IRIs to a list of (function_iri, [input_iris, ...]) tuples. Source code in tripper/mappings/mappings.py def fno_mapper ( triplestore : \"Triplestore\" ) -> \"Dict[str, list]\" : \"\"\"Finds all function definitions in `triplestore` based on the function ontololy (FNO). Arguments: triplestore: The triplestore to investigate. Returns: A mapping of output IRIs to a list of `(function_iri, [input_iris, ...])` tuples. \"\"\" # pylint: disable=too-many-branches # Temporary dicts for fast lookup Dfirst = dict ( triplestore . subject_objects ( RDF . first )) Drest = dict ( triplestore . subject_objects ( RDF . rest )) Dexpects = defaultdict ( list ) Dreturns = defaultdict ( list ) for s , o in triplestore . subject_objects ( FNO . expects ): Dexpects [ s ] . append ( o ) for s , o in triplestore . subject_objects ( FNO . returns ): Dreturns [ s ] . append ( o ) d = defaultdict ( list ) for func , lst in Dreturns . items (): input_iris = [] for exp in Dexpects . get ( func , ()): if exp in Dfirst : while exp in Dfirst : input_iris . append ( Dfirst [ exp ]) if exp not in Drest : break exp = Drest [ exp ] else : # Support also misuse of FNO, where fno:expects refers # directly to input individuals input_iris . append ( exp ) for ret in lst : if ret in Dfirst : while ret in Dfirst : d [ Dfirst [ ret ]] . append (( func , input_iris )) if ret not in Drest : break ret = Drest [ ret ] else : # Support also misuse of FNO, where fno:returns refers # directly to the returned individual d [ ret ] . append (( func , input_iris )) return d get_nroutes ( inputs ) \u00b6 Help function returning the number of routes for an input dict. Parameters: Name Type Description Default inputs 'Inputs' Input dictionary. required Returns: Type Description int Number of routes in the inputs input dictionary. Source code in tripper/mappings/mappings.py def get_nroutes ( inputs : \"Inputs\" ) -> int : \"\"\"Help function returning the number of routes for an input dict. Arguments: inputs: Input dictionary. Returns: Number of routes in the `inputs` input dictionary. \"\"\" nroutes = 1 for input in inputs . values (): if isinstance ( input , MappingStep ): nroutes *= input . number_of_routes () return nroutes get_values ( inputs , routeno , quantity =< class ' pint . quantity . Quantity '>, magnitudes=False) \u00b6 Help function returning a dict mapping the input names to actual value of expected input unit. There exists get_nroutes(inputs) routes to populate inputs . routeno is the index of the specific route we will use to obtain the values. Parameters: Name Type Description Default inputs 'dict[str, Any]' Input dictionary. required routeno int Route number index. required quantity 'Type[Quantity]' A unit quantity class. <class 'pint.quantity.Quantity'> magnitudes bool Whether to only return the magnitude of the evaluated value (with no unit). False Returns: Type Description 'dict[str, Any]' A mapping between input names and values of expected input unit. Source code in tripper/mappings/mappings.py def get_values ( inputs : \"dict[str, Any]\" , routeno : int , quantity : \"Type[Quantity]\" = Quantity , magnitudes : bool = False , ) -> \"dict[str, Any]\" : \"\"\"Help function returning a dict mapping the input names to actual value of expected input unit. There exists `get_nroutes(inputs)` routes to populate `inputs`. `routeno` is the index of the specific route we will use to obtain the values. Arguments: inputs: Input dictionary. routeno: Route number index. quantity: A unit quantity class. magnitudes: Whether to only return the magnitude of the evaluated value (with no unit). Returns: A mapping between input names and values of expected input unit. \"\"\" values = {} for k , v in inputs . items (): if isinstance ( v , MappingStep ): value = v . eval ( routeno = routeno , quantity = quantity ) values [ k ] = ( value . to ( v . output_unit ) if v . output_unit and isinstance ( v , quantity ) else value ) elif isinstance ( v , Value ): values [ k ] = quantity ( v . value , v . unit ) else : raise TypeError ( \"Expected values in inputs to be either `MappingStep` or \" \"`Value` objects.\" ) if magnitudes : values = { k : v . m if isinstance ( v , quantity ) else v for k , v in values . items () } return values mapping_routes ( target , sources , triplestore , function_repo = None , function_mappers = ( < function fno_mapper at 0x7f77c9176680 > ,), default_costs = (( 'function' , 10.0 ), ( 'mapsTo' , 2.0 ), ( 'instanceOf' , 1.0 ), ( 'subClassOf' , 1.0 ), ( 'value' , 0.0 )), mapsTo = 'http://emmo.info/domain-mappings#mapsTo' , instanceOf = 'http://emmo.info/datamodel#instanceOf' , subClassOf = 'http://www.w3.org/2000/01/rdf-schema#subClassOf' , label = 'http://www.w3.org/2000/01/rdf-schema#label' , hasUnit = 'http://emmo.info/datamodel#hasUnit' , hasCost = 'http://emmo.info/datamodel#hasCost' ) \u00b6 Find routes of mappings from any source in sources to target . This implementation supports functions (using FnO) and subclass relations. It also correctly handles transitivity of mapsTo and subClassOf relations. Parameters: Name Type Description Default target str IRI of the target in triplestore . required sources 'Dict[str, Value]' Dict mapping source IRIs to source values or a sequence of source IRIs (with no explicit values). required triplestore 'Triplestore' Triplestore instance. It is safe to pass a generator expression too. required Additional arguments for fine-grained tuning: !!! function_repo \"Dict mapping function IRIs to corresponding Python\" function. Default is to use triplestore.function_repo . !!! function_mappers \"Sequence of mapping functions that takes\" triplestore as argument and return a dict mapping output IRIs to a list of (function_iri, [input_iris, ...]) tuples. !!! default_costs \"A dict providing default costs of different types\" of mapping steps (\"function\", \"mapsTo\", \"instanceOf\", \"subclassOf\", and \"value\"). These costs can be overridden with 'hasCost' relations in the ontology. mapsTo: IRI of 'mapsTo' in triplestore . instanceOf: IRI of 'instanceOf' in triplestore . !!! subclassof \"IRI of 'subClassOf' in triples . Set it to None if\" subclasses should not be considered. !!! label \"IRI of 'label' in triplestore . Used for naming function\" input parameters. The default is to use rdfs:label. !!! hasunit \"IRI of 'hasUnit' in triples . Can be used to explicit\" specify the unit of a quantity. !!! hascost \"IRI of 'hasCost' in triples . Used for associating a\" user-defined cost or cost function with instantiation of a property. Returns: Type Description Input A MappingStep instance. This is a root of a nested tree of MappingStep instances providing an (efficient) internal description of all possible mapping routes from sources to target . Source code in tripper/mappings/mappings.py def mapping_routes ( target : str , sources : \"Dict[str, Value]\" , triplestore : \"Triplestore\" , function_repo : \"Optional[dict]\" = None , function_mappers : \"Sequence[Callable]\" = ( fno_mapper ,), default_costs : \"Tuple\" = ( ( \"function\" , 10.0 ), ( \"mapsTo\" , 2.0 ), ( \"instanceOf\" , 1.0 ), ( \"subClassOf\" , 1.0 ), ( \"value\" , 0.0 ), ), mapsTo : str = MAP . mapsTo , instanceOf : str = DM . instanceOf , subClassOf : str = RDFS . subClassOf , # description: str = DCTERMS.description, label : str = RDFS . label , hasUnit : str = DM . hasUnit , hasCost : str = DM . hasCost , # TODO - add hasCost to the DM ontology ) -> Input : \"\"\"Find routes of mappings from any source in `sources` to `target`. This implementation supports functions (using FnO) and subclass relations. It also correctly handles transitivity of `mapsTo` and `subClassOf` relations. Arguments: target: IRI of the target in `triplestore`. sources: Dict mapping source IRIs to source values or a sequence of source IRIs (with no explicit values). triplestore: Triplestore instance. It is safe to pass a generator expression too. Additional arguments for fine-grained tuning: function_repo: Dict mapping function IRIs to corresponding Python function. Default is to use `triplestore.function_repo`. function_mappers: Sequence of mapping functions that takes `triplestore` as argument and return a dict mapping output IRIs to a list of `(function_iri, [input_iris, ...])` tuples. default_costs: A dict providing default costs of different types of mapping steps (\"function\", \"mapsTo\", \"instanceOf\", \"subclassOf\", and \"value\"). These costs can be overridden with 'hasCost' relations in the ontology. mapsTo: IRI of 'mapsTo' in `triplestore`. instanceOf: IRI of 'instanceOf' in `triplestore`. subClassOf: IRI of 'subClassOf' in `triples`. Set it to None if subclasses should not be considered. label: IRI of 'label' in `triplestore`. Used for naming function input parameters. The default is to use rdfs:label. hasUnit: IRI of 'hasUnit' in `triples`. Can be used to explicit specify the unit of a quantity. hasCost: IRI of 'hasCost' in `triples`. Used for associating a user-defined cost or cost function with instantiation of a property. Returns: A MappingStep instance. This is a root of a nested tree of MappingStep instances providing an (efficient) internal description of all possible mapping routes from `sources` to `target`. \"\"\" # pylint: disable=too-many-arguments,too-many-locals,too-many-statements if target in sources : return Value ( iri = target ) if isinstance ( sources , Sequence ): sources = { iri : None for iri in sources } if function_repo is None : function_repo = triplestore . function_repo default_costs = dict ( default_costs ) # Create lookup tables for fast access to triplestore content soMaps = defaultdict ( list ) # (s, mapsTo, o) ==> soMaps[s] -> [o, ..] osMaps = defaultdict ( list ) # (o, mapsTo, s) ==> osMaps[o] -> [s, ..] osSubcl = defaultdict ( list ) # (o, subClassOf, s) ==> osSubcl[o] -> [s, ..] soInst = {} # (s, instanceOf, o) ==> soInst[s] -> o osInst = defaultdict ( list ) # (o, instanceOf, s) ==> osInst[o] -> [s, ..] for s , o in triplestore . subject_objects ( mapsTo ): soMaps [ s ] . append ( o ) osMaps [ o ] . append ( s ) for s , o in triplestore . subject_objects ( subClassOf ): osSubcl [ o ] . append ( s ) for s , o in triplestore . subject_objects ( instanceOf ): if s in soInst : raise InconsistentTriplesError ( f \"The same individual can only relate to one datamodel \" f \"property via { instanceOf } relations.\" ) soInst [ s ] = o osInst [ o ] . append ( s ) soName = dict ( triplestore . subject_objects ( label )) soUnit = dict ( triplestore . subject_objects ( hasUnit )) soCost = dict ( triplestore . subject_objects ( hasCost )) def getcost ( target , stepname ): \"\"\"Returns the cost assigned to IRI `target` for a mapping step of type `stepname`.\"\"\" cost = soCost . get ( target , default_costs [ stepname ]) if cost is None : return None return ( function_repo [ cost ] if cost in function_repo else float ( parse_literal ( cost )) ) def walk ( target , visited , step ): \"\"\"Walk backward in rdf graph from `node` to sources.\"\"\" if target in visited : return visited . add ( target ) def addnode ( node , steptype , stepname ): if node in visited : return step . steptype = steptype step . cost = getcost ( target , stepname ) if node in sources : value = Value ( value = sources [ node ], unit = soUnit . get ( node ), iri = node , property_iri = soInst . get ( node ), cost = getcost ( node , \"value\" ), ) step . add_input ( value , name = soName . get ( node )) else : prevstep = MappingStep ( output_iri = node , output_unit = soUnit . get ( node ), triplestore = triplestore , ) step . add_input ( prevstep , name = soName . get ( node )) walk ( node , visited , prevstep ) for node in osInst [ target ]: addnode ( node , StepType . INV_INSTANCEOF , \"instanceOf\" ) for node in soMaps [ target ]: addnode ( node , StepType . MAPSTO , \"mapsTo\" ) for node in osMaps [ target ]: addnode ( node , StepType . INV_MAPSTO , \"mapsTo\" ) for node in osSubcl [ target ]: addnode ( node , StepType . INV_SUBCLASSOF , \"subClassOf\" ) for fmap in function_mappers : for func , input_iris in fmap ( triplestore )[ target ]: step . steptype = StepType . FUNCTION step . cost = getcost ( func , \"function\" ) step . function = function_repo . get ( func ) step . join_mode = True for input_iri in input_iris : step0 = MappingStep ( output_iri = input_iri , output_unit = soUnit . get ( input_iri ), triplestore = triplestore , ) step . add_input ( step0 , name = soName . get ( input_iri )) walk ( input_iri , visited , step0 ) step . join_input () visited = set () step = MappingStep ( output_iri = target , output_unit = soUnit . get ( target ), triplestore = triplestore , ) if target in soInst : # It is only initially we want to follow instanceOf in forward # direction. Later on we will only follow mapsTo and instanceOf in # backward direction. visited . add ( target ) # do we really wan't this? Yes, I think so... source = soInst [ target ] step . steptype = StepType . INSTANCEOF step . cost = getcost ( source , \"instanceOf\" ) step0 = MappingStep ( output_iri = source , output_unit = soUnit . get ( source ), triplestore = triplestore , ) step . add_input ( step0 , name = soName . get ( target )) step = step0 target = source if target not in soMaps : raise MissingRelationError ( f 'Missing \"mapsTo\" relation on: { target } ' ) walk ( target , visited , step ) return step","title":"mappings"},{"location":"api_reference/mappings/mappings/#mappings","text":"Implements mappings between entities. Units are currently handled with pint.Quantity. The benefit of this compared to explicit unit conversions, is that units will be handled transparently by mapping functions, without any need to specify units of input and output parameters. Shapes are automatically handled by expressing non-scalar quantities with numpy.","title":"mappings"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.AmbiguousMappingError","text":"A property maps to more than one value. Source code in tripper/mappings/mappings.py class AmbiguousMappingError ( MappingError ): \"\"\"A property maps to more than one value.\"\"\"","title":"AmbiguousMappingError"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.InconsistentDimensionError","text":"The size of a dimension is assigned to more than one value. Source code in tripper/mappings/mappings.py class InconsistentDimensionError ( MappingError ): \"\"\"The size of a dimension is assigned to more than one value.\"\"\"","title":"InconsistentDimensionError"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.InconsistentTriplesError","text":"Inconsistcy in RDF triples. Source code in tripper/mappings/mappings.py class InconsistentTriplesError ( MappingError ): \"\"\"Inconsistcy in RDF triples.\"\"\"","title":"InconsistentTriplesError"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.InsufficientMappingError","text":"There are properties or dimensions that are not mapped. Source code in tripper/mappings/mappings.py class InsufficientMappingError ( MappingError ): \"\"\"There are properties or dimensions that are not mapped.\"\"\"","title":"InsufficientMappingError"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingError","text":"Base class for mapping errors. Source code in tripper/mappings/mappings.py class MappingError ( Exception ): \"\"\"Base class for mapping errors.\"\"\"","title":"MappingError"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep","text":"A step in a mapping route from a target to one or more sources. A mapping step corresponds to one or more RDF triples. In the simple case of a mo:mapsTo or rdfs:isSubclassOf relation, it is only one triple. For transformations that has several input and output, a set of triples are expected. Parameters: Name Type Description Default output_iri 'Optional[str]' IRI of the output concept. None steptype 'Optional[StepType]' One of the step types from the StepType enum. None function 'Optional[Callable]' Callable that evaluates the output from the input. None cost 'Union[float, Callable]' The cost related to this mapping step. Should be either a float or a callable taking three arguments ( triplestore , input_iris and output_iri ) and return the cost as a float. 1.0 output_unit 'Optional[str]' Output unit. None triplestore 'Optional[Triplestore]' Triplestore instance containing the knowledge base that this mapping step was created from. None The arguments can also be assigned as attributes. Source code in tripper/mappings/mappings.py class MappingStep : \"\"\"A step in a mapping route from a target to one or more sources. A mapping step corresponds to one or more RDF triples. In the simple case of a `mo:mapsTo` or `rdfs:isSubclassOf` relation, it is only one triple. For transformations that has several input and output, a set of triples are expected. Arguments: output_iri: IRI of the output concept. steptype: One of the step types from the StepType enum. function: Callable that evaluates the output from the input. cost: The cost related to this mapping step. Should be either a float or a callable taking three arguments (`triplestore`, `input_iris` and `output_iri`) and return the cost as a float. output_unit: Output unit. triplestore: Triplestore instance containing the knowledge base that this mapping step was created from. The arguments can also be assigned as attributes. \"\"\" # pylint: disable=too-many-instance-attributes def __init__ ( self , output_iri : \"Optional[str]\" = None , steptype : \"Optional[StepType]\" = None , function : \"Optional[Callable]\" = None , cost : \"Union[float, Callable]\" = 1.0 , output_unit : \"Optional[str]\" = None , triplestore : \"Optional[Triplestore]\" = None , ) -> None : self . output_iri = output_iri self . steptype = steptype self . function = function self . cost = cost self . triplestore = triplestore self . output_unit = output_unit self . input_routes : \"List[dict]\" = [] # list of inputs dicts self . join_mode = False # whether to join upcoming input self . joined_input : \"Inputs\" = {} def add_inputs ( self , inputs : \"Inputs\" ) -> None : \"\"\"Add input dict for an input route.\"\"\" assert isinstance ( inputs , dict ) # nosec B101 self . input_routes . append ( inputs ) def add_input ( self , input : \"Input\" , name : \"Optional[str]\" = None ) -> None : \"\"\"Add an input (MappingStep or Value), where `name` is the name assigned to the argument. If the `join_mode` attribute is false, a new route is created with only one input. If the `join_mode` attribute is true, the input is remembered, but first added when join_input() is called. \"\"\" assert isinstance ( input , ( MappingStep , Value )) # nosec B101 argname = name if name else f \"arg { len ( self . joined_input ) + 1 } \" if self . join_mode : self . joined_input [ argname ] = input else : self . add_inputs ({ argname : input }) def join_input ( self ) -> None : \"\"\"Join all input added with add_input() since `join_mode` was set true. Resets `join_mode` to false.\"\"\" if not self . join_mode : raise MappingError ( \"Calling join_input() when join_mode is false.\" ) self . join_mode = False self . add_inputs ( self . joined_input ) self . joined_input = {} def eval ( self , routeno : \"Optional[int]\" = None , unit : \"Optional[str]\" = None , magnitude : bool = False , quantity : \"Type[Quantity]\" = Quantity , ) -> \"Any\" : \"\"\"Returns the evaluated value of given input route number. Arguments: routeno: The route number to evaluate. If None (default) the route with the lowest cost is evalueated. unit: return the result in the given unit. Implies `magnitude=True`. magnitude: Whether to only return the magnitude of the evaluated value (with no unit). quantity: Quantity class to use for evaluation. Defaults to pint. Returns: Evaluation result. \"\"\" if routeno is None : (( _ , routeno ),) = self . lowest_costs ( nresults = 1 ) inputs , idx = self . get_inputs ( routeno ) values = get_values ( inputs , idx , quantity = quantity ) if self . function : value = self . function ( ** values ) elif len ( values ) == 1 : ( value ,) = values . values () else : raise TypeError ( f \"Expected inputs to be a single argument: { values } \" ) if isinstance ( value , quantity ) and unit : return value . m_as ( unit ) if isinstance ( value , quantity ) and magnitude : return value . m return value def get_inputs ( self , routeno : int ) -> \"Tuple[Inputs, int]\" : \"\"\"Returns input and input index `(inputs, idx)` for route number `routeno`. Arguments: routeno: The route number to return inputs for. Returns: Inputs and difference between route number and number of routes for an input dictioary. \"\"\" n = 0 for inputs in self . input_routes : n0 = n n += get_nroutes ( inputs ) if n > routeno : return inputs , routeno - n0 raise ValueError ( f \"routeno= { routeno } exceeds number of routes\" ) def get_input_iris ( self , routeno : int ) -> \"Dict[str, Optional[str]]\" : \"\"\"Returns a dict mapping input names to iris for the given route number. Arguments: routeno: The route number to return a mapping for. Returns: Mapping of input names to IRIs. \"\"\" inputs , _ = self . get_inputs ( routeno ) return { k : v . output_iri if isinstance ( v , MappingStep ) else v . output_iri for k , v in inputs . items () } def number_of_routes ( self ) -> int : \"\"\"Total number of routes to this mapping step. Returns: Total number of routes to this mapping step. \"\"\" n = 0 for inputs in self . input_routes : n += get_nroutes ( inputs ) return n def lowest_costs ( self , nresults : int = 5 ) -> \"List[Tuple[float, int]]\" : \"\"\"Returns a list of `(cost, routeno)` tuples with up to the `nresult` lowest costs and their corresponding route numbers. Arguments: nresults: Number of results to return. Returns: A list of `(cost, routeno)` tuples. \"\"\" result = [] n = 0 # total number of routes # Loop over all toplevel routes leading into this mapping step for inputs in self . input_routes : # For each route, loop over all input arguments of this step # The number of permutations we must consider is the product # of the total number of routes to each input argument. # # We (potentially drastic) limit the possibilities by only # considering the `nresults` routes with lowest costs into # each argument. This gives at maximum # # nresults * number_of_input_arguments # # possibilities. We calculate the costs for all of them and # store them in an array with two columns: `cost` and `routeno`. # The `results` list is extended with the cost array # for each toplevel route leading into this step. base = np . rec . fromrecords ([( 0.0 , 0 )], names = \"cost,routeno\" , formats = \"f8,i8\" ) m = 1 for input in inputs . values (): if isinstance ( input , MappingStep ): nroutes = input . number_of_routes () res = np . rec . fromrecords ( sorted ( input . lowest_costs ( nresults = nresults ), key = lambda x : x [ 1 ], ), # [ # row # for row in sorted( # input.lowest_costs(nresults=nresults), # key=lambda x: x[1], # ) # ], dtype = base . dtype , ) res1 = res . repeat ( len ( base )) base = np . tile ( base , len ( res )) base . cost += res1 . cost base . routeno += res1 . routeno * m m *= nroutes else : base . cost += input . cost # Reduce the length of base (makes probably only sense in # the case self.cost is a callable, but it doesn't hurt...) base . sort () base = base [: nresults ] base . routeno += n n += m # Add the cost for this step to `res`. If `self.cost` is # a callable, we call it with the input for each routeno # as arguments. Otherwise `self.cost` is the cost of this # mapping step. if callable ( self . cost ): for i , rno in enumerate ( base . routeno ): inputs , _ = self . get_inputs ( rno ) input_iris = [ input . output_iri for input in inputs . values ()] owncost = self . cost ( self . triplestore , input_iris , self . output_iri ) base . cost [ i ] += owncost else : owncost = self . cost base . cost += owncost result . extend ( base . tolist ()) # Finally sort the results according to cost and return the # `nresults` rows with lowest cost. return sorted ( result )[: nresults ] def show ( self , routeno : \"Optional[int]\" = None , name : \"Optional[str]\" = None , indent : int = 0 , ) -> str : \"\"\"Returns a string representation of the mapping routes to this step. Arguments: routeno: show given route. The default is to show all routes. name: Name of the last mapping step (mainly for internal use). indent: How of blanks to prepend each line with (mainly for internal use). Returns: String representation of the mapping routes. \"\"\" strings = [] ind = \" \" * indent strings . append ( ind + f ' { name if name else \"Step\" } :' ) strings . append ( ind + f \" steptype: \" f \" { self . steptype . name if self . steptype else None } \" ) strings . append ( ind + f \" output_iri: { self . output_iri } \" ) strings . append ( ind + f \" output_unit: { self . output_unit } \" ) strings . append ( ind + f \" cost: { self . cost } \" ) if routeno is None : strings . append ( ind + \" routes:\" ) for inputs in self . input_routes : t = \" \\n \" . join ( [ input_ . show ( name = name_ , indent = indent + 6 ) for name_ , input_ in inputs . items () ] ) strings . append ( ind + \" - \" + t [ indent + 6 :]) else : strings . append ( ind + \" inputs:\" ) inputs , idx = self . get_inputs ( routeno ) t = \" \\n \" . join ( [ input_ . show ( routeno = idx , name = name_ , indent = indent + 6 ) for name_ , input_ in inputs . items () ] ) strings . append ( ind + \" - \" + t [ indent + 6 :]) return \" \\n \" . join ( strings )","title":"MappingStep"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep.add_input","text":"Add an input (MappingStep or Value), where name is the name assigned to the argument. If the join_mode attribute is false, a new route is created with only one input. If the join_mode attribute is true, the input is remembered, but first added when join_input() is called. Source code in tripper/mappings/mappings.py def add_input ( self , input : \"Input\" , name : \"Optional[str]\" = None ) -> None : \"\"\"Add an input (MappingStep or Value), where `name` is the name assigned to the argument. If the `join_mode` attribute is false, a new route is created with only one input. If the `join_mode` attribute is true, the input is remembered, but first added when join_input() is called. \"\"\" assert isinstance ( input , ( MappingStep , Value )) # nosec B101 argname = name if name else f \"arg { len ( self . joined_input ) + 1 } \" if self . join_mode : self . joined_input [ argname ] = input else : self . add_inputs ({ argname : input })","title":"add_input()"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep.add_inputs","text":"Add input dict for an input route. Source code in tripper/mappings/mappings.py def add_inputs ( self , inputs : \"Inputs\" ) -> None : \"\"\"Add input dict for an input route.\"\"\" assert isinstance ( inputs , dict ) # nosec B101 self . input_routes . append ( inputs )","title":"add_inputs()"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep.eval","text":"Returns the evaluated value of given input route number. Parameters: Name Type Description Default routeno 'Optional[int]' The route number to evaluate. If None (default) the route with the lowest cost is evalueated. None unit 'Optional[str]' return the result in the given unit. Implies magnitude=True . None magnitude bool Whether to only return the magnitude of the evaluated value (with no unit). False quantity 'Type[Quantity]' Quantity class to use for evaluation. Defaults to pint. <class 'pint.quantity.Quantity'> Returns: Type Description 'Any' Evaluation result. Source code in tripper/mappings/mappings.py def eval ( self , routeno : \"Optional[int]\" = None , unit : \"Optional[str]\" = None , magnitude : bool = False , quantity : \"Type[Quantity]\" = Quantity , ) -> \"Any\" : \"\"\"Returns the evaluated value of given input route number. Arguments: routeno: The route number to evaluate. If None (default) the route with the lowest cost is evalueated. unit: return the result in the given unit. Implies `magnitude=True`. magnitude: Whether to only return the magnitude of the evaluated value (with no unit). quantity: Quantity class to use for evaluation. Defaults to pint. Returns: Evaluation result. \"\"\" if routeno is None : (( _ , routeno ),) = self . lowest_costs ( nresults = 1 ) inputs , idx = self . get_inputs ( routeno ) values = get_values ( inputs , idx , quantity = quantity ) if self . function : value = self . function ( ** values ) elif len ( values ) == 1 : ( value ,) = values . values () else : raise TypeError ( f \"Expected inputs to be a single argument: { values } \" ) if isinstance ( value , quantity ) and unit : return value . m_as ( unit ) if isinstance ( value , quantity ) and magnitude : return value . m return value","title":"eval()"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep.get_input_iris","text":"Returns a dict mapping input names to iris for the given route number. Parameters: Name Type Description Default routeno int The route number to return a mapping for. required Returns: Type Description 'Dict[str, Optional[str]]' Mapping of input names to IRIs. Source code in tripper/mappings/mappings.py def get_input_iris ( self , routeno : int ) -> \"Dict[str, Optional[str]]\" : \"\"\"Returns a dict mapping input names to iris for the given route number. Arguments: routeno: The route number to return a mapping for. Returns: Mapping of input names to IRIs. \"\"\" inputs , _ = self . get_inputs ( routeno ) return { k : v . output_iri if isinstance ( v , MappingStep ) else v . output_iri for k , v in inputs . items () }","title":"get_input_iris()"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep.get_inputs","text":"Returns input and input index (inputs, idx) for route number routeno . Parameters: Name Type Description Default routeno int The route number to return inputs for. required Returns: Type Description 'Tuple[Inputs, int]' Inputs and difference between route number and number of routes for an input dictioary. Source code in tripper/mappings/mappings.py def get_inputs ( self , routeno : int ) -> \"Tuple[Inputs, int]\" : \"\"\"Returns input and input index `(inputs, idx)` for route number `routeno`. Arguments: routeno: The route number to return inputs for. Returns: Inputs and difference between route number and number of routes for an input dictioary. \"\"\" n = 0 for inputs in self . input_routes : n0 = n n += get_nroutes ( inputs ) if n > routeno : return inputs , routeno - n0 raise ValueError ( f \"routeno= { routeno } exceeds number of routes\" )","title":"get_inputs()"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep.join_input","text":"Join all input added with add_input() since join_mode was set true. Resets join_mode to false. Source code in tripper/mappings/mappings.py def join_input ( self ) -> None : \"\"\"Join all input added with add_input() since `join_mode` was set true. Resets `join_mode` to false.\"\"\" if not self . join_mode : raise MappingError ( \"Calling join_input() when join_mode is false.\" ) self . join_mode = False self . add_inputs ( self . joined_input ) self . joined_input = {}","title":"join_input()"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep.lowest_costs","text":"Returns a list of (cost, routeno) tuples with up to the nresult lowest costs and their corresponding route numbers. Parameters: Name Type Description Default nresults int Number of results to return. 5 Returns: Type Description 'List[Tuple[float, int]]' A list of (cost, routeno) tuples. Source code in tripper/mappings/mappings.py def lowest_costs ( self , nresults : int = 5 ) -> \"List[Tuple[float, int]]\" : \"\"\"Returns a list of `(cost, routeno)` tuples with up to the `nresult` lowest costs and their corresponding route numbers. Arguments: nresults: Number of results to return. Returns: A list of `(cost, routeno)` tuples. \"\"\" result = [] n = 0 # total number of routes # Loop over all toplevel routes leading into this mapping step for inputs in self . input_routes : # For each route, loop over all input arguments of this step # The number of permutations we must consider is the product # of the total number of routes to each input argument. # # We (potentially drastic) limit the possibilities by only # considering the `nresults` routes with lowest costs into # each argument. This gives at maximum # # nresults * number_of_input_arguments # # possibilities. We calculate the costs for all of them and # store them in an array with two columns: `cost` and `routeno`. # The `results` list is extended with the cost array # for each toplevel route leading into this step. base = np . rec . fromrecords ([( 0.0 , 0 )], names = \"cost,routeno\" , formats = \"f8,i8\" ) m = 1 for input in inputs . values (): if isinstance ( input , MappingStep ): nroutes = input . number_of_routes () res = np . rec . fromrecords ( sorted ( input . lowest_costs ( nresults = nresults ), key = lambda x : x [ 1 ], ), # [ # row # for row in sorted( # input.lowest_costs(nresults=nresults), # key=lambda x: x[1], # ) # ], dtype = base . dtype , ) res1 = res . repeat ( len ( base )) base = np . tile ( base , len ( res )) base . cost += res1 . cost base . routeno += res1 . routeno * m m *= nroutes else : base . cost += input . cost # Reduce the length of base (makes probably only sense in # the case self.cost is a callable, but it doesn't hurt...) base . sort () base = base [: nresults ] base . routeno += n n += m # Add the cost for this step to `res`. If `self.cost` is # a callable, we call it with the input for each routeno # as arguments. Otherwise `self.cost` is the cost of this # mapping step. if callable ( self . cost ): for i , rno in enumerate ( base . routeno ): inputs , _ = self . get_inputs ( rno ) input_iris = [ input . output_iri for input in inputs . values ()] owncost = self . cost ( self . triplestore , input_iris , self . output_iri ) base . cost [ i ] += owncost else : owncost = self . cost base . cost += owncost result . extend ( base . tolist ()) # Finally sort the results according to cost and return the # `nresults` rows with lowest cost. return sorted ( result )[: nresults ]","title":"lowest_costs()"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep.number_of_routes","text":"Total number of routes to this mapping step. Returns: Type Description int Total number of routes to this mapping step. Source code in tripper/mappings/mappings.py def number_of_routes ( self ) -> int : \"\"\"Total number of routes to this mapping step. Returns: Total number of routes to this mapping step. \"\"\" n = 0 for inputs in self . input_routes : n += get_nroutes ( inputs ) return n","title":"number_of_routes()"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MappingStep.show","text":"Returns a string representation of the mapping routes to this step. Parameters: Name Type Description Default routeno 'Optional[int]' show given route. The default is to show all routes. None name 'Optional[str]' Name of the last mapping step (mainly for internal use). None indent int How of blanks to prepend each line with (mainly for internal use). 0 Returns: Type Description str String representation of the mapping routes. Source code in tripper/mappings/mappings.py def show ( self , routeno : \"Optional[int]\" = None , name : \"Optional[str]\" = None , indent : int = 0 , ) -> str : \"\"\"Returns a string representation of the mapping routes to this step. Arguments: routeno: show given route. The default is to show all routes. name: Name of the last mapping step (mainly for internal use). indent: How of blanks to prepend each line with (mainly for internal use). Returns: String representation of the mapping routes. \"\"\" strings = [] ind = \" \" * indent strings . append ( ind + f ' { name if name else \"Step\" } :' ) strings . append ( ind + f \" steptype: \" f \" { self . steptype . name if self . steptype else None } \" ) strings . append ( ind + f \" output_iri: { self . output_iri } \" ) strings . append ( ind + f \" output_unit: { self . output_unit } \" ) strings . append ( ind + f \" cost: { self . cost } \" ) if routeno is None : strings . append ( ind + \" routes:\" ) for inputs in self . input_routes : t = \" \\n \" . join ( [ input_ . show ( name = name_ , indent = indent + 6 ) for name_ , input_ in inputs . items () ] ) strings . append ( ind + \" - \" + t [ indent + 6 :]) else : strings . append ( ind + \" inputs:\" ) inputs , idx = self . get_inputs ( routeno ) t = \" \\n \" . join ( [ input_ . show ( routeno = idx , name = name_ , indent = indent + 6 ) for name_ , input_ in inputs . items () ] ) strings . append ( ind + \" - \" + t [ indent + 6 :]) return \" \\n \" . join ( strings )","title":"show()"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.MissingRelationError","text":"There are missing relations in RDF triples. Source code in tripper/mappings/mappings.py class MissingRelationError ( MappingError ): \"\"\"There are missing relations in RDF triples.\"\"\"","title":"MissingRelationError"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.StepType","text":"Type of mapping step when going from the output to the inputs. Source code in tripper/mappings/mappings.py class StepType ( Enum ): \"\"\"Type of mapping step when going from the output to the inputs.\"\"\" MAPSTO = 1 INV_MAPSTO = - 1 INSTANCEOF = 2 INV_INSTANCEOF = - 2 SUBCLASSOF = 3 INV_SUBCLASSOF = - 3 FUNCTION = 4","title":"StepType"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.Value","text":"Represents the value of an instance property. Parameters: Name Type Description Default value 'Any' Property value. None unit 'Optional[str]' Property unit. None iri 'Optional[str]' IRI of ontological concept that this value is an instance of. None property_iri 'Optional[str]' IRI of datamodel property that this value is an instance of. None cost 'Union[float, Callable]' Cost of accessing this value. 0.0 Source code in tripper/mappings/mappings.py class Value : \"\"\"Represents the value of an instance property. Arguments: value: Property value. unit: Property unit. iri: IRI of ontological concept that this value is an instance of. property_iri: IRI of datamodel property that this value is an instance of. cost: Cost of accessing this value. \"\"\" # pylint: disable=too-few-public-methods def __init__ ( self , value : \"Any\" = None , unit : \"Optional[str]\" = None , iri : \"Optional[str]\" = None , property_iri : \"Optional[str]\" = None , cost : \"Union[float, Callable]\" = 0.0 , ): self . value = value self . unit = unit self . output_iri = iri self . property_iri = property_iri self . cost = cost def show ( self , routeno : \"Optional[int]\" = None , name : \"Optional[str]\" = None , indent : int = 0 , ) -> str : # pylint: disable=unused-argument \"\"\"Returns a string representation of the Value. Arguments: routeno: Unused. The argument exists for consistency with the corresponding method in Step. name: Name of value. indent: Indentation level. Returns: String representation of the value. \"\"\" strings = [] ind = \" \" * indent strings . append ( ind + f ' { name if name else \"Value\" } :' ) strings . append ( ind + f \" iri: { self . output_iri } \" ) strings . append ( ind + f \" property_iri: { self . property_iri } \" ) strings . append ( ind + f \" unit: { self . unit } \" ) strings . append ( ind + f \" cost: { self . cost } \" ) strings . append ( ind + f \" value: { self . value } \" ) return \" \\n \" . join ( strings )","title":"Value"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.Value.show","text":"Returns a string representation of the Value. Parameters: Name Type Description Default routeno 'Optional[int]' Unused. The argument exists for consistency with the corresponding method in Step. None name 'Optional[str]' Name of value. None indent int Indentation level. 0 Returns: Type Description str String representation of the value. Source code in tripper/mappings/mappings.py def show ( self , routeno : \"Optional[int]\" = None , name : \"Optional[str]\" = None , indent : int = 0 , ) -> str : # pylint: disable=unused-argument \"\"\"Returns a string representation of the Value. Arguments: routeno: Unused. The argument exists for consistency with the corresponding method in Step. name: Name of value. indent: Indentation level. Returns: String representation of the value. \"\"\" strings = [] ind = \" \" * indent strings . append ( ind + f ' { name if name else \"Value\" } :' ) strings . append ( ind + f \" iri: { self . output_iri } \" ) strings . append ( ind + f \" property_iri: { self . property_iri } \" ) strings . append ( ind + f \" unit: { self . unit } \" ) strings . append ( ind + f \" cost: { self . cost } \" ) strings . append ( ind + f \" value: { self . value } \" ) return \" \\n \" . join ( strings )","title":"show()"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.emmo_mapper","text":"Finds all function definitions in triplestore based on EMMO. Return a dict mapping output IRIs to a list of (function_iri, [input_iris, ...]) tuples. Source code in tripper/mappings/mappings.py def emmo_mapper ( triplestore : \"Triplestore\" ) -> \"Dict[str, list]\" : \"\"\"Finds all function definitions in `triplestore` based on EMMO. Return a dict mapping output IRIs to a list of (function_iri, [input_iris, ...]) tuples. \"\"\" Task = EMMO . EMMO_4299e344_a321_4ef2_a744_bacfcce80afc hasInput = EMMO . EMMO_36e69413_8c59_4799_946c_10b05d266e22 hasOutput = EMMO . EMMO_c4bace1d_4db0_4cd3_87e9_18122bae2840 d = defaultdict ( list ) for task in triplestore . subjects ( RDF . type , Task ): inputs = list ( triplestore . objects ( task , hasInput )) for output in triplestore . objects ( task , hasOutput ): d [ output ] . append (( task , inputs )) return d","title":"emmo_mapper()"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.fno_mapper","text":"Finds all function definitions in triplestore based on the function ontololy (FNO). Parameters: Name Type Description Default triplestore 'Triplestore' The triplestore to investigate. required Returns: Type Description 'Dict[str, list]' A mapping of output IRIs to a list of (function_iri, [input_iris, ...]) tuples. Source code in tripper/mappings/mappings.py def fno_mapper ( triplestore : \"Triplestore\" ) -> \"Dict[str, list]\" : \"\"\"Finds all function definitions in `triplestore` based on the function ontololy (FNO). Arguments: triplestore: The triplestore to investigate. Returns: A mapping of output IRIs to a list of `(function_iri, [input_iris, ...])` tuples. \"\"\" # pylint: disable=too-many-branches # Temporary dicts for fast lookup Dfirst = dict ( triplestore . subject_objects ( RDF . first )) Drest = dict ( triplestore . subject_objects ( RDF . rest )) Dexpects = defaultdict ( list ) Dreturns = defaultdict ( list ) for s , o in triplestore . subject_objects ( FNO . expects ): Dexpects [ s ] . append ( o ) for s , o in triplestore . subject_objects ( FNO . returns ): Dreturns [ s ] . append ( o ) d = defaultdict ( list ) for func , lst in Dreturns . items (): input_iris = [] for exp in Dexpects . get ( func , ()): if exp in Dfirst : while exp in Dfirst : input_iris . append ( Dfirst [ exp ]) if exp not in Drest : break exp = Drest [ exp ] else : # Support also misuse of FNO, where fno:expects refers # directly to input individuals input_iris . append ( exp ) for ret in lst : if ret in Dfirst : while ret in Dfirst : d [ Dfirst [ ret ]] . append (( func , input_iris )) if ret not in Drest : break ret = Drest [ ret ] else : # Support also misuse of FNO, where fno:returns refers # directly to the returned individual d [ ret ] . append (( func , input_iris )) return d","title":"fno_mapper()"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.get_nroutes","text":"Help function returning the number of routes for an input dict. Parameters: Name Type Description Default inputs 'Inputs' Input dictionary. required Returns: Type Description int Number of routes in the inputs input dictionary. Source code in tripper/mappings/mappings.py def get_nroutes ( inputs : \"Inputs\" ) -> int : \"\"\"Help function returning the number of routes for an input dict. Arguments: inputs: Input dictionary. Returns: Number of routes in the `inputs` input dictionary. \"\"\" nroutes = 1 for input in inputs . values (): if isinstance ( input , MappingStep ): nroutes *= input . number_of_routes () return nroutes","title":"get_nroutes()"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.get_values","text":"Help function returning a dict mapping the input names to actual value of expected input unit. There exists get_nroutes(inputs) routes to populate inputs . routeno is the index of the specific route we will use to obtain the values. Parameters: Name Type Description Default inputs 'dict[str, Any]' Input dictionary. required routeno int Route number index. required quantity 'Type[Quantity]' A unit quantity class. <class 'pint.quantity.Quantity'> magnitudes bool Whether to only return the magnitude of the evaluated value (with no unit). False Returns: Type Description 'dict[str, Any]' A mapping between input names and values of expected input unit. Source code in tripper/mappings/mappings.py def get_values ( inputs : \"dict[str, Any]\" , routeno : int , quantity : \"Type[Quantity]\" = Quantity , magnitudes : bool = False , ) -> \"dict[str, Any]\" : \"\"\"Help function returning a dict mapping the input names to actual value of expected input unit. There exists `get_nroutes(inputs)` routes to populate `inputs`. `routeno` is the index of the specific route we will use to obtain the values. Arguments: inputs: Input dictionary. routeno: Route number index. quantity: A unit quantity class. magnitudes: Whether to only return the magnitude of the evaluated value (with no unit). Returns: A mapping between input names and values of expected input unit. \"\"\" values = {} for k , v in inputs . items (): if isinstance ( v , MappingStep ): value = v . eval ( routeno = routeno , quantity = quantity ) values [ k ] = ( value . to ( v . output_unit ) if v . output_unit and isinstance ( v , quantity ) else value ) elif isinstance ( v , Value ): values [ k ] = quantity ( v . value , v . unit ) else : raise TypeError ( \"Expected values in inputs to be either `MappingStep` or \" \"`Value` objects.\" ) if magnitudes : values = { k : v . m if isinstance ( v , quantity ) else v for k , v in values . items () } return values","title":"get_values()"},{"location":"api_reference/mappings/mappings/#tripper.mappings.mappings.mapping_routes","text":"Find routes of mappings from any source in sources to target . This implementation supports functions (using FnO) and subclass relations. It also correctly handles transitivity of mapsTo and subClassOf relations. Parameters: Name Type Description Default target str IRI of the target in triplestore . required sources 'Dict[str, Value]' Dict mapping source IRIs to source values or a sequence of source IRIs (with no explicit values). required triplestore 'Triplestore' Triplestore instance. It is safe to pass a generator expression too. required Additional arguments for fine-grained tuning: !!! function_repo \"Dict mapping function IRIs to corresponding Python\" function. Default is to use triplestore.function_repo . !!! function_mappers \"Sequence of mapping functions that takes\" triplestore as argument and return a dict mapping output IRIs to a list of (function_iri, [input_iris, ...]) tuples. !!! default_costs \"A dict providing default costs of different types\" of mapping steps (\"function\", \"mapsTo\", \"instanceOf\", \"subclassOf\", and \"value\"). These costs can be overridden with 'hasCost' relations in the ontology. mapsTo: IRI of 'mapsTo' in triplestore . instanceOf: IRI of 'instanceOf' in triplestore . !!! subclassof \"IRI of 'subClassOf' in triples . Set it to None if\" subclasses should not be considered. !!! label \"IRI of 'label' in triplestore . Used for naming function\" input parameters. The default is to use rdfs:label. !!! hasunit \"IRI of 'hasUnit' in triples . Can be used to explicit\" specify the unit of a quantity. !!! hascost \"IRI of 'hasCost' in triples . Used for associating a\" user-defined cost or cost function with instantiation of a property. Returns: Type Description Input A MappingStep instance. This is a root of a nested tree of MappingStep instances providing an (efficient) internal description of all possible mapping routes from sources to target . Source code in tripper/mappings/mappings.py def mapping_routes ( target : str , sources : \"Dict[str, Value]\" , triplestore : \"Triplestore\" , function_repo : \"Optional[dict]\" = None , function_mappers : \"Sequence[Callable]\" = ( fno_mapper ,), default_costs : \"Tuple\" = ( ( \"function\" , 10.0 ), ( \"mapsTo\" , 2.0 ), ( \"instanceOf\" , 1.0 ), ( \"subClassOf\" , 1.0 ), ( \"value\" , 0.0 ), ), mapsTo : str = MAP . mapsTo , instanceOf : str = DM . instanceOf , subClassOf : str = RDFS . subClassOf , # description: str = DCTERMS.description, label : str = RDFS . label , hasUnit : str = DM . hasUnit , hasCost : str = DM . hasCost , # TODO - add hasCost to the DM ontology ) -> Input : \"\"\"Find routes of mappings from any source in `sources` to `target`. This implementation supports functions (using FnO) and subclass relations. It also correctly handles transitivity of `mapsTo` and `subClassOf` relations. Arguments: target: IRI of the target in `triplestore`. sources: Dict mapping source IRIs to source values or a sequence of source IRIs (with no explicit values). triplestore: Triplestore instance. It is safe to pass a generator expression too. Additional arguments for fine-grained tuning: function_repo: Dict mapping function IRIs to corresponding Python function. Default is to use `triplestore.function_repo`. function_mappers: Sequence of mapping functions that takes `triplestore` as argument and return a dict mapping output IRIs to a list of `(function_iri, [input_iris, ...])` tuples. default_costs: A dict providing default costs of different types of mapping steps (\"function\", \"mapsTo\", \"instanceOf\", \"subclassOf\", and \"value\"). These costs can be overridden with 'hasCost' relations in the ontology. mapsTo: IRI of 'mapsTo' in `triplestore`. instanceOf: IRI of 'instanceOf' in `triplestore`. subClassOf: IRI of 'subClassOf' in `triples`. Set it to None if subclasses should not be considered. label: IRI of 'label' in `triplestore`. Used for naming function input parameters. The default is to use rdfs:label. hasUnit: IRI of 'hasUnit' in `triples`. Can be used to explicit specify the unit of a quantity. hasCost: IRI of 'hasCost' in `triples`. Used for associating a user-defined cost or cost function with instantiation of a property. Returns: A MappingStep instance. This is a root of a nested tree of MappingStep instances providing an (efficient) internal description of all possible mapping routes from `sources` to `target`. \"\"\" # pylint: disable=too-many-arguments,too-many-locals,too-many-statements if target in sources : return Value ( iri = target ) if isinstance ( sources , Sequence ): sources = { iri : None for iri in sources } if function_repo is None : function_repo = triplestore . function_repo default_costs = dict ( default_costs ) # Create lookup tables for fast access to triplestore content soMaps = defaultdict ( list ) # (s, mapsTo, o) ==> soMaps[s] -> [o, ..] osMaps = defaultdict ( list ) # (o, mapsTo, s) ==> osMaps[o] -> [s, ..] osSubcl = defaultdict ( list ) # (o, subClassOf, s) ==> osSubcl[o] -> [s, ..] soInst = {} # (s, instanceOf, o) ==> soInst[s] -> o osInst = defaultdict ( list ) # (o, instanceOf, s) ==> osInst[o] -> [s, ..] for s , o in triplestore . subject_objects ( mapsTo ): soMaps [ s ] . append ( o ) osMaps [ o ] . append ( s ) for s , o in triplestore . subject_objects ( subClassOf ): osSubcl [ o ] . append ( s ) for s , o in triplestore . subject_objects ( instanceOf ): if s in soInst : raise InconsistentTriplesError ( f \"The same individual can only relate to one datamodel \" f \"property via { instanceOf } relations.\" ) soInst [ s ] = o osInst [ o ] . append ( s ) soName = dict ( triplestore . subject_objects ( label )) soUnit = dict ( triplestore . subject_objects ( hasUnit )) soCost = dict ( triplestore . subject_objects ( hasCost )) def getcost ( target , stepname ): \"\"\"Returns the cost assigned to IRI `target` for a mapping step of type `stepname`.\"\"\" cost = soCost . get ( target , default_costs [ stepname ]) if cost is None : return None return ( function_repo [ cost ] if cost in function_repo else float ( parse_literal ( cost )) ) def walk ( target , visited , step ): \"\"\"Walk backward in rdf graph from `node` to sources.\"\"\" if target in visited : return visited . add ( target ) def addnode ( node , steptype , stepname ): if node in visited : return step . steptype = steptype step . cost = getcost ( target , stepname ) if node in sources : value = Value ( value = sources [ node ], unit = soUnit . get ( node ), iri = node , property_iri = soInst . get ( node ), cost = getcost ( node , \"value\" ), ) step . add_input ( value , name = soName . get ( node )) else : prevstep = MappingStep ( output_iri = node , output_unit = soUnit . get ( node ), triplestore = triplestore , ) step . add_input ( prevstep , name = soName . get ( node )) walk ( node , visited , prevstep ) for node in osInst [ target ]: addnode ( node , StepType . INV_INSTANCEOF , \"instanceOf\" ) for node in soMaps [ target ]: addnode ( node , StepType . MAPSTO , \"mapsTo\" ) for node in osMaps [ target ]: addnode ( node , StepType . INV_MAPSTO , \"mapsTo\" ) for node in osSubcl [ target ]: addnode ( node , StepType . INV_SUBCLASSOF , \"subClassOf\" ) for fmap in function_mappers : for func , input_iris in fmap ( triplestore )[ target ]: step . steptype = StepType . FUNCTION step . cost = getcost ( func , \"function\" ) step . function = function_repo . get ( func ) step . join_mode = True for input_iri in input_iris : step0 = MappingStep ( output_iri = input_iri , output_unit = soUnit . get ( input_iri ), triplestore = triplestore , ) step . add_input ( step0 , name = soName . get ( input_iri )) walk ( input_iri , visited , step0 ) step . join_input () visited = set () step = MappingStep ( output_iri = target , output_unit = soUnit . get ( target ), triplestore = triplestore , ) if target in soInst : # It is only initially we want to follow instanceOf in forward # direction. Later on we will only follow mapsTo and instanceOf in # backward direction. visited . add ( target ) # do we really wan't this? Yes, I think so... source = soInst [ target ] step . steptype = StepType . INSTANCEOF step . cost = getcost ( source , \"instanceOf\" ) step0 = MappingStep ( output_iri = source , output_unit = soUnit . get ( source ), triplestore = triplestore , ) step . add_input ( step0 , name = soName . get ( target )) step = step0 target = source if target not in soMaps : raise MissingRelationError ( f 'Missing \"mapsTo\" relation on: { target } ' ) walk ( target , visited , step ) return step","title":"mapping_routes()"}]}