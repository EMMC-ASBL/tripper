{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tripper \u00b6 A triplestore wrapper for Python. The best ride when handling any triplestore. See the documentation for a quick tutorial. Installation \u00b6 The package can be installed from PyPI using pip : pip install tripper License and copyright \u00b6 All files in this repository are licensed under the MIT license with copyright \u00a9 2022 SINTEF.","title":"Home"},{"location":"#tripper","text":"A triplestore wrapper for Python. The best ride when handling any triplestore. See the documentation for a quick tutorial.","title":"Tripper"},{"location":"#installation","text":"The package can be installed from PyPI using pip : pip install tripper","title":"Installation"},{"location":"#license-and-copyright","text":"All files in this repository are licensed under the MIT license with copyright \u00a9 2022 SINTEF.","title":"License and copyright"},{"location":"CHANGELOG/","text":"Changelog \u00b6 Unreleased \u00b6 Full Changelog Implemented enhancements: Change package name to tripper on PyPI #13 v0.1.1 (2022-10-13) \u00b6 Full Changelog Implemented enhancements: Clean up newly initialized Python API #1 Fixed bugs: Enable proper release workflow #8 Fix workflows so they succeed #2 Merged pull requests: Use the package name tripper (not tripperpy ) #16 ( CasperWA ) Clean up repository & fix workflows #5 ( CasperWA ) Added version number in __init__ to enable local pip install #4 ( quaat ) * This Changelog was automatically generated by github_changelog_generator","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#unreleased","text":"Full Changelog Implemented enhancements: Change package name to tripper on PyPI #13","title":"Unreleased"},{"location":"CHANGELOG/#v011-2022-10-13","text":"Full Changelog Implemented enhancements: Clean up newly initialized Python API #1 Fixed bugs: Enable proper release workflow #8 Fix workflows so they succeed #2 Merged pull requests: Use the package name tripper (not tripperpy ) #16 ( CasperWA ) Clean up repository & fix workflows #5 ( CasperWA ) Added version number in __init__ to enable local pip install #4 ( quaat ) * This Changelog was automatically generated by github_changelog_generator","title":"v0.1.1 (2022-10-13)"},{"location":"LICENSE/","text":"MIT License Copyright (c) 2022 SINTEF Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"overview/","text":"Overview \u00b6 A Python package encapsulating different triplestores using the strategy design pattern. This package has by itself no dependencies outside the standard library, but the triplestore backends may have. The main class is Triplestore, who's __init__() method takes the name of the backend to encapsulate as first argument. Its interface is strongly inspired by rdflib.Graph, but simplified when possible to make it easy to use. Some important differences: all IRIs are represented by Python strings blank nodes are strings starting with \"_:\" literals are constructed with Literal() from triplestore import Triplestore ts = Triplestore ( backend = \"rdflib\" ) The module already provides a set of pre-defined namespaces that simplifies writing IRIs. For example: from triplestore import RDFS , OWL RDFS . subClassOf # -> 'http://www.w3.org/2000/01/rdf-schema#subClassOf' New namespaces can be created using the Namespace class, but are usually added with the bind() method: ONTO = ts . bind ( \"onto\" , \"http://example.com/onto#\" ) ONTO . MyConcept # -> 'http://example.com/onto#MyConcept' Namespace also support access by label and IRI checking. Both of these features requires loading an ontology. The following example shows how to create an EMMO namespace with IRI checking. The keyword argument label_annotations=True enables access by skos:prefLabel , rdfs:label or skos:altLabel . The check=True enables checking for existing IRIs. The triplestore_url=... is a resolvable URL that can be read by the 'rdflib' backend. It is needed, because the 'rdflib' backend is currently not able to load EMMO from the http://emmo.info/emmo# namespace. EMMO = ts . bind ( \"emmo\" , \"http://emmo.info/emmo#\" , label_annotations = True , check = True , triplestore_url = \"https://emmo-repo.github.io/versions/1.0.0-beta4/emmo-inferred.ttl\" , ) EMMO . Atom # -> 'http://emmo.info/emmo#EMMO_eb77076b_a104_42ac_a065_798b2d2809ad' EMMO . invalid_name # -> NoSuchIRIError: http://emmo.info/emmo#invalid_name New triples can be added either with the parse() method (for backends that support it) or the add() and add_triples() methods: # en(msg) is a convenient function for adding english literals. # It is equivalent to ``triplestore.Literal(msg, lang=\"en\")``. from triplestore import en ts . parse ( \"onto.ttl\" , format = \"turtle\" ) ts . add_triples ([ ( ONTO . MyConcept , RDFS . subClassOf , OWL . Thing ), ( ONTO . MyConcept , RDFS . label , en ( \"My briliant ontological concept.\" )), ]) For backends that support it the triplestore can be serialised using serialize() : ts . serialize ( \"onto2.ttl\" ) A set of convenient functions exists for simple queries, including triples() , subjects() , predicates() , objects() , subject_predicates() , subject_objects() , predicate_objects() and value() . Except for value() , they return the result as generators. For example: ts . objects ( subject = ONTO . MyConcept , predicate = RDFS . subClassOf ) # -> <generator object Triplestore.objects at 0x7fa502590200> list ( ts . objects ( subject = ONTO . MyConcept , predicate = RDFS . subClassOf )) # -> ['http://www.w3.org/2002/07/owl#Thing'] The query() and update() methods can be used to query and update the triplestore using SPARQL. Finally Triplestore has two specialised methods add_mapsTo() and add_function() that simplify working with mappings. add_mapsTo() is convinient for defining new mappings: from triplestore import Namespace META = Namespace ( \"http://onto-ns.com/meta/0.1/MyEntity#\" ) ts . add_mapsTo ( ONTO . MyConcept , META . my_property ) It can also be used with DLite and SOFT7 data models. Here we repeat the above with DLite: import dlite meta = dlite . get_instance ( \"http://onto-ns.com/meta/0.1/MyEntity\" ) ts . add_mapsTo ( ONTO . MyConcept , meta , \"my_property\" ) The add_function() describes a function and adds mappings for its arguments and return value(s). Currently it only supports the Function Ontology (FnO) . def mean ( x , y ): \"\"\"Returns the mean value of `x` and `y`.\"\"\" return ( x + y ) / 2 ts . add_function ( mean , expects = ( ONTO . RightArmLength , ONTO . LeftArmLength ), returns = ONTO . AverageArmLength , ) Further development \u00b6 Update the query() method to return the SPARQL result in a backend-independent way. Add additional backends. Candidates include: list of tuples owlready2/EMMOntoPy OntoRec/OntoFlowKB Stardog DLite triplestore (based on Redland librdf) Redland librdf Apache Jena Fuseki Allegrograph Wikidata","title":"Overview"},{"location":"overview/#overview","text":"A Python package encapsulating different triplestores using the strategy design pattern. This package has by itself no dependencies outside the standard library, but the triplestore backends may have. The main class is Triplestore, who's __init__() method takes the name of the backend to encapsulate as first argument. Its interface is strongly inspired by rdflib.Graph, but simplified when possible to make it easy to use. Some important differences: all IRIs are represented by Python strings blank nodes are strings starting with \"_:\" literals are constructed with Literal() from triplestore import Triplestore ts = Triplestore ( backend = \"rdflib\" ) The module already provides a set of pre-defined namespaces that simplifies writing IRIs. For example: from triplestore import RDFS , OWL RDFS . subClassOf # -> 'http://www.w3.org/2000/01/rdf-schema#subClassOf' New namespaces can be created using the Namespace class, but are usually added with the bind() method: ONTO = ts . bind ( \"onto\" , \"http://example.com/onto#\" ) ONTO . MyConcept # -> 'http://example.com/onto#MyConcept' Namespace also support access by label and IRI checking. Both of these features requires loading an ontology. The following example shows how to create an EMMO namespace with IRI checking. The keyword argument label_annotations=True enables access by skos:prefLabel , rdfs:label or skos:altLabel . The check=True enables checking for existing IRIs. The triplestore_url=... is a resolvable URL that can be read by the 'rdflib' backend. It is needed, because the 'rdflib' backend is currently not able to load EMMO from the http://emmo.info/emmo# namespace. EMMO = ts . bind ( \"emmo\" , \"http://emmo.info/emmo#\" , label_annotations = True , check = True , triplestore_url = \"https://emmo-repo.github.io/versions/1.0.0-beta4/emmo-inferred.ttl\" , ) EMMO . Atom # -> 'http://emmo.info/emmo#EMMO_eb77076b_a104_42ac_a065_798b2d2809ad' EMMO . invalid_name # -> NoSuchIRIError: http://emmo.info/emmo#invalid_name New triples can be added either with the parse() method (for backends that support it) or the add() and add_triples() methods: # en(msg) is a convenient function for adding english literals. # It is equivalent to ``triplestore.Literal(msg, lang=\"en\")``. from triplestore import en ts . parse ( \"onto.ttl\" , format = \"turtle\" ) ts . add_triples ([ ( ONTO . MyConcept , RDFS . subClassOf , OWL . Thing ), ( ONTO . MyConcept , RDFS . label , en ( \"My briliant ontological concept.\" )), ]) For backends that support it the triplestore can be serialised using serialize() : ts . serialize ( \"onto2.ttl\" ) A set of convenient functions exists for simple queries, including triples() , subjects() , predicates() , objects() , subject_predicates() , subject_objects() , predicate_objects() and value() . Except for value() , they return the result as generators. For example: ts . objects ( subject = ONTO . MyConcept , predicate = RDFS . subClassOf ) # -> <generator object Triplestore.objects at 0x7fa502590200> list ( ts . objects ( subject = ONTO . MyConcept , predicate = RDFS . subClassOf )) # -> ['http://www.w3.org/2002/07/owl#Thing'] The query() and update() methods can be used to query and update the triplestore using SPARQL. Finally Triplestore has two specialised methods add_mapsTo() and add_function() that simplify working with mappings. add_mapsTo() is convinient for defining new mappings: from triplestore import Namespace META = Namespace ( \"http://onto-ns.com/meta/0.1/MyEntity#\" ) ts . add_mapsTo ( ONTO . MyConcept , META . my_property ) It can also be used with DLite and SOFT7 data models. Here we repeat the above with DLite: import dlite meta = dlite . get_instance ( \"http://onto-ns.com/meta/0.1/MyEntity\" ) ts . add_mapsTo ( ONTO . MyConcept , meta , \"my_property\" ) The add_function() describes a function and adds mappings for its arguments and return value(s). Currently it only supports the Function Ontology (FnO) . def mean ( x , y ): \"\"\"Returns the mean value of `x` and `y`.\"\"\" return ( x + y ) / 2 ts . add_function ( mean , expects = ( ONTO . RightArmLength , ONTO . LeftArmLength ), returns = ONTO . AverageArmLength , )","title":"Overview"},{"location":"overview/#further-development","text":"Update the query() method to return the SPARQL result in a backend-independent way. Add additional backends. Candidates include: list of tuples owlready2/EMMOntoPy OntoRec/OntoFlowKB Stardog DLite triplestore (based on Redland librdf) Redland librdf Apache Jena Fuseki Allegrograph Wikidata","title":"Further development"},{"location":"api_reference/interface/","text":"interface \u00b6 Provides the ITriplestore protocol class, that documents the interface of the triplestore backends. ITriplestore ( Protocol ) \u00b6 Interface for triplestore backends. In addition to the methods specified by this interface, a backend may also implement the following optional methods: def __init__ ( self , base_iri = None , ** kwargs ) def parse ( self , source = None , location = None , data = None , format = None , ** kwargs ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Parameters: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. kwargs: Additional backend-specific parameters controlling the parsing. \"\"\" def serialize ( self , destination = None , format = 'xml' , ** kwargs ) \"\"\"Serialise to destination. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Additional backend-specific parameters controlling the serialisation. Returns: Serialised string if `destination` is None. \"\"\" def query ( self , query_object , ** kwargs ) \"\"\"SPARQL query.\"\"\" def update ( self , update_object , ** kwargs ) \"\"\"Update triplestore with SPARQL.\"\"\" def bind ( self , prefix : str , namespace : str ) \"\"\"Bind prefix to namespace. Should only be defined if the backend supports namespaces. \"\"\" def namespaces ( self ) -> dict \"\"\"Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. \"\"\" Source code in tripper/interface.py class ITriplestore ( Protocol ): '''Interface for triplestore backends. In addition to the methods specified by this interface, a backend may also implement the following optional methods: ```python def __init__(self, base_iri=None, **kwargs) def parse(self, source=None, location=None, data=None, format=None, **kwargs): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Parameters: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. kwargs: Additional backend-specific parameters controlling the parsing. \"\"\" def serialize(self, destination=None, format='xml', **kwargs) \"\"\"Serialise to destination. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Additional backend-specific parameters controlling the serialisation. Returns: Serialised string if `destination` is None. \"\"\" def query(self, query_object, **kwargs) \"\"\"SPARQL query.\"\"\" def update(self, update_object, **kwargs) \"\"\"Update triplestore with SPARQL.\"\"\" def bind(self, prefix: str, namespace: str) \"\"\"Bind prefix to namespace. Should only be defined if the backend supports namespaces. \"\"\" def namespaces(self) -> dict \"\"\"Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. \"\"\" ``` ''' def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples.\"\"\" def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" add_triples ( self , triples ) \u00b6 Add a sequence of triples. Source code in tripper/interface.py def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" remove ( self , triple ) \u00b6 Remove all matching triples from the backend. Source code in tripper/interface.py def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" triples ( self , triple ) \u00b6 Returns a generator over matching triples. Source code in tripper/interface.py def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples.\"\"\"","title":"interface"},{"location":"api_reference/interface/#interface","text":"Provides the ITriplestore protocol class, that documents the interface of the triplestore backends.","title":"interface"},{"location":"api_reference/interface/#tripper.interface.ITriplestore","text":"Interface for triplestore backends. In addition to the methods specified by this interface, a backend may also implement the following optional methods: def __init__ ( self , base_iri = None , ** kwargs ) def parse ( self , source = None , location = None , data = None , format = None , ** kwargs ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Parameters: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. kwargs: Additional backend-specific parameters controlling the parsing. \"\"\" def serialize ( self , destination = None , format = 'xml' , ** kwargs ) \"\"\"Serialise to destination. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Additional backend-specific parameters controlling the serialisation. Returns: Serialised string if `destination` is None. \"\"\" def query ( self , query_object , ** kwargs ) \"\"\"SPARQL query.\"\"\" def update ( self , update_object , ** kwargs ) \"\"\"Update triplestore with SPARQL.\"\"\" def bind ( self , prefix : str , namespace : str ) \"\"\"Bind prefix to namespace. Should only be defined if the backend supports namespaces. \"\"\" def namespaces ( self ) -> dict \"\"\"Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. \"\"\" Source code in tripper/interface.py class ITriplestore ( Protocol ): '''Interface for triplestore backends. In addition to the methods specified by this interface, a backend may also implement the following optional methods: ```python def __init__(self, base_iri=None, **kwargs) def parse(self, source=None, location=None, data=None, format=None, **kwargs): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Parameters: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. kwargs: Additional backend-specific parameters controlling the parsing. \"\"\" def serialize(self, destination=None, format='xml', **kwargs) \"\"\"Serialise to destination. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Additional backend-specific parameters controlling the serialisation. Returns: Serialised string if `destination` is None. \"\"\" def query(self, query_object, **kwargs) \"\"\"SPARQL query.\"\"\" def update(self, update_object, **kwargs) \"\"\"Update triplestore with SPARQL.\"\"\" def bind(self, prefix: str, namespace: str) \"\"\"Bind prefix to namespace. Should only be defined if the backend supports namespaces. \"\"\" def namespaces(self) -> dict \"\"\"Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. \"\"\" ``` ''' def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples.\"\"\" def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\"","title":"ITriplestore"},{"location":"api_reference/interface/#tripper.interface.ITriplestore.add_triples","text":"Add a sequence of triples. Source code in tripper/interface.py def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\"","title":"add_triples()"},{"location":"api_reference/interface/#tripper.interface.ITriplestore.remove","text":"Remove all matching triples from the backend. Source code in tripper/interface.py def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\"","title":"remove()"},{"location":"api_reference/interface/#tripper.interface.ITriplestore.triples","text":"Returns a generator over matching triples. Source code in tripper/interface.py def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples.\"\"\"","title":"triples()"},{"location":"api_reference/triplestore/","text":"triplestore \u00b6 A module encapsulating different triplestores using the strategy design pattern. See https://raw.githubusercontent.com/EMMC-ASBL/OntoFlow/master/triplestore/README.md for an introduction. This module has no dependencies outside the standard library, but the triplestore backends may have. For developers: The usage of s , p , and o represent the different parts of an RDF Triple: subject, predicate, and object. Literal ( str ) \u00b6 A literal RDF value. Source code in tripper/triplestore.py class Literal ( str ): \"\"\"A literal RDF value.\"\"\" lang : str datatype : \"Any\" def __new__ ( cls , value , lang = None , datatype = None ): string = super () . __new__ ( cls , value ) if lang : if datatype : raise TypeError ( \"A literal can only have one of `lang` or `datatype`.\" ) string . lang = str ( lang ) string . datatype = None else : string . lang = None if datatype : string . datatype = { str : XSD . string , bool : XSD . boolean , int : XSD . integer , float : XSD . double , bytes : XSD . hexBinary , bytearray : XSD . hexBinary , datetime : XSD . dateTime , } . get ( datatype , datatype ) elif isinstance ( value , str ): string . datatype = None elif isinstance ( value , bool ): string . datatype = XSD . boolean elif isinstance ( value , int ): string . datatype = XSD . integer elif isinstance ( value , float ): string . datatype = XSD . double elif isinstance ( value , ( bytes , bytearray )): string = value . hex () string . datatype = XSD . hexBinary elif isinstance ( value , datetime ): string . datatype = XSD . dateTime # TODO: # - XSD.base64Binary # - XSD.byte, XSD.unsignedByte else : string . datatype = None return string def __repr__ ( self ): lang = f \", lang=' { self . lang } '\" if self . lang else \"\" datatype = f \", datatype=' { self . datatype } '\" if self . datatype else \"\" return f \"Literal(' { self } ' { lang }{ datatype } )\" value = property ( fget = lambda self : self . to_python (), doc = \"Appropriate python datatype derived from this RDF literal.\" , ) def to_python ( self ): \"\"\"Returns an appropriate python datatype derived from this RDF literal.\"\"\" value = str ( self ) if self . datatype == XSD . boolean : value = bool ( self ) elif self . datatype in ( XSD . integer , XSD . int , XSD . short , XSD . long , XSD . nonPositiveInteger , XSD . negativeInteger , XSD . nonNegativeInteger , XSD . unsignedInt , XSD . unsignedShort , XSD . unsignedLong , XSD . byte , XSD . unsignedByte , ): value = int ( self ) elif self . datatype in ( XSD . double , XSD . decimal , XSD . dataTimeStamp , OWL . real , OWL . rational , ): value = float ( self ) elif self . datatype == XSD . hexBinary : value = self . encode () elif self . datatype == XSD . dateTime : value = datetime . fromisoformat ( self ) elif self . datatype and self . datatype not in ( RDF . PlainLiteral , RDF . XMLLiteral , RDFS . Literal , XSD . anyURI , XSD . language , XSD . Name , XSD . NMName , XSD . normalizedString , XSD . string , XSD . token , XSD . NMTOKEN , ): warnings . warn ( f \"unknown datatype: { self . datatype } - assuming string\" ) return value def n3 ( self ): # pylint: disable=invalid-name \"\"\"Returns a representation in n3 format.\"\"\" if self . lang : return f '\" { self } \"@ { self . lang } ' if self . datatype : return f '\" { self } \"^^ { self . datatype } ' return f '\" { self } \"' value property readonly \u00b6 Appropriate python datatype derived from this RDF literal. __new__ ( cls , value , lang = None , datatype = None ) special staticmethod \u00b6 Create and return a new object. See help(type) for accurate signature. Source code in tripper/triplestore.py def __new__ ( cls , value , lang = None , datatype = None ): string = super () . __new__ ( cls , value ) if lang : if datatype : raise TypeError ( \"A literal can only have one of `lang` or `datatype`.\" ) string . lang = str ( lang ) string . datatype = None else : string . lang = None if datatype : string . datatype = { str : XSD . string , bool : XSD . boolean , int : XSD . integer , float : XSD . double , bytes : XSD . hexBinary , bytearray : XSD . hexBinary , datetime : XSD . dateTime , } . get ( datatype , datatype ) elif isinstance ( value , str ): string . datatype = None elif isinstance ( value , bool ): string . datatype = XSD . boolean elif isinstance ( value , int ): string . datatype = XSD . integer elif isinstance ( value , float ): string . datatype = XSD . double elif isinstance ( value , ( bytes , bytearray )): string = value . hex () string . datatype = XSD . hexBinary elif isinstance ( value , datetime ): string . datatype = XSD . dateTime # TODO: # - XSD.base64Binary # - XSD.byte, XSD.unsignedByte else : string . datatype = None return string n3 ( self ) \u00b6 Returns a representation in n3 format. Source code in tripper/triplestore.py def n3 ( self ): # pylint: disable=invalid-name \"\"\"Returns a representation in n3 format.\"\"\" if self . lang : return f '\" { self } \"@ { self . lang } ' if self . datatype : return f '\" { self } \"^^ { self . datatype } ' return f '\" { self } \"' to_python ( self ) \u00b6 Returns an appropriate python datatype derived from this RDF literal. Source code in tripper/triplestore.py def to_python ( self ): \"\"\"Returns an appropriate python datatype derived from this RDF literal.\"\"\" value = str ( self ) if self . datatype == XSD . boolean : value = bool ( self ) elif self . datatype in ( XSD . integer , XSD . int , XSD . short , XSD . long , XSD . nonPositiveInteger , XSD . negativeInteger , XSD . nonNegativeInteger , XSD . unsignedInt , XSD . unsignedShort , XSD . unsignedLong , XSD . byte , XSD . unsignedByte , ): value = int ( self ) elif self . datatype in ( XSD . double , XSD . decimal , XSD . dataTimeStamp , OWL . real , OWL . rational , ): value = float ( self ) elif self . datatype == XSD . hexBinary : value = self . encode () elif self . datatype == XSD . dateTime : value = datetime . fromisoformat ( self ) elif self . datatype and self . datatype not in ( RDF . PlainLiteral , RDF . XMLLiteral , RDFS . Literal , XSD . anyURI , XSD . language , XSD . Name , XSD . NMName , XSD . normalizedString , XSD . string , XSD . token , XSD . NMTOKEN , ): warnings . warn ( f \"unknown datatype: { self . datatype } - assuming string\" ) return value Namespace \u00b6 Represent a namespace. Parameters: Name Type Description Default iri IRI of namespace to represent. required label_annotations Sequence of label annotations. If given, check the underlying ontology during attribute access if the name correspond to a label. The label annotations should be ordered from highest to lowest precedense. If True is provided, label_annotations is set to (SKOS.prefLabel, RDF.label, SKOS.altLabel) . () check Whether to check underlying ontology if the IRI exists during attribute access. If true, NoSuchIRIError will be raised if the IRI does not exist in this namespace. False cachemode Should be one of: - Namespace.NO_CACHE: Turn off caching. - Namespace.USE_CACHE: Cache attributes as they are looked up. - Namespace.ONLY_CACHE: Cache all names at initialisation time. Do not access the triplestore after that. Default is NO_CACHE if neither label_annotations or check is given, otherwise USE_CACHE . -1 triplestore Use this triplestore for label lookup and checking. If not given, and either label_annotations or check are enabled, a new rdflib triplestore will be created. None triplestore_url Alternative URL to use for loading the underlying ontology if triplestore is not given. Defaults to iri . None Source code in tripper/triplestore.py class Namespace : \"\"\"Represent a namespace. Arguments: iri: IRI of namespace to represent. label_annotations: Sequence of label annotations. If given, check the underlying ontology during attribute access if the name correspond to a label. The label annotations should be ordered from highest to lowest precedense. If True is provided, `label_annotations` is set to ``(SKOS.prefLabel, RDF.label, SKOS.altLabel)``. check: Whether to check underlying ontology if the IRI exists during attribute access. If true, NoSuchIRIError will be raised if the IRI does not exist in this namespace. cachemode: Should be one of: - Namespace.NO_CACHE: Turn off caching. - Namespace.USE_CACHE: Cache attributes as they are looked up. - Namespace.ONLY_CACHE: Cache all names at initialisation time. Do not access the triplestore after that. Default is `NO_CACHE` if neither `label_annotations` or `check` is given, otherwise `USE_CACHE`. triplestore: Use this triplestore for label lookup and checking. If not given, and either `label_annotations` or `check` are enabled, a new rdflib triplestore will be created. triplestore_url: Alternative URL to use for loading the underlying ontology if `triplestore` is not given. Defaults to `iri`. \"\"\" NO_CACHE = 0 USE_CACHE = 1 ONLY_CACHE = 2 __slots__ = ( \"_iri\" , \"_label_annotations\" , \"_check\" , \"_cache\" , \"_triplestore\" , ) def __init__ ( self , iri , label_annotations = (), check = False , cachemode =- 1 , triplestore = None , triplestore_url = None , ): if label_annotations is True : label_annotations = ( SKOS . prefLabel , RDF . label , SKOS . altLabel ) self . _iri = str ( iri ) self . _label_annotations = tuple ( label_annotations ) self . _check = bool ( check ) need_triplestore = bool ( check or label_annotations ) if cachemode == - 1 : cachemode = Namespace . ONLY_CACHE if need_triplestore else Namespace . NO_CACHE if need_triplestore and triplestore is None : url = triplestore_url if triplestore_url else iri triplestore = Triplestore ( \"rdflib\" , base_iri = iri ) triplestore . parse ( url ) self . _cache = {} if cachemode != Namespace . NO_CACHE else None # # FIXME: # Change this to only assigning the triplestore if cachemode is # ONLY_CACHE when we figure out a good way to pre-populate the # cache with IRIs from the triplestore. # # self._triplestore = ( # triplestore if cachemode != Namespace.ONLY_CACHE else None # ) self . _triplestore = triplestore if need_triplestore else None if cachemode != Namespace . NO_CACHE : self . _update_cache ( triplestore ) def _update_cache ( self , triplestore = None ): \"\"\"Update the internal cache from `triplestore`.\"\"\" if not triplestore : triplestore = self . _triplestore if not triplestore : raise NamespaceError ( \"`triplestore` argument needed for updating the cache\" ) if self . _cache is None : self . _cache = {} # Add (label, full_iri) pairs to cache for label in reversed ( self . _label_annotations ): self . _cache . update ( ( o , s ) for s , o in triplestore . subject_objects ( label ) if s . startswith ( self . _iri ) ) # Add (name, full_iri) pairs to cache # Currently we only check concepts that defines RDFS.isDefinedBy # relations. # Is there an efficient way to loop over all IRIs in this namespace? self . _cache . update ( ( s [ len ( self . _iri ) :], s ) for s in triplestore . subjects ( RDFS . isDefinedBy , self . _iri ) if s . startswith ( self . _iri ) ) def __getattr__ ( self , name ): if self . _cache and name in self . _cache : return self . _cache [ name ] if self . _triplestore : # Check if ``iri = self._iri + name`` is in the triplestore. # If so, add it to the cache. # We only need to check that generator returned by # `self._triplestore.predicate_objects(iri)` is non-empty. iri = self . _iri + name predicate_object = self . _triplestore . predicate_objects ( iri ) try : predicate_object . __next__ () except StopIteration : pass else : if self . _cache is not None : self . _cache [ name ] = iri return iri # Check for label annotations matching `name`. for label in self . _label_annotations : for s , o in self . _triplestore . subject_objects ( label ): if o == name and s . startswith ( self . _iri ): if self . _cache is not None : self . _cache [ name ] = s return s if self . _check : raise NoSuchIRIError ( self . _iri + name ) return self . _iri + name def __getitem__ ( self , key ): return self . __getattr__ ( key ) def __repr__ ( self ): return f \"Namespace( { self . _iri } )\" def __str__ ( self ): return self . _iri def __add__ ( self , other ): return self . _iri + str ( other ) NamespaceError ( TriplestoreError ) \u00b6 Namespace error. Source code in tripper/triplestore.py class NamespaceError ( TriplestoreError ): \"\"\"Namespace error.\"\"\" NoSuchIRIError ( NamespaceError ) \u00b6 Namespace has no such IRI. Source code in tripper/triplestore.py class NoSuchIRIError ( NamespaceError ): \"\"\"Namespace has no such IRI.\"\"\" Triplestore \u00b6 Provides a common frontend to a range of triplestore backends. Source code in tripper/triplestore.py class Triplestore : \"\"\"Provides a common frontend to a range of triplestore backends.\"\"\" default_namespaces = { \"xml\" : XML , \"rdf\" : RDF , \"rdfs\" : RDFS , \"xsd\" : XSD , \"owl\" : OWL , # \"skos\": SKOS, # \"dc\": DC, # \"dcterms\": DCTERMS, # \"foaf\": FOAF, # \"doap\": DOAP, # \"fno\": FNO, # \"emmo\": EMMO, # \"map\": MAP, # \"dm\": DM, } def __init__ ( self , backend : str , base_iri : str = None , ** kwargs ): \"\"\"Initialise triplestore using the backend with the given name. Parameters: backend: Name of the backend module. base_iri: Base IRI used by the add_function() method when adding new triples. kwargs: Keyword arguments passed to the backend's __init__() method. \"\"\" module = import_module ( backend if \".\" in backend else f \"tripper.backends. { backend } \" ) cls = getattr ( module , backend . title () + \"Strategy\" ) self . base_iri = base_iri self . namespaces : \"Dict[str, Namespace]\" = {} self . backend_name = backend self . backend = cls ( base_iri = base_iri , ** kwargs ) # Keep functions in the triplestore for convienence even though # they usually do not belong to the triplestore per se. self . function_repo : \"Dict[str, Union[float, Callable[[], float]]]\" = {} for prefix , namespace in self . default_namespaces . items (): self . bind ( prefix , namespace ) # Methods implemented by backend # ------------------------------ def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples.\"\"\" return self . backend . triples ( triple ) def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" self . backend . add_triples ( triples ) def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" self . backend . remove ( triple ) # Methods optionally implemented by backend # ----------------------------------------- def parse ( self , source = None , format = None , ** kwargs # pylint: disable=redefined-builtin ): \"\"\"Parse source and add the resulting triples to triplestore. Parameters: source: File-like object or file name. format: Needed if format can not be inferred from source. kwargs: Keyword arguments passed to the backend. The rdflib backend supports e.g. `location` (absolute or relative URL) and `data` (string containing the data to be parsed) arguments. \"\"\" self . _check_method ( \"parse\" ) self . backend . parse ( source = source , format = format , ** kwargs ) if hasattr ( self . backend , \"namespaces\" ): for prefix , namespace in self . backend . namespaces () . items (): if prefix and prefix not in self . namespaces : self . namespaces [ prefix ] = Namespace ( namespace ) def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise triplestore. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the backend serialize() method. Returns: Serialized string if `destination` is None. \"\"\" self . _check_method ( \"serialize\" ) return self . backend . serialize ( destination = destination , format = format , ** kwargs ) def query ( self , query_object , ** kwargs ): \"\"\"SPARQL query.\"\"\" self . _check_method ( \"query\" ) return self . backend . query ( query_object = query_object , ** kwargs ) def update ( self , update_object , ** kwargs ): \"\"\"Update triplestore with SPARQL.\"\"\" self . _check_method ( \"update\" ) return self . backend . update ( update_object = update_object , ** kwargs ) def bind ( self , prefix : str , namespace : \"Union[str, Namespace]\" , ** kwargs ): \"\"\"Bind prefix to namespace and return the new Namespace object. The new Namespace is created with `namespace` as IRI. Keyword arguments are passed to the Namespace() constructor. If `namespace` is None, the corresponding prefix is removed. \"\"\" if hasattr ( self . backend , \"bind\" ): self . backend . bind ( prefix , namespace ) if namespace is None : del self . namespaces [ prefix ] return None self . namespaces [ prefix ] = ( namespace if isinstance ( namespace , Namespace ) else Namespace ( namespace , ** kwargs ) ) return self . namespaces [ prefix ] # Convenient methods # ------------------ # These methods are modelled after rdflib and provide some convinient # interfaces to the triples(), add_triples() and remove() methods # implemented by all backends. def _check_method ( self , name ): \"\"\"Check that backend implements the given method.\"\"\" if not hasattr ( self . backend , name ): raise NotImplementedError ( f \"Triplestore backend { self . backend_name !r} do not implement a \" f '\" { name } ()\" method.' ) def add ( self , triple : \"Triple\" ): \"\"\"Add `triple` to triplestore.\"\"\" self . add_triples ([ triple ]) def value ( self , subject = None , predicate = None , object = None , default = None , any = False ): # pylint: disable=redefined-builtin \"\"\"Return the value for a pair of two criteria. Useful if one knows that there may only be one value. Parameters: subject, predicate, object: Triple to match. default: Value to return if no matches are found. any: If true, return any matching value, otherwise raise UniquenessError. \"\"\" triple = self . triples (( subject , predicate , object )) try : value = next ( triple ) except StopIteration : return default if any : return value try : next ( triple ) except StopIteration : return value else : raise UniquenessError ( \"More than one match\" ) def subjects ( self , predicate = None , object = None # pylint: disable=redefined-builtin ): \"\"\"Returns a generator of subjects for given predicate and object.\"\"\" for s , _ , _ in self . triples (( None , predicate , object )): yield s def predicates ( self , subject = None , object = None # pylint: disable=redefined-builtin ): \"\"\"Returns a generator of predicates for given subject and object.\"\"\" for _ , p , _ in self . triples (( subject , None , object )): yield p def objects ( self , subject = None , predicate = None ): \"\"\"Returns a generator of objects for given subject and predicate.\"\"\" for _ , _ , o in self . triples (( subject , predicate , None )): yield o def subject_predicates ( self , object = None ): # pylint: disable=redefined-builtin \"\"\"Returns a generator of (subject, predicate) tuples for given object.\"\"\" for s , p , _ in self . triples (( None , None , object )): yield s , p def subject_objects ( self , predicate = None ): \"\"\"Returns a generator of (subject, object) tuples for given predicate.\"\"\" for s , _ , o in self . triples (( None , predicate , None )): yield s , o def predicate_objects ( self , subject = None ): \"\"\"Returns a generator of (predicate, object) tuples for given subject.\"\"\" for _ , p , o in self . triples (( subject , None , None )): yield p , o def set ( self , triple ): \"\"\"Convenience method to update the value of object. Removes any existing triples for subject and predicate before adding the given `triple`. \"\"\" s , p , _ = triple self . remove (( s , p , None )) self . add ( triple ) def has ( self , subject = None , predicate = None , object = None ): # pylint: disable=redefined-builtin \"\"\"Returns true if the triplestore has any triple matching the give subject, predicate and/or object.\"\"\" triple = self . triples (( subject , predicate , object )) try : next ( triple ) except StopIteration : return False return True # Methods providing additional functionality # ------------------------------------------ def expand_iri ( self , iri : str ): \"\"\"Return the full IRI if `iri` is prefixed. Otherwise `iri` is returned.\"\"\" match = re . match ( _MATCH_PREFIXED_IRI , iri ) if match : prefix , name = match . groups () if prefix not in self . namespaces : raise NamespaceError ( f \"unknown namespace: { prefix } \" ) return f \" { self . namespaces [ prefix ] }{ name } \" return iri def prefix_iri ( self , iri : str , require_prefixed : bool = False ): \"\"\"Return prefixed IRI. This is the reverse of expand_iri(). If `require_prefixed` is true, a NamespaceError exception is raised if no prefix can be found. \"\"\" if not re . match ( _MATCH_PREFIXED_IRI , iri ): for prefix , namespace in self . namespaces . items (): if iri . startswith ( str ( namespace )): return f \" { prefix } : { iri [ len ( str ( namespace )):] } \" if require_prefixed : raise NamespaceError ( f \"No prefix defined for IRI: { iri } \" ) return iri def add_mapsTo ( # pylint: disable=invalid-name self , target : str , source : str , property_name : str = None , cost : \"Union[float, Callable]\" = None , target_cost : bool = True , ): \"\"\"Add 'mapsTo' relation to triplestore. Parameters: target: IRI of target ontological concept. source: Source IRI (or entity object). property_name: Name of property if `source` is an entity or an entity IRI. cost: User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the value of the mapped quantity as input and returning the cost as a float. target_cost: Whether the cost is assigned to mapping steps that have `target` as output. \"\"\" self . bind ( \"map\" , MAP ) if not property_name and not isinstance ( source , str ): raise TriplestoreError ( \"`property_name` is required when `target` is not a string.\" ) target = self . expand_iri ( target ) source = self . expand_iri ( infer_iri ( source )) if property_name : source = f \" { source } # { property_name } \" self . add (( source , MAP . mapsTo , target )) if cost is not None : dest = target if target_cost else source self . _add_cost ( cost , dest ) def add_function ( self , func : Callable , expects : \"Union[str, Sequence, Mapping]\" = (), returns : \"Union[str, Sequence]\" = (), base_iri : str = None , standard : str = \"fno\" , cost : \"Union[float, Callable]\" = None , ): \"\"\"Inspect function and add triples describing it to the triplestore. Parameters: func: Function to describe. expects: Sequence of IRIs to ontological concepts corresponding to positional arguments of `func`. May also be given as a dict mapping argument names to corresponding ontological IRIs. returns: IRI of return value. May also be given as a sequence of IRIs, if multiple values are returned. base_iri: Base of the IRI representing the function in the knowledge base. Defaults to the base IRI of the triplestore. standard: Name of ontology to use when describing the function. Defaults to the Function Ontology (FnO). cost: User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the same arguments as `func` returning the cost as a float. Returns: func_iri: IRI of the added function. \"\"\" if isinstance ( expects , str ): expects = [ expects ] if isinstance ( returns , str ): returns = [ returns ] method = getattr ( self , f \"_add_function_ { standard } \" ) func_iri = method ( func , expects , returns , base_iri ) self . function_repo [ func_iri ] = func if cost is not None : for dest_iri in returns : self . _add_cost ( cost , dest_iri ) return func_iri def _add_cost ( self , cost : \"Union[float, Callable[[], float]]\" , dest_iri ): \"\"\"Help function that adds `cost` to destination IRI `dest_iri`. `cost` should be either a float or a Callable returning a float. If `cost` is a callable it is just referred to with a literal id and is not ontologically described as a function. The expected input arguments depends on the context, which is why this function is not part of the public API. Use the add_mapsTo() and add_function() methods instead. \"\"\" if self . has ( dest_iri , DM . hasCost ): warnings . warn ( f \"A cost is already assigned to IRI: { dest_iri } \" ) elif callable ( cost ): cost_id = f \"cost_function { function_id ( cost ) } \" self . add (( dest_iri , DM . hasCost , Literal ( cost_id ))) self . function_repo [ cost_id ] = cost else : self . add (( dest_iri , DM . hasCost , Literal ( cost ))) def _add_function_fno ( self , func , expects , returns , base_iri ): \"\"\"Implementing add_function() for FnO.\"\"\" self . bind ( \"fno\" , FNO ) self . bind ( \"dcterms\" , DCTERMS ) self . bind ( \"map\" , MAP ) if base_iri is None : base_iri = self . base_iri if self . base_iri else \":\" fid = function_id ( func ) # Function id doc_string = inspect . getdoc ( func ) func_iri = f \" { base_iri }{ func . __name__ } _ { fid } \" parlist = f \"_: { func . __name__ }{ fid } parlist\" outlist = f \"_: { func . __name__ }{ fid } outlist\" self . add (( func_iri , RDF . type , FNO . Function )) self . add (( func_iri , FNO . expects , parlist )) self . add (( func_iri , FNO . returns , outlist )) if doc_string : self . add (( func_iri , DCTERMS . description , en ( doc_string ))) if isinstance ( expects , Sequence ): items = list ( zip ( expects , inspect . signature ( func ) . parameters )) else : items = [( expects [ par ], par ) for par in inspect . signature ( func ) . parameters ] lst = parlist for i , ( iri , parname ) in enumerate ( items ): lst_next = f \" { parlist }{ i + 2 } \" if i < len ( items ) - 1 else RDF . nil par = f \" { func_iri } _parameter { i + 1 } _ { parname } \" self . add (( par , RDF . type , FNO . Parameter )) self . add (( par , RDFS . label , en ( parname ))) self . add (( par , MAP . mapsTo , iri )) self . add (( lst , RDF . first , par )) self . add (( lst , RDF . rest , lst_next )) lst = lst_next lst = outlist for i , iri in enumerate ( returns ): lst_next = f \" { outlist }{ i + 2 } \" if i < len ( returns ) - 1 else RDF . nil val = f \" { func_iri } _output { i + 1 } \" self . add (( val , RDF . type , FNO . Output )) self . add (( val , MAP . mapsTo , iri )) self . add (( lst , RDF . first , val )) self . add (( lst , RDF . rest , lst_next )) lst = lst_next return func_iri __init__ ( self , backend , base_iri = None , ** kwargs ) special \u00b6 Initialise triplestore using the backend with the given name. Parameters: Name Type Description Default backend str Name of the backend module. required base_iri str Base IRI used by the add_function() method when adding new triples. None kwargs Keyword arguments passed to the backend's init () method. {} Source code in tripper/triplestore.py def __init__ ( self , backend : str , base_iri : str = None , ** kwargs ): \"\"\"Initialise triplestore using the backend with the given name. Parameters: backend: Name of the backend module. base_iri: Base IRI used by the add_function() method when adding new triples. kwargs: Keyword arguments passed to the backend's __init__() method. \"\"\" module = import_module ( backend if \".\" in backend else f \"tripper.backends. { backend } \" ) cls = getattr ( module , backend . title () + \"Strategy\" ) self . base_iri = base_iri self . namespaces : \"Dict[str, Namespace]\" = {} self . backend_name = backend self . backend = cls ( base_iri = base_iri , ** kwargs ) # Keep functions in the triplestore for convienence even though # they usually do not belong to the triplestore per se. self . function_repo : \"Dict[str, Union[float, Callable[[], float]]]\" = {} for prefix , namespace in self . default_namespaces . items (): self . bind ( prefix , namespace ) add ( self , triple ) \u00b6 Add triple to triplestore. Source code in tripper/triplestore.py def add ( self , triple : \"Triple\" ): \"\"\"Add `triple` to triplestore.\"\"\" self . add_triples ([ triple ]) add_function ( self , func , expects = (), returns = (), base_iri = None , standard = 'fno' , cost = None ) \u00b6 Inspect function and add triples describing it to the triplestore. Parameters: Name Type Description Default func Callable Function to describe. required expects 'Union[str, Sequence, Mapping]' Sequence of IRIs to ontological concepts corresponding to positional arguments of func . May also be given as a dict mapping argument names to corresponding ontological IRIs. () returns 'Union[str, Sequence]' IRI of return value. May also be given as a sequence of IRIs, if multiple values are returned. () base_iri str Base of the IRI representing the function in the knowledge base. Defaults to the base IRI of the triplestore. None standard str Name of ontology to use when describing the function. Defaults to the Function Ontology (FnO). 'fno' cost 'Union[float, Callable]' User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the same arguments as func returning the cost as a float. None Returns: Type Description func_iri IRI of the added function. Source code in tripper/triplestore.py def add_function ( self , func : Callable , expects : \"Union[str, Sequence, Mapping]\" = (), returns : \"Union[str, Sequence]\" = (), base_iri : str = None , standard : str = \"fno\" , cost : \"Union[float, Callable]\" = None , ): \"\"\"Inspect function and add triples describing it to the triplestore. Parameters: func: Function to describe. expects: Sequence of IRIs to ontological concepts corresponding to positional arguments of `func`. May also be given as a dict mapping argument names to corresponding ontological IRIs. returns: IRI of return value. May also be given as a sequence of IRIs, if multiple values are returned. base_iri: Base of the IRI representing the function in the knowledge base. Defaults to the base IRI of the triplestore. standard: Name of ontology to use when describing the function. Defaults to the Function Ontology (FnO). cost: User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the same arguments as `func` returning the cost as a float. Returns: func_iri: IRI of the added function. \"\"\" if isinstance ( expects , str ): expects = [ expects ] if isinstance ( returns , str ): returns = [ returns ] method = getattr ( self , f \"_add_function_ { standard } \" ) func_iri = method ( func , expects , returns , base_iri ) self . function_repo [ func_iri ] = func if cost is not None : for dest_iri in returns : self . _add_cost ( cost , dest_iri ) return func_iri add_mapsTo ( self , target , source , property_name = None , cost = None , target_cost = True ) \u00b6 Add 'mapsTo' relation to triplestore. Parameters: Name Type Description Default target str IRI of target ontological concept. required source str Source IRI (or entity object). required property_name str Name of property if source is an entity or an entity IRI. None cost 'Union[float, Callable]' User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the value of the mapped quantity as input and returning the cost as a float. None target_cost bool Whether the cost is assigned to mapping steps that have target as output. True Source code in tripper/triplestore.py def add_mapsTo ( # pylint: disable=invalid-name self , target : str , source : str , property_name : str = None , cost : \"Union[float, Callable]\" = None , target_cost : bool = True , ): \"\"\"Add 'mapsTo' relation to triplestore. Parameters: target: IRI of target ontological concept. source: Source IRI (or entity object). property_name: Name of property if `source` is an entity or an entity IRI. cost: User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the value of the mapped quantity as input and returning the cost as a float. target_cost: Whether the cost is assigned to mapping steps that have `target` as output. \"\"\" self . bind ( \"map\" , MAP ) if not property_name and not isinstance ( source , str ): raise TriplestoreError ( \"`property_name` is required when `target` is not a string.\" ) target = self . expand_iri ( target ) source = self . expand_iri ( infer_iri ( source )) if property_name : source = f \" { source } # { property_name } \" self . add (( source , MAP . mapsTo , target )) if cost is not None : dest = target if target_cost else source self . _add_cost ( cost , dest ) add_triples ( self , triples ) \u00b6 Add a sequence of triples. Source code in tripper/triplestore.py def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" self . backend . add_triples ( triples ) bind ( self , prefix , namespace , ** kwargs ) \u00b6 Bind prefix to namespace and return the new Namespace object. The new Namespace is created with namespace as IRI. Keyword arguments are passed to the Namespace() constructor. If namespace is None, the corresponding prefix is removed. Source code in tripper/triplestore.py def bind ( self , prefix : str , namespace : \"Union[str, Namespace]\" , ** kwargs ): \"\"\"Bind prefix to namespace and return the new Namespace object. The new Namespace is created with `namespace` as IRI. Keyword arguments are passed to the Namespace() constructor. If `namespace` is None, the corresponding prefix is removed. \"\"\" if hasattr ( self . backend , \"bind\" ): self . backend . bind ( prefix , namespace ) if namespace is None : del self . namespaces [ prefix ] return None self . namespaces [ prefix ] = ( namespace if isinstance ( namespace , Namespace ) else Namespace ( namespace , ** kwargs ) ) return self . namespaces [ prefix ] expand_iri ( self , iri ) \u00b6 Return the full IRI if iri is prefixed. Otherwise iri is returned. Source code in tripper/triplestore.py def expand_iri ( self , iri : str ): \"\"\"Return the full IRI if `iri` is prefixed. Otherwise `iri` is returned.\"\"\" match = re . match ( _MATCH_PREFIXED_IRI , iri ) if match : prefix , name = match . groups () if prefix not in self . namespaces : raise NamespaceError ( f \"unknown namespace: { prefix } \" ) return f \" { self . namespaces [ prefix ] }{ name } \" return iri has ( self , subject = None , predicate = None , object = None ) \u00b6 Returns true if the triplestore has any triple matching the give subject, predicate and/or object. Source code in tripper/triplestore.py def has ( self , subject = None , predicate = None , object = None ): # pylint: disable=redefined-builtin \"\"\"Returns true if the triplestore has any triple matching the give subject, predicate and/or object.\"\"\" triple = self . triples (( subject , predicate , object )) try : next ( triple ) except StopIteration : return False return True objects ( self , subject = None , predicate = None ) \u00b6 Returns a generator of objects for given subject and predicate. Source code in tripper/triplestore.py def objects ( self , subject = None , predicate = None ): \"\"\"Returns a generator of objects for given subject and predicate.\"\"\" for _ , _ , o in self . triples (( subject , predicate , None )): yield o parse ( self , source = None , format = None , ** kwargs ) \u00b6 Parse source and add the resulting triples to triplestore. Parameters: Name Type Description Default source File-like object or file name. None format Needed if format can not be inferred from source. None kwargs Keyword arguments passed to the backend. The rdflib backend supports e.g. location (absolute or relative URL) and data (string containing the data to be parsed) arguments. {} Source code in tripper/triplestore.py def parse ( self , source = None , format = None , ** kwargs # pylint: disable=redefined-builtin ): \"\"\"Parse source and add the resulting triples to triplestore. Parameters: source: File-like object or file name. format: Needed if format can not be inferred from source. kwargs: Keyword arguments passed to the backend. The rdflib backend supports e.g. `location` (absolute or relative URL) and `data` (string containing the data to be parsed) arguments. \"\"\" self . _check_method ( \"parse\" ) self . backend . parse ( source = source , format = format , ** kwargs ) if hasattr ( self . backend , \"namespaces\" ): for prefix , namespace in self . backend . namespaces () . items (): if prefix and prefix not in self . namespaces : self . namespaces [ prefix ] = Namespace ( namespace ) predicate_objects ( self , subject = None ) \u00b6 Returns a generator of (predicate, object) tuples for given subject. Source code in tripper/triplestore.py def predicate_objects ( self , subject = None ): \"\"\"Returns a generator of (predicate, object) tuples for given subject.\"\"\" for _ , p , o in self . triples (( subject , None , None )): yield p , o predicates ( self , subject = None , object = None ) \u00b6 Returns a generator of predicates for given subject and object. Source code in tripper/triplestore.py def predicates ( self , subject = None , object = None # pylint: disable=redefined-builtin ): \"\"\"Returns a generator of predicates for given subject and object.\"\"\" for _ , p , _ in self . triples (( subject , None , object )): yield p prefix_iri ( self , iri , require_prefixed = False ) \u00b6 Return prefixed IRI. This is the reverse of expand_iri(). If require_prefixed is true, a NamespaceError exception is raised if no prefix can be found. Source code in tripper/triplestore.py def prefix_iri ( self , iri : str , require_prefixed : bool = False ): \"\"\"Return prefixed IRI. This is the reverse of expand_iri(). If `require_prefixed` is true, a NamespaceError exception is raised if no prefix can be found. \"\"\" if not re . match ( _MATCH_PREFIXED_IRI , iri ): for prefix , namespace in self . namespaces . items (): if iri . startswith ( str ( namespace )): return f \" { prefix } : { iri [ len ( str ( namespace )):] } \" if require_prefixed : raise NamespaceError ( f \"No prefix defined for IRI: { iri } \" ) return iri query ( self , query_object , ** kwargs ) \u00b6 SPARQL query. Source code in tripper/triplestore.py def query ( self , query_object , ** kwargs ): \"\"\"SPARQL query.\"\"\" self . _check_method ( \"query\" ) return self . backend . query ( query_object = query_object , ** kwargs ) remove ( self , triple ) \u00b6 Remove all matching triples from the backend. Source code in tripper/triplestore.py def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" self . backend . remove ( triple ) serialize ( self , destination = None , format = 'turtle' , ** kwargs ) \u00b6 Serialise triplestore. Parameters: Name Type Description Default destination File name or object to write to. If None, the serialisation is returned. None format Format to serialise as. Supported formats, depends on the backend. 'turtle' kwargs Passed to the backend serialize() method. {} Returns: Type Description 'Union[None, str]' Serialized string if destination is None. Source code in tripper/triplestore.py def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise triplestore. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the backend serialize() method. Returns: Serialized string if `destination` is None. \"\"\" self . _check_method ( \"serialize\" ) return self . backend . serialize ( destination = destination , format = format , ** kwargs ) set ( self , triple ) \u00b6 Convenience method to update the value of object. Removes any existing triples for subject and predicate before adding the given triple . Source code in tripper/triplestore.py def set ( self , triple ): \"\"\"Convenience method to update the value of object. Removes any existing triples for subject and predicate before adding the given `triple`. \"\"\" s , p , _ = triple self . remove (( s , p , None )) self . add ( triple ) subject_objects ( self , predicate = None ) \u00b6 Returns a generator of (subject, object) tuples for given predicate. Source code in tripper/triplestore.py def subject_objects ( self , predicate = None ): \"\"\"Returns a generator of (subject, object) tuples for given predicate.\"\"\" for s , _ , o in self . triples (( None , predicate , None )): yield s , o subject_predicates ( self , object = None ) \u00b6 Returns a generator of (subject, predicate) tuples for given object. Source code in tripper/triplestore.py def subject_predicates ( self , object = None ): # pylint: disable=redefined-builtin \"\"\"Returns a generator of (subject, predicate) tuples for given object.\"\"\" for s , p , _ in self . triples (( None , None , object )): yield s , p subjects ( self , predicate = None , object = None ) \u00b6 Returns a generator of subjects for given predicate and object. Source code in tripper/triplestore.py def subjects ( self , predicate = None , object = None # pylint: disable=redefined-builtin ): \"\"\"Returns a generator of subjects for given predicate and object.\"\"\" for s , _ , _ in self . triples (( None , predicate , object )): yield s triples ( self , triple ) \u00b6 Returns a generator over matching triples. Source code in tripper/triplestore.py def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples.\"\"\" return self . backend . triples ( triple ) update ( self , update_object , ** kwargs ) \u00b6 Update triplestore with SPARQL. Source code in tripper/triplestore.py def update ( self , update_object , ** kwargs ): \"\"\"Update triplestore with SPARQL.\"\"\" self . _check_method ( \"update\" ) return self . backend . update ( update_object = update_object , ** kwargs ) value ( self , subject = None , predicate = None , object = None , default = None , any = False ) \u00b6 Return the value for a pair of two criteria. Useful if one knows that there may only be one value. Parameters: Name Type Description Default subject, predicate, object Triple to match. required default Value to return if no matches are found. None any If true, return any matching value, otherwise raise UniquenessError. False Source code in tripper/triplestore.py def value ( self , subject = None , predicate = None , object = None , default = None , any = False ): # pylint: disable=redefined-builtin \"\"\"Return the value for a pair of two criteria. Useful if one knows that there may only be one value. Parameters: subject, predicate, object: Triple to match. default: Value to return if no matches are found. any: If true, return any matching value, otherwise raise UniquenessError. \"\"\" triple = self . triples (( subject , predicate , object )) try : value = next ( triple ) except StopIteration : return default if any : return value try : next ( triple ) except StopIteration : return value else : raise UniquenessError ( \"More than one match\" ) TriplestoreError ( Exception ) \u00b6 Base exception for triplestore errors. Source code in tripper/triplestore.py class TriplestoreError ( Exception ): \"\"\"Base exception for triplestore errors.\"\"\" UniquenessError ( TriplestoreError ) \u00b6 More than one matching triple. Source code in tripper/triplestore.py class UniquenessError ( TriplestoreError ): \"\"\"More than one matching triple.\"\"\" en ( value ) \u00b6 Convenience function that returns value as a plain english literal. Equivalent to Literal(value, lang=\"en\") . Source code in tripper/triplestore.py def en ( value ): # pylint: disable=invalid-name \"\"\"Convenience function that returns value as a plain english literal. Equivalent to``Literal(value, lang=\"en\")``. \"\"\" return Literal ( value , lang = \"en\" ) function_id ( func , length = 4 ) \u00b6 Return a checksum for function func . The returned object is a string of hexadecimal digits. length is the number of bytes in the returned checksum. Since the current implementation is based on the shake_128 algorithm, it make no sense to set length larger than 32 bytes. Source code in tripper/triplestore.py def function_id ( func , length = 4 ): \"\"\"Return a checksum for function `func`. The returned object is a string of hexadecimal digits. `length` is the number of bytes in the returned checksum. Since the current implementation is based on the shake_128 algorithm, it make no sense to set `length` larger than 32 bytes. \"\"\" # return hex(crc32(inspect.getsource(func).encode())).lstrip('0x') return hashlib . shake_128 ( # pylint: disable=too-many-function-args inspect . getsource ( func ) . encode () ) . hexdigest ( length ) infer_iri ( obj ) \u00b6 Return IRI of the individual that stands for object obj . Source code in tripper/triplestore.py def infer_iri ( obj ): \"\"\"Return IRI of the individual that stands for object `obj`.\"\"\" if isinstance ( obj , str ): return obj if hasattr ( obj , \"uri\" ) and obj . uri : # dlite.Metadata or dataclass (or instance with uri) return obj . uri if hasattr ( obj , \"uuid\" ) and obj . uuid : # dlite.Instance or dataclass return obj . uuid if hasattr ( obj , \"schema\" ) and callable ( obj . schema ): # pydantic.BaseModel schema = obj . schema () properties = schema [ \"properties\" ] if \"uri\" in properties and properties [ \"uri\" ]: return properties [ \"uri\" ] if \"uuid\" in properties and properties [ \"uuid\" ]: return properties [ \"uuid\" ] raise TypeError ( \"cannot infer IRI from object {obj!r} \" )","title":"triplestore"},{"location":"api_reference/triplestore/#triplestore","text":"A module encapsulating different triplestores using the strategy design pattern. See https://raw.githubusercontent.com/EMMC-ASBL/OntoFlow/master/triplestore/README.md for an introduction. This module has no dependencies outside the standard library, but the triplestore backends may have. For developers: The usage of s , p , and o represent the different parts of an RDF Triple: subject, predicate, and object.","title":"triplestore"},{"location":"api_reference/triplestore/#tripper.triplestore.Literal","text":"A literal RDF value. Source code in tripper/triplestore.py class Literal ( str ): \"\"\"A literal RDF value.\"\"\" lang : str datatype : \"Any\" def __new__ ( cls , value , lang = None , datatype = None ): string = super () . __new__ ( cls , value ) if lang : if datatype : raise TypeError ( \"A literal can only have one of `lang` or `datatype`.\" ) string . lang = str ( lang ) string . datatype = None else : string . lang = None if datatype : string . datatype = { str : XSD . string , bool : XSD . boolean , int : XSD . integer , float : XSD . double , bytes : XSD . hexBinary , bytearray : XSD . hexBinary , datetime : XSD . dateTime , } . get ( datatype , datatype ) elif isinstance ( value , str ): string . datatype = None elif isinstance ( value , bool ): string . datatype = XSD . boolean elif isinstance ( value , int ): string . datatype = XSD . integer elif isinstance ( value , float ): string . datatype = XSD . double elif isinstance ( value , ( bytes , bytearray )): string = value . hex () string . datatype = XSD . hexBinary elif isinstance ( value , datetime ): string . datatype = XSD . dateTime # TODO: # - XSD.base64Binary # - XSD.byte, XSD.unsignedByte else : string . datatype = None return string def __repr__ ( self ): lang = f \", lang=' { self . lang } '\" if self . lang else \"\" datatype = f \", datatype=' { self . datatype } '\" if self . datatype else \"\" return f \"Literal(' { self } ' { lang }{ datatype } )\" value = property ( fget = lambda self : self . to_python (), doc = \"Appropriate python datatype derived from this RDF literal.\" , ) def to_python ( self ): \"\"\"Returns an appropriate python datatype derived from this RDF literal.\"\"\" value = str ( self ) if self . datatype == XSD . boolean : value = bool ( self ) elif self . datatype in ( XSD . integer , XSD . int , XSD . short , XSD . long , XSD . nonPositiveInteger , XSD . negativeInteger , XSD . nonNegativeInteger , XSD . unsignedInt , XSD . unsignedShort , XSD . unsignedLong , XSD . byte , XSD . unsignedByte , ): value = int ( self ) elif self . datatype in ( XSD . double , XSD . decimal , XSD . dataTimeStamp , OWL . real , OWL . rational , ): value = float ( self ) elif self . datatype == XSD . hexBinary : value = self . encode () elif self . datatype == XSD . dateTime : value = datetime . fromisoformat ( self ) elif self . datatype and self . datatype not in ( RDF . PlainLiteral , RDF . XMLLiteral , RDFS . Literal , XSD . anyURI , XSD . language , XSD . Name , XSD . NMName , XSD . normalizedString , XSD . string , XSD . token , XSD . NMTOKEN , ): warnings . warn ( f \"unknown datatype: { self . datatype } - assuming string\" ) return value def n3 ( self ): # pylint: disable=invalid-name \"\"\"Returns a representation in n3 format.\"\"\" if self . lang : return f '\" { self } \"@ { self . lang } ' if self . datatype : return f '\" { self } \"^^ { self . datatype } ' return f '\" { self } \"'","title":"Literal"},{"location":"api_reference/triplestore/#tripper.triplestore.Literal.value","text":"Appropriate python datatype derived from this RDF literal.","title":"value"},{"location":"api_reference/triplestore/#tripper.triplestore.Literal.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in tripper/triplestore.py def __new__ ( cls , value , lang = None , datatype = None ): string = super () . __new__ ( cls , value ) if lang : if datatype : raise TypeError ( \"A literal can only have one of `lang` or `datatype`.\" ) string . lang = str ( lang ) string . datatype = None else : string . lang = None if datatype : string . datatype = { str : XSD . string , bool : XSD . boolean , int : XSD . integer , float : XSD . double , bytes : XSD . hexBinary , bytearray : XSD . hexBinary , datetime : XSD . dateTime , } . get ( datatype , datatype ) elif isinstance ( value , str ): string . datatype = None elif isinstance ( value , bool ): string . datatype = XSD . boolean elif isinstance ( value , int ): string . datatype = XSD . integer elif isinstance ( value , float ): string . datatype = XSD . double elif isinstance ( value , ( bytes , bytearray )): string = value . hex () string . datatype = XSD . hexBinary elif isinstance ( value , datetime ): string . datatype = XSD . dateTime # TODO: # - XSD.base64Binary # - XSD.byte, XSD.unsignedByte else : string . datatype = None return string","title":"__new__()"},{"location":"api_reference/triplestore/#tripper.triplestore.Literal.n3","text":"Returns a representation in n3 format. Source code in tripper/triplestore.py def n3 ( self ): # pylint: disable=invalid-name \"\"\"Returns a representation in n3 format.\"\"\" if self . lang : return f '\" { self } \"@ { self . lang } ' if self . datatype : return f '\" { self } \"^^ { self . datatype } ' return f '\" { self } \"'","title":"n3()"},{"location":"api_reference/triplestore/#tripper.triplestore.Literal.to_python","text":"Returns an appropriate python datatype derived from this RDF literal. Source code in tripper/triplestore.py def to_python ( self ): \"\"\"Returns an appropriate python datatype derived from this RDF literal.\"\"\" value = str ( self ) if self . datatype == XSD . boolean : value = bool ( self ) elif self . datatype in ( XSD . integer , XSD . int , XSD . short , XSD . long , XSD . nonPositiveInteger , XSD . negativeInteger , XSD . nonNegativeInteger , XSD . unsignedInt , XSD . unsignedShort , XSD . unsignedLong , XSD . byte , XSD . unsignedByte , ): value = int ( self ) elif self . datatype in ( XSD . double , XSD . decimal , XSD . dataTimeStamp , OWL . real , OWL . rational , ): value = float ( self ) elif self . datatype == XSD . hexBinary : value = self . encode () elif self . datatype == XSD . dateTime : value = datetime . fromisoformat ( self ) elif self . datatype and self . datatype not in ( RDF . PlainLiteral , RDF . XMLLiteral , RDFS . Literal , XSD . anyURI , XSD . language , XSD . Name , XSD . NMName , XSD . normalizedString , XSD . string , XSD . token , XSD . NMTOKEN , ): warnings . warn ( f \"unknown datatype: { self . datatype } - assuming string\" ) return value","title":"to_python()"},{"location":"api_reference/triplestore/#tripper.triplestore.Namespace","text":"Represent a namespace. Parameters: Name Type Description Default iri IRI of namespace to represent. required label_annotations Sequence of label annotations. If given, check the underlying ontology during attribute access if the name correspond to a label. The label annotations should be ordered from highest to lowest precedense. If True is provided, label_annotations is set to (SKOS.prefLabel, RDF.label, SKOS.altLabel) . () check Whether to check underlying ontology if the IRI exists during attribute access. If true, NoSuchIRIError will be raised if the IRI does not exist in this namespace. False cachemode Should be one of: - Namespace.NO_CACHE: Turn off caching. - Namespace.USE_CACHE: Cache attributes as they are looked up. - Namespace.ONLY_CACHE: Cache all names at initialisation time. Do not access the triplestore after that. Default is NO_CACHE if neither label_annotations or check is given, otherwise USE_CACHE . -1 triplestore Use this triplestore for label lookup and checking. If not given, and either label_annotations or check are enabled, a new rdflib triplestore will be created. None triplestore_url Alternative URL to use for loading the underlying ontology if triplestore is not given. Defaults to iri . None Source code in tripper/triplestore.py class Namespace : \"\"\"Represent a namespace. Arguments: iri: IRI of namespace to represent. label_annotations: Sequence of label annotations. If given, check the underlying ontology during attribute access if the name correspond to a label. The label annotations should be ordered from highest to lowest precedense. If True is provided, `label_annotations` is set to ``(SKOS.prefLabel, RDF.label, SKOS.altLabel)``. check: Whether to check underlying ontology if the IRI exists during attribute access. If true, NoSuchIRIError will be raised if the IRI does not exist in this namespace. cachemode: Should be one of: - Namespace.NO_CACHE: Turn off caching. - Namespace.USE_CACHE: Cache attributes as they are looked up. - Namespace.ONLY_CACHE: Cache all names at initialisation time. Do not access the triplestore after that. Default is `NO_CACHE` if neither `label_annotations` or `check` is given, otherwise `USE_CACHE`. triplestore: Use this triplestore for label lookup and checking. If not given, and either `label_annotations` or `check` are enabled, a new rdflib triplestore will be created. triplestore_url: Alternative URL to use for loading the underlying ontology if `triplestore` is not given. Defaults to `iri`. \"\"\" NO_CACHE = 0 USE_CACHE = 1 ONLY_CACHE = 2 __slots__ = ( \"_iri\" , \"_label_annotations\" , \"_check\" , \"_cache\" , \"_triplestore\" , ) def __init__ ( self , iri , label_annotations = (), check = False , cachemode =- 1 , triplestore = None , triplestore_url = None , ): if label_annotations is True : label_annotations = ( SKOS . prefLabel , RDF . label , SKOS . altLabel ) self . _iri = str ( iri ) self . _label_annotations = tuple ( label_annotations ) self . _check = bool ( check ) need_triplestore = bool ( check or label_annotations ) if cachemode == - 1 : cachemode = Namespace . ONLY_CACHE if need_triplestore else Namespace . NO_CACHE if need_triplestore and triplestore is None : url = triplestore_url if triplestore_url else iri triplestore = Triplestore ( \"rdflib\" , base_iri = iri ) triplestore . parse ( url ) self . _cache = {} if cachemode != Namespace . NO_CACHE else None # # FIXME: # Change this to only assigning the triplestore if cachemode is # ONLY_CACHE when we figure out a good way to pre-populate the # cache with IRIs from the triplestore. # # self._triplestore = ( # triplestore if cachemode != Namespace.ONLY_CACHE else None # ) self . _triplestore = triplestore if need_triplestore else None if cachemode != Namespace . NO_CACHE : self . _update_cache ( triplestore ) def _update_cache ( self , triplestore = None ): \"\"\"Update the internal cache from `triplestore`.\"\"\" if not triplestore : triplestore = self . _triplestore if not triplestore : raise NamespaceError ( \"`triplestore` argument needed for updating the cache\" ) if self . _cache is None : self . _cache = {} # Add (label, full_iri) pairs to cache for label in reversed ( self . _label_annotations ): self . _cache . update ( ( o , s ) for s , o in triplestore . subject_objects ( label ) if s . startswith ( self . _iri ) ) # Add (name, full_iri) pairs to cache # Currently we only check concepts that defines RDFS.isDefinedBy # relations. # Is there an efficient way to loop over all IRIs in this namespace? self . _cache . update ( ( s [ len ( self . _iri ) :], s ) for s in triplestore . subjects ( RDFS . isDefinedBy , self . _iri ) if s . startswith ( self . _iri ) ) def __getattr__ ( self , name ): if self . _cache and name in self . _cache : return self . _cache [ name ] if self . _triplestore : # Check if ``iri = self._iri + name`` is in the triplestore. # If so, add it to the cache. # We only need to check that generator returned by # `self._triplestore.predicate_objects(iri)` is non-empty. iri = self . _iri + name predicate_object = self . _triplestore . predicate_objects ( iri ) try : predicate_object . __next__ () except StopIteration : pass else : if self . _cache is not None : self . _cache [ name ] = iri return iri # Check for label annotations matching `name`. for label in self . _label_annotations : for s , o in self . _triplestore . subject_objects ( label ): if o == name and s . startswith ( self . _iri ): if self . _cache is not None : self . _cache [ name ] = s return s if self . _check : raise NoSuchIRIError ( self . _iri + name ) return self . _iri + name def __getitem__ ( self , key ): return self . __getattr__ ( key ) def __repr__ ( self ): return f \"Namespace( { self . _iri } )\" def __str__ ( self ): return self . _iri def __add__ ( self , other ): return self . _iri + str ( other )","title":"Namespace"},{"location":"api_reference/triplestore/#tripper.triplestore.NamespaceError","text":"Namespace error. Source code in tripper/triplestore.py class NamespaceError ( TriplestoreError ): \"\"\"Namespace error.\"\"\"","title":"NamespaceError"},{"location":"api_reference/triplestore/#tripper.triplestore.NoSuchIRIError","text":"Namespace has no such IRI. Source code in tripper/triplestore.py class NoSuchIRIError ( NamespaceError ): \"\"\"Namespace has no such IRI.\"\"\"","title":"NoSuchIRIError"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore","text":"Provides a common frontend to a range of triplestore backends. Source code in tripper/triplestore.py class Triplestore : \"\"\"Provides a common frontend to a range of triplestore backends.\"\"\" default_namespaces = { \"xml\" : XML , \"rdf\" : RDF , \"rdfs\" : RDFS , \"xsd\" : XSD , \"owl\" : OWL , # \"skos\": SKOS, # \"dc\": DC, # \"dcterms\": DCTERMS, # \"foaf\": FOAF, # \"doap\": DOAP, # \"fno\": FNO, # \"emmo\": EMMO, # \"map\": MAP, # \"dm\": DM, } def __init__ ( self , backend : str , base_iri : str = None , ** kwargs ): \"\"\"Initialise triplestore using the backend with the given name. Parameters: backend: Name of the backend module. base_iri: Base IRI used by the add_function() method when adding new triples. kwargs: Keyword arguments passed to the backend's __init__() method. \"\"\" module = import_module ( backend if \".\" in backend else f \"tripper.backends. { backend } \" ) cls = getattr ( module , backend . title () + \"Strategy\" ) self . base_iri = base_iri self . namespaces : \"Dict[str, Namespace]\" = {} self . backend_name = backend self . backend = cls ( base_iri = base_iri , ** kwargs ) # Keep functions in the triplestore for convienence even though # they usually do not belong to the triplestore per se. self . function_repo : \"Dict[str, Union[float, Callable[[], float]]]\" = {} for prefix , namespace in self . default_namespaces . items (): self . bind ( prefix , namespace ) # Methods implemented by backend # ------------------------------ def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples.\"\"\" return self . backend . triples ( triple ) def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" self . backend . add_triples ( triples ) def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" self . backend . remove ( triple ) # Methods optionally implemented by backend # ----------------------------------------- def parse ( self , source = None , format = None , ** kwargs # pylint: disable=redefined-builtin ): \"\"\"Parse source and add the resulting triples to triplestore. Parameters: source: File-like object or file name. format: Needed if format can not be inferred from source. kwargs: Keyword arguments passed to the backend. The rdflib backend supports e.g. `location` (absolute or relative URL) and `data` (string containing the data to be parsed) arguments. \"\"\" self . _check_method ( \"parse\" ) self . backend . parse ( source = source , format = format , ** kwargs ) if hasattr ( self . backend , \"namespaces\" ): for prefix , namespace in self . backend . namespaces () . items (): if prefix and prefix not in self . namespaces : self . namespaces [ prefix ] = Namespace ( namespace ) def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise triplestore. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the backend serialize() method. Returns: Serialized string if `destination` is None. \"\"\" self . _check_method ( \"serialize\" ) return self . backend . serialize ( destination = destination , format = format , ** kwargs ) def query ( self , query_object , ** kwargs ): \"\"\"SPARQL query.\"\"\" self . _check_method ( \"query\" ) return self . backend . query ( query_object = query_object , ** kwargs ) def update ( self , update_object , ** kwargs ): \"\"\"Update triplestore with SPARQL.\"\"\" self . _check_method ( \"update\" ) return self . backend . update ( update_object = update_object , ** kwargs ) def bind ( self , prefix : str , namespace : \"Union[str, Namespace]\" , ** kwargs ): \"\"\"Bind prefix to namespace and return the new Namespace object. The new Namespace is created with `namespace` as IRI. Keyword arguments are passed to the Namespace() constructor. If `namespace` is None, the corresponding prefix is removed. \"\"\" if hasattr ( self . backend , \"bind\" ): self . backend . bind ( prefix , namespace ) if namespace is None : del self . namespaces [ prefix ] return None self . namespaces [ prefix ] = ( namespace if isinstance ( namespace , Namespace ) else Namespace ( namespace , ** kwargs ) ) return self . namespaces [ prefix ] # Convenient methods # ------------------ # These methods are modelled after rdflib and provide some convinient # interfaces to the triples(), add_triples() and remove() methods # implemented by all backends. def _check_method ( self , name ): \"\"\"Check that backend implements the given method.\"\"\" if not hasattr ( self . backend , name ): raise NotImplementedError ( f \"Triplestore backend { self . backend_name !r} do not implement a \" f '\" { name } ()\" method.' ) def add ( self , triple : \"Triple\" ): \"\"\"Add `triple` to triplestore.\"\"\" self . add_triples ([ triple ]) def value ( self , subject = None , predicate = None , object = None , default = None , any = False ): # pylint: disable=redefined-builtin \"\"\"Return the value for a pair of two criteria. Useful if one knows that there may only be one value. Parameters: subject, predicate, object: Triple to match. default: Value to return if no matches are found. any: If true, return any matching value, otherwise raise UniquenessError. \"\"\" triple = self . triples (( subject , predicate , object )) try : value = next ( triple ) except StopIteration : return default if any : return value try : next ( triple ) except StopIteration : return value else : raise UniquenessError ( \"More than one match\" ) def subjects ( self , predicate = None , object = None # pylint: disable=redefined-builtin ): \"\"\"Returns a generator of subjects for given predicate and object.\"\"\" for s , _ , _ in self . triples (( None , predicate , object )): yield s def predicates ( self , subject = None , object = None # pylint: disable=redefined-builtin ): \"\"\"Returns a generator of predicates for given subject and object.\"\"\" for _ , p , _ in self . triples (( subject , None , object )): yield p def objects ( self , subject = None , predicate = None ): \"\"\"Returns a generator of objects for given subject and predicate.\"\"\" for _ , _ , o in self . triples (( subject , predicate , None )): yield o def subject_predicates ( self , object = None ): # pylint: disable=redefined-builtin \"\"\"Returns a generator of (subject, predicate) tuples for given object.\"\"\" for s , p , _ in self . triples (( None , None , object )): yield s , p def subject_objects ( self , predicate = None ): \"\"\"Returns a generator of (subject, object) tuples for given predicate.\"\"\" for s , _ , o in self . triples (( None , predicate , None )): yield s , o def predicate_objects ( self , subject = None ): \"\"\"Returns a generator of (predicate, object) tuples for given subject.\"\"\" for _ , p , o in self . triples (( subject , None , None )): yield p , o def set ( self , triple ): \"\"\"Convenience method to update the value of object. Removes any existing triples for subject and predicate before adding the given `triple`. \"\"\" s , p , _ = triple self . remove (( s , p , None )) self . add ( triple ) def has ( self , subject = None , predicate = None , object = None ): # pylint: disable=redefined-builtin \"\"\"Returns true if the triplestore has any triple matching the give subject, predicate and/or object.\"\"\" triple = self . triples (( subject , predicate , object )) try : next ( triple ) except StopIteration : return False return True # Methods providing additional functionality # ------------------------------------------ def expand_iri ( self , iri : str ): \"\"\"Return the full IRI if `iri` is prefixed. Otherwise `iri` is returned.\"\"\" match = re . match ( _MATCH_PREFIXED_IRI , iri ) if match : prefix , name = match . groups () if prefix not in self . namespaces : raise NamespaceError ( f \"unknown namespace: { prefix } \" ) return f \" { self . namespaces [ prefix ] }{ name } \" return iri def prefix_iri ( self , iri : str , require_prefixed : bool = False ): \"\"\"Return prefixed IRI. This is the reverse of expand_iri(). If `require_prefixed` is true, a NamespaceError exception is raised if no prefix can be found. \"\"\" if not re . match ( _MATCH_PREFIXED_IRI , iri ): for prefix , namespace in self . namespaces . items (): if iri . startswith ( str ( namespace )): return f \" { prefix } : { iri [ len ( str ( namespace )):] } \" if require_prefixed : raise NamespaceError ( f \"No prefix defined for IRI: { iri } \" ) return iri def add_mapsTo ( # pylint: disable=invalid-name self , target : str , source : str , property_name : str = None , cost : \"Union[float, Callable]\" = None , target_cost : bool = True , ): \"\"\"Add 'mapsTo' relation to triplestore. Parameters: target: IRI of target ontological concept. source: Source IRI (or entity object). property_name: Name of property if `source` is an entity or an entity IRI. cost: User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the value of the mapped quantity as input and returning the cost as a float. target_cost: Whether the cost is assigned to mapping steps that have `target` as output. \"\"\" self . bind ( \"map\" , MAP ) if not property_name and not isinstance ( source , str ): raise TriplestoreError ( \"`property_name` is required when `target` is not a string.\" ) target = self . expand_iri ( target ) source = self . expand_iri ( infer_iri ( source )) if property_name : source = f \" { source } # { property_name } \" self . add (( source , MAP . mapsTo , target )) if cost is not None : dest = target if target_cost else source self . _add_cost ( cost , dest ) def add_function ( self , func : Callable , expects : \"Union[str, Sequence, Mapping]\" = (), returns : \"Union[str, Sequence]\" = (), base_iri : str = None , standard : str = \"fno\" , cost : \"Union[float, Callable]\" = None , ): \"\"\"Inspect function and add triples describing it to the triplestore. Parameters: func: Function to describe. expects: Sequence of IRIs to ontological concepts corresponding to positional arguments of `func`. May also be given as a dict mapping argument names to corresponding ontological IRIs. returns: IRI of return value. May also be given as a sequence of IRIs, if multiple values are returned. base_iri: Base of the IRI representing the function in the knowledge base. Defaults to the base IRI of the triplestore. standard: Name of ontology to use when describing the function. Defaults to the Function Ontology (FnO). cost: User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the same arguments as `func` returning the cost as a float. Returns: func_iri: IRI of the added function. \"\"\" if isinstance ( expects , str ): expects = [ expects ] if isinstance ( returns , str ): returns = [ returns ] method = getattr ( self , f \"_add_function_ { standard } \" ) func_iri = method ( func , expects , returns , base_iri ) self . function_repo [ func_iri ] = func if cost is not None : for dest_iri in returns : self . _add_cost ( cost , dest_iri ) return func_iri def _add_cost ( self , cost : \"Union[float, Callable[[], float]]\" , dest_iri ): \"\"\"Help function that adds `cost` to destination IRI `dest_iri`. `cost` should be either a float or a Callable returning a float. If `cost` is a callable it is just referred to with a literal id and is not ontologically described as a function. The expected input arguments depends on the context, which is why this function is not part of the public API. Use the add_mapsTo() and add_function() methods instead. \"\"\" if self . has ( dest_iri , DM . hasCost ): warnings . warn ( f \"A cost is already assigned to IRI: { dest_iri } \" ) elif callable ( cost ): cost_id = f \"cost_function { function_id ( cost ) } \" self . add (( dest_iri , DM . hasCost , Literal ( cost_id ))) self . function_repo [ cost_id ] = cost else : self . add (( dest_iri , DM . hasCost , Literal ( cost ))) def _add_function_fno ( self , func , expects , returns , base_iri ): \"\"\"Implementing add_function() for FnO.\"\"\" self . bind ( \"fno\" , FNO ) self . bind ( \"dcterms\" , DCTERMS ) self . bind ( \"map\" , MAP ) if base_iri is None : base_iri = self . base_iri if self . base_iri else \":\" fid = function_id ( func ) # Function id doc_string = inspect . getdoc ( func ) func_iri = f \" { base_iri }{ func . __name__ } _ { fid } \" parlist = f \"_: { func . __name__ }{ fid } parlist\" outlist = f \"_: { func . __name__ }{ fid } outlist\" self . add (( func_iri , RDF . type , FNO . Function )) self . add (( func_iri , FNO . expects , parlist )) self . add (( func_iri , FNO . returns , outlist )) if doc_string : self . add (( func_iri , DCTERMS . description , en ( doc_string ))) if isinstance ( expects , Sequence ): items = list ( zip ( expects , inspect . signature ( func ) . parameters )) else : items = [( expects [ par ], par ) for par in inspect . signature ( func ) . parameters ] lst = parlist for i , ( iri , parname ) in enumerate ( items ): lst_next = f \" { parlist }{ i + 2 } \" if i < len ( items ) - 1 else RDF . nil par = f \" { func_iri } _parameter { i + 1 } _ { parname } \" self . add (( par , RDF . type , FNO . Parameter )) self . add (( par , RDFS . label , en ( parname ))) self . add (( par , MAP . mapsTo , iri )) self . add (( lst , RDF . first , par )) self . add (( lst , RDF . rest , lst_next )) lst = lst_next lst = outlist for i , iri in enumerate ( returns ): lst_next = f \" { outlist }{ i + 2 } \" if i < len ( returns ) - 1 else RDF . nil val = f \" { func_iri } _output { i + 1 } \" self . add (( val , RDF . type , FNO . Output )) self . add (( val , MAP . mapsTo , iri )) self . add (( lst , RDF . first , val )) self . add (( lst , RDF . rest , lst_next )) lst = lst_next return func_iri","title":"Triplestore"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.__init__","text":"Initialise triplestore using the backend with the given name. Parameters: Name Type Description Default backend str Name of the backend module. required base_iri str Base IRI used by the add_function() method when adding new triples. None kwargs Keyword arguments passed to the backend's init () method. {} Source code in tripper/triplestore.py def __init__ ( self , backend : str , base_iri : str = None , ** kwargs ): \"\"\"Initialise triplestore using the backend with the given name. Parameters: backend: Name of the backend module. base_iri: Base IRI used by the add_function() method when adding new triples. kwargs: Keyword arguments passed to the backend's __init__() method. \"\"\" module = import_module ( backend if \".\" in backend else f \"tripper.backends. { backend } \" ) cls = getattr ( module , backend . title () + \"Strategy\" ) self . base_iri = base_iri self . namespaces : \"Dict[str, Namespace]\" = {} self . backend_name = backend self . backend = cls ( base_iri = base_iri , ** kwargs ) # Keep functions in the triplestore for convienence even though # they usually do not belong to the triplestore per se. self . function_repo : \"Dict[str, Union[float, Callable[[], float]]]\" = {} for prefix , namespace in self . default_namespaces . items (): self . bind ( prefix , namespace )","title":"__init__()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.add","text":"Add triple to triplestore. Source code in tripper/triplestore.py def add ( self , triple : \"Triple\" ): \"\"\"Add `triple` to triplestore.\"\"\" self . add_triples ([ triple ])","title":"add()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.add_function","text":"Inspect function and add triples describing it to the triplestore. Parameters: Name Type Description Default func Callable Function to describe. required expects 'Union[str, Sequence, Mapping]' Sequence of IRIs to ontological concepts corresponding to positional arguments of func . May also be given as a dict mapping argument names to corresponding ontological IRIs. () returns 'Union[str, Sequence]' IRI of return value. May also be given as a sequence of IRIs, if multiple values are returned. () base_iri str Base of the IRI representing the function in the knowledge base. Defaults to the base IRI of the triplestore. None standard str Name of ontology to use when describing the function. Defaults to the Function Ontology (FnO). 'fno' cost 'Union[float, Callable]' User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the same arguments as func returning the cost as a float. None Returns: Type Description func_iri IRI of the added function. Source code in tripper/triplestore.py def add_function ( self , func : Callable , expects : \"Union[str, Sequence, Mapping]\" = (), returns : \"Union[str, Sequence]\" = (), base_iri : str = None , standard : str = \"fno\" , cost : \"Union[float, Callable]\" = None , ): \"\"\"Inspect function and add triples describing it to the triplestore. Parameters: func: Function to describe. expects: Sequence of IRIs to ontological concepts corresponding to positional arguments of `func`. May also be given as a dict mapping argument names to corresponding ontological IRIs. returns: IRI of return value. May also be given as a sequence of IRIs, if multiple values are returned. base_iri: Base of the IRI representing the function in the knowledge base. Defaults to the base IRI of the triplestore. standard: Name of ontology to use when describing the function. Defaults to the Function Ontology (FnO). cost: User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the same arguments as `func` returning the cost as a float. Returns: func_iri: IRI of the added function. \"\"\" if isinstance ( expects , str ): expects = [ expects ] if isinstance ( returns , str ): returns = [ returns ] method = getattr ( self , f \"_add_function_ { standard } \" ) func_iri = method ( func , expects , returns , base_iri ) self . function_repo [ func_iri ] = func if cost is not None : for dest_iri in returns : self . _add_cost ( cost , dest_iri ) return func_iri","title":"add_function()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.add_mapsTo","text":"Add 'mapsTo' relation to triplestore. Parameters: Name Type Description Default target str IRI of target ontological concept. required source str Source IRI (or entity object). required property_name str Name of property if source is an entity or an entity IRI. None cost 'Union[float, Callable]' User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the value of the mapped quantity as input and returning the cost as a float. None target_cost bool Whether the cost is assigned to mapping steps that have target as output. True Source code in tripper/triplestore.py def add_mapsTo ( # pylint: disable=invalid-name self , target : str , source : str , property_name : str = None , cost : \"Union[float, Callable]\" = None , target_cost : bool = True , ): \"\"\"Add 'mapsTo' relation to triplestore. Parameters: target: IRI of target ontological concept. source: Source IRI (or entity object). property_name: Name of property if `source` is an entity or an entity IRI. cost: User-defined cost of following this mapping relation represented as a float. It may be given either as a float or as a callable taking the value of the mapped quantity as input and returning the cost as a float. target_cost: Whether the cost is assigned to mapping steps that have `target` as output. \"\"\" self . bind ( \"map\" , MAP ) if not property_name and not isinstance ( source , str ): raise TriplestoreError ( \"`property_name` is required when `target` is not a string.\" ) target = self . expand_iri ( target ) source = self . expand_iri ( infer_iri ( source )) if property_name : source = f \" { source } # { property_name } \" self . add (( source , MAP . mapsTo , target )) if cost is not None : dest = target if target_cost else source self . _add_cost ( cost , dest )","title":"add_mapsTo()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.add_triples","text":"Add a sequence of triples. Source code in tripper/triplestore.py def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" self . backend . add_triples ( triples )","title":"add_triples()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.bind","text":"Bind prefix to namespace and return the new Namespace object. The new Namespace is created with namespace as IRI. Keyword arguments are passed to the Namespace() constructor. If namespace is None, the corresponding prefix is removed. Source code in tripper/triplestore.py def bind ( self , prefix : str , namespace : \"Union[str, Namespace]\" , ** kwargs ): \"\"\"Bind prefix to namespace and return the new Namespace object. The new Namespace is created with `namespace` as IRI. Keyword arguments are passed to the Namespace() constructor. If `namespace` is None, the corresponding prefix is removed. \"\"\" if hasattr ( self . backend , \"bind\" ): self . backend . bind ( prefix , namespace ) if namespace is None : del self . namespaces [ prefix ] return None self . namespaces [ prefix ] = ( namespace if isinstance ( namespace , Namespace ) else Namespace ( namespace , ** kwargs ) ) return self . namespaces [ prefix ]","title":"bind()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.expand_iri","text":"Return the full IRI if iri is prefixed. Otherwise iri is returned. Source code in tripper/triplestore.py def expand_iri ( self , iri : str ): \"\"\"Return the full IRI if `iri` is prefixed. Otherwise `iri` is returned.\"\"\" match = re . match ( _MATCH_PREFIXED_IRI , iri ) if match : prefix , name = match . groups () if prefix not in self . namespaces : raise NamespaceError ( f \"unknown namespace: { prefix } \" ) return f \" { self . namespaces [ prefix ] }{ name } \" return iri","title":"expand_iri()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.has","text":"Returns true if the triplestore has any triple matching the give subject, predicate and/or object. Source code in tripper/triplestore.py def has ( self , subject = None , predicate = None , object = None ): # pylint: disable=redefined-builtin \"\"\"Returns true if the triplestore has any triple matching the give subject, predicate and/or object.\"\"\" triple = self . triples (( subject , predicate , object )) try : next ( triple ) except StopIteration : return False return True","title":"has()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.objects","text":"Returns a generator of objects for given subject and predicate. Source code in tripper/triplestore.py def objects ( self , subject = None , predicate = None ): \"\"\"Returns a generator of objects for given subject and predicate.\"\"\" for _ , _ , o in self . triples (( subject , predicate , None )): yield o","title":"objects()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.parse","text":"Parse source and add the resulting triples to triplestore. Parameters: Name Type Description Default source File-like object or file name. None format Needed if format can not be inferred from source. None kwargs Keyword arguments passed to the backend. The rdflib backend supports e.g. location (absolute or relative URL) and data (string containing the data to be parsed) arguments. {} Source code in tripper/triplestore.py def parse ( self , source = None , format = None , ** kwargs # pylint: disable=redefined-builtin ): \"\"\"Parse source and add the resulting triples to triplestore. Parameters: source: File-like object or file name. format: Needed if format can not be inferred from source. kwargs: Keyword arguments passed to the backend. The rdflib backend supports e.g. `location` (absolute or relative URL) and `data` (string containing the data to be parsed) arguments. \"\"\" self . _check_method ( \"parse\" ) self . backend . parse ( source = source , format = format , ** kwargs ) if hasattr ( self . backend , \"namespaces\" ): for prefix , namespace in self . backend . namespaces () . items (): if prefix and prefix not in self . namespaces : self . namespaces [ prefix ] = Namespace ( namespace )","title":"parse()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.predicate_objects","text":"Returns a generator of (predicate, object) tuples for given subject. Source code in tripper/triplestore.py def predicate_objects ( self , subject = None ): \"\"\"Returns a generator of (predicate, object) tuples for given subject.\"\"\" for _ , p , o in self . triples (( subject , None , None )): yield p , o","title":"predicate_objects()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.predicates","text":"Returns a generator of predicates for given subject and object. Source code in tripper/triplestore.py def predicates ( self , subject = None , object = None # pylint: disable=redefined-builtin ): \"\"\"Returns a generator of predicates for given subject and object.\"\"\" for _ , p , _ in self . triples (( subject , None , object )): yield p","title":"predicates()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.prefix_iri","text":"Return prefixed IRI. This is the reverse of expand_iri(). If require_prefixed is true, a NamespaceError exception is raised if no prefix can be found. Source code in tripper/triplestore.py def prefix_iri ( self , iri : str , require_prefixed : bool = False ): \"\"\"Return prefixed IRI. This is the reverse of expand_iri(). If `require_prefixed` is true, a NamespaceError exception is raised if no prefix can be found. \"\"\" if not re . match ( _MATCH_PREFIXED_IRI , iri ): for prefix , namespace in self . namespaces . items (): if iri . startswith ( str ( namespace )): return f \" { prefix } : { iri [ len ( str ( namespace )):] } \" if require_prefixed : raise NamespaceError ( f \"No prefix defined for IRI: { iri } \" ) return iri","title":"prefix_iri()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.query","text":"SPARQL query. Source code in tripper/triplestore.py def query ( self , query_object , ** kwargs ): \"\"\"SPARQL query.\"\"\" self . _check_method ( \"query\" ) return self . backend . query ( query_object = query_object , ** kwargs )","title":"query()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.remove","text":"Remove all matching triples from the backend. Source code in tripper/triplestore.py def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" self . backend . remove ( triple )","title":"remove()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.serialize","text":"Serialise triplestore. Parameters: Name Type Description Default destination File name or object to write to. If None, the serialisation is returned. None format Format to serialise as. Supported formats, depends on the backend. 'turtle' kwargs Passed to the backend serialize() method. {} Returns: Type Description 'Union[None, str]' Serialized string if destination is None. Source code in tripper/triplestore.py def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise triplestore. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the backend serialize() method. Returns: Serialized string if `destination` is None. \"\"\" self . _check_method ( \"serialize\" ) return self . backend . serialize ( destination = destination , format = format , ** kwargs )","title":"serialize()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.set","text":"Convenience method to update the value of object. Removes any existing triples for subject and predicate before adding the given triple . Source code in tripper/triplestore.py def set ( self , triple ): \"\"\"Convenience method to update the value of object. Removes any existing triples for subject and predicate before adding the given `triple`. \"\"\" s , p , _ = triple self . remove (( s , p , None )) self . add ( triple )","title":"set()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.subject_objects","text":"Returns a generator of (subject, object) tuples for given predicate. Source code in tripper/triplestore.py def subject_objects ( self , predicate = None ): \"\"\"Returns a generator of (subject, object) tuples for given predicate.\"\"\" for s , _ , o in self . triples (( None , predicate , None )): yield s , o","title":"subject_objects()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.subject_predicates","text":"Returns a generator of (subject, predicate) tuples for given object. Source code in tripper/triplestore.py def subject_predicates ( self , object = None ): # pylint: disable=redefined-builtin \"\"\"Returns a generator of (subject, predicate) tuples for given object.\"\"\" for s , p , _ in self . triples (( None , None , object )): yield s , p","title":"subject_predicates()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.subjects","text":"Returns a generator of subjects for given predicate and object. Source code in tripper/triplestore.py def subjects ( self , predicate = None , object = None # pylint: disable=redefined-builtin ): \"\"\"Returns a generator of subjects for given predicate and object.\"\"\" for s , _ , _ in self . triples (( None , predicate , object )): yield s","title":"subjects()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.triples","text":"Returns a generator over matching triples. Source code in tripper/triplestore.py def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples.\"\"\" return self . backend . triples ( triple )","title":"triples()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.update","text":"Update triplestore with SPARQL. Source code in tripper/triplestore.py def update ( self , update_object , ** kwargs ): \"\"\"Update triplestore with SPARQL.\"\"\" self . _check_method ( \"update\" ) return self . backend . update ( update_object = update_object , ** kwargs )","title":"update()"},{"location":"api_reference/triplestore/#tripper.triplestore.Triplestore.value","text":"Return the value for a pair of two criteria. Useful if one knows that there may only be one value. Parameters: Name Type Description Default subject, predicate, object Triple to match. required default Value to return if no matches are found. None any If true, return any matching value, otherwise raise UniquenessError. False Source code in tripper/triplestore.py def value ( self , subject = None , predicate = None , object = None , default = None , any = False ): # pylint: disable=redefined-builtin \"\"\"Return the value for a pair of two criteria. Useful if one knows that there may only be one value. Parameters: subject, predicate, object: Triple to match. default: Value to return if no matches are found. any: If true, return any matching value, otherwise raise UniquenessError. \"\"\" triple = self . triples (( subject , predicate , object )) try : value = next ( triple ) except StopIteration : return default if any : return value try : next ( triple ) except StopIteration : return value else : raise UniquenessError ( \"More than one match\" )","title":"value()"},{"location":"api_reference/triplestore/#tripper.triplestore.TriplestoreError","text":"Base exception for triplestore errors. Source code in tripper/triplestore.py class TriplestoreError ( Exception ): \"\"\"Base exception for triplestore errors.\"\"\"","title":"TriplestoreError"},{"location":"api_reference/triplestore/#tripper.triplestore.UniquenessError","text":"More than one matching triple. Source code in tripper/triplestore.py class UniquenessError ( TriplestoreError ): \"\"\"More than one matching triple.\"\"\"","title":"UniquenessError"},{"location":"api_reference/triplestore/#tripper.triplestore.en","text":"Convenience function that returns value as a plain english literal. Equivalent to Literal(value, lang=\"en\") . Source code in tripper/triplestore.py def en ( value ): # pylint: disable=invalid-name \"\"\"Convenience function that returns value as a plain english literal. Equivalent to``Literal(value, lang=\"en\")``. \"\"\" return Literal ( value , lang = \"en\" )","title":"en()"},{"location":"api_reference/triplestore/#tripper.triplestore.function_id","text":"Return a checksum for function func . The returned object is a string of hexadecimal digits. length is the number of bytes in the returned checksum. Since the current implementation is based on the shake_128 algorithm, it make no sense to set length larger than 32 bytes. Source code in tripper/triplestore.py def function_id ( func , length = 4 ): \"\"\"Return a checksum for function `func`. The returned object is a string of hexadecimal digits. `length` is the number of bytes in the returned checksum. Since the current implementation is based on the shake_128 algorithm, it make no sense to set `length` larger than 32 bytes. \"\"\" # return hex(crc32(inspect.getsource(func).encode())).lstrip('0x') return hashlib . shake_128 ( # pylint: disable=too-many-function-args inspect . getsource ( func ) . encode () ) . hexdigest ( length )","title":"function_id()"},{"location":"api_reference/triplestore/#tripper.triplestore.infer_iri","text":"Return IRI of the individual that stands for object obj . Source code in tripper/triplestore.py def infer_iri ( obj ): \"\"\"Return IRI of the individual that stands for object `obj`.\"\"\" if isinstance ( obj , str ): return obj if hasattr ( obj , \"uri\" ) and obj . uri : # dlite.Metadata or dataclass (or instance with uri) return obj . uri if hasattr ( obj , \"uuid\" ) and obj . uuid : # dlite.Instance or dataclass return obj . uuid if hasattr ( obj , \"schema\" ) and callable ( obj . schema ): # pydantic.BaseModel schema = obj . schema () properties = schema [ \"properties\" ] if \"uri\" in properties and properties [ \"uri\" ]: return properties [ \"uri\" ] if \"uuid\" in properties and properties [ \"uuid\" ]: return properties [ \"uuid\" ] raise TypeError ( \"cannot infer IRI from object {obj!r} \" )","title":"infer_iri()"},{"location":"api_reference/backends/ontopy/","text":"ontopy \u00b6 Backend for EMMOntoPy. For developers: The usage of s , p , and o represent the different parts of an RDF Triple: subject, predicate, and object. OntopyStrategy \u00b6 Triplestore strategy for EMMOntoPy. Parameters: Name Type Description Default base_iri Optional[str] The base iri of the ontology. Default to \"http://example.com/onto#\" if onto is not given. None onto Optional[Ontology] Ontology to initiate the triplestore from. Defaults to an new ontology with the given base_iri . None load bool Whether to load the ontology. False kwargs Keyword arguments passed to the ontology load() method. {} Either the base_iri or onto argument must be provided. Source code in tripper/backends/ontopy.py class OntopyStrategy : \"\"\"Triplestore strategy for EMMOntoPy. Arguments: base_iri: The base iri of the ontology. Default to \"http://example.com/onto#\" if `onto` is not given. onto: Ontology to initiate the triplestore from. Defaults to an new ontology with the given `base_iri`. load: Whether to load the ontology. kwargs: Keyword arguments passed to the ontology load() method. Either the `base_iri` or `onto` argument must be provided. \"\"\" def __init__ ( self , base_iri : \"Optional[str]\" = None , onto : \"Optional[Ontology]\" = None , load : bool = False , ** kwargs , ): if onto is None : if base_iri is None : base_iri = \"http://example.com/onto#\" self . onto = get_ontology ( base_iri ) elif isinstance ( onto , Ontology ): self . onto = onto else : raise TypeError ( \"`onto` must be either an ontology or None\" ) if load : self . onto . load ( ** kwargs ) def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples.\"\"\" def to_literal ( o , datatype ) -> Literal : \"\"\"Returns a literal from (o, datatype).\"\"\" if isinstance ( datatype , str ) and datatype . startswith ( \"@\" ): return Literal ( o , lang = datatype [ 1 :], datatype = None ) return Literal ( o , lang = None , datatype = datatype ) s , p , o = triple abb = ( None if ( s ) is None else self . onto . _abbreviate ( s ), None if ( p ) is None else self . onto . _abbreviate ( p ), None if ( o ) is None else self . onto . _abbreviate ( o ), ) for s , p , o in self . onto . _get_obj_triples_spo_spo ( * abb ): yield ( _unabbreviate ( self . onto , s ), _unabbreviate ( self . onto , p ), _unabbreviate ( self . onto , o ), ) for s , p , o , datatype in self . onto . _get_data_triples_spod_spod ( * abb , d = \"\" ): yield ( _unabbreviate ( self . onto , s ), _unabbreviate ( self . onto , p ), to_literal ( o , datatype ), ) def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" if TYPE_CHECKING : # pragma: no cover datatype : \"Union[int, str]\" for s , p , o in triples : if isinstance ( o , Literal ): if o . lang : datatype = f \"@ { o . lang } \" elif o . datatype : datatype = f \"^^ { o . datatype } \" else : datatype = 0 self . onto . _add_data_triple_spod ( self . onto . _abbreviate ( s ), self . onto . _abbreviate ( p ), self . onto . _abbreviate ( o ), datatype , ) else : self . onto . _add_obj_triple_spo ( self . onto . _abbreviate ( s ), self . onto . _abbreviate ( p ), self . onto . _abbreviate ( o ), ) def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" s , p , o = triple to_remove = list ( self . onto . _get_triples_spod_spod ( self . onto . _abbreviate ( s ) if ( s ) is not None else None , self . onto . _abbreviate ( p ) if ( s ) is not None else None , self . onto . _abbreviate ( o ) if ( s ) is not None else None , ) ) for s , p , o , datatype in to_remove : if datatype : self . onto . _del_data_triple_spod ( s , p , o , datatype ) else : self . onto . _del_obj_triple_spo ( s , p , o ) # Optional methods def parse ( self , source = None , location = None , data = None , format = None , # pylint: disable=redefined-builtin encoding = None , ** kwargs , ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Parameters: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. encoding: Encoding argument to io.open(). kwargs: Additional keyword arguments passed to Ontology.load(). \"\"\" if source : self . onto . load ( filename = source , format = format , ** kwargs ) elif location : self . onto . load ( filename = location , format = format , ** kwargs ) elif data : # s = io.StringIO(data) # self.onto.load(filename=s, format=format, **kwargs) # Could have been done much nicer if it hasn't been for Windows filename = None try : tmpfile_options = { \"delete\" : False } if isinstance ( data , str ): tmpfile_options . update ( mode = \"w+t\" , encoding = encoding ) with tempfile . NamedTemporaryFile ( ** tmpfile_options ) as handle : handle . write ( data ) filename = handle . name self . onto . load ( filename = filename , format = format , ** kwargs ) finally : if filename : os . remove ( filename ) else : raise ValueError ( \"either `source`, `location` or `data` must be given\" ) def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise to destination. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the Ontology.save() method. Returns: Serialised string if `destination` is None. \"\"\" if destination : self . onto . save ( destination , format = format , ** kwargs ) else : # Clumsy implementation due to Windows file locking... filename = None try : with tempfile . NamedTemporaryFile ( delete = False ) as handle : filename = handle . name self . onto . save ( filename , format = format , ** kwargs ) with open ( filename , \"rt\" , encoding = \"utf8\" ) as handle : return handle . read () finally : if filename : os . remove ( filename ) return None def query ( self , query_object , native = True , ** kwargs ): \"\"\"SPARQL query.\"\"\" if native : res = self . onto . world . sparql ( query_object ) else : graph = self . onto . world . as_rdflib_graph () res = graph . query ( query_object , ** kwargs ) # TODO: Convert result to expected type return res def update ( self , update_object , native = True , ** kwargs ): \"\"\"Update triplestore with SPARQL.\"\"\" if native : self . onto . world . sparql ( update_object ) else : graph = self . onto . world . as_rdflib_graph () graph . update ( update_object , ** kwargs ) add_triples ( self , triples ) \u00b6 Add a sequence of triples. Source code in tripper/backends/ontopy.py def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" if TYPE_CHECKING : # pragma: no cover datatype : \"Union[int, str]\" for s , p , o in triples : if isinstance ( o , Literal ): if o . lang : datatype = f \"@ { o . lang } \" elif o . datatype : datatype = f \"^^ { o . datatype } \" else : datatype = 0 self . onto . _add_data_triple_spod ( self . onto . _abbreviate ( s ), self . onto . _abbreviate ( p ), self . onto . _abbreviate ( o ), datatype , ) else : self . onto . _add_obj_triple_spo ( self . onto . _abbreviate ( s ), self . onto . _abbreviate ( p ), self . onto . _abbreviate ( o ), ) parse ( self , source = None , location = None , data = None , format = None , encoding = None , ** kwargs ) \u00b6 Parse source and add the resulting triples to triplestore. The source is specified using one of source , location or data . Parameters: Name Type Description Default source File-like object or file name. None location String with relative or absolute URL to source. None data String containing the data to be parsed. None format Needed if format can not be inferred from source. None encoding Encoding argument to io.open(). None kwargs Additional keyword arguments passed to Ontology.load(). {} Source code in tripper/backends/ontopy.py def parse ( self , source = None , location = None , data = None , format = None , # pylint: disable=redefined-builtin encoding = None , ** kwargs , ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Parameters: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. encoding: Encoding argument to io.open(). kwargs: Additional keyword arguments passed to Ontology.load(). \"\"\" if source : self . onto . load ( filename = source , format = format , ** kwargs ) elif location : self . onto . load ( filename = location , format = format , ** kwargs ) elif data : # s = io.StringIO(data) # self.onto.load(filename=s, format=format, **kwargs) # Could have been done much nicer if it hasn't been for Windows filename = None try : tmpfile_options = { \"delete\" : False } if isinstance ( data , str ): tmpfile_options . update ( mode = \"w+t\" , encoding = encoding ) with tempfile . NamedTemporaryFile ( ** tmpfile_options ) as handle : handle . write ( data ) filename = handle . name self . onto . load ( filename = filename , format = format , ** kwargs ) finally : if filename : os . remove ( filename ) else : raise ValueError ( \"either `source`, `location` or `data` must be given\" ) query ( self , query_object , native = True , ** kwargs ) \u00b6 SPARQL query. Source code in tripper/backends/ontopy.py def query ( self , query_object , native = True , ** kwargs ): \"\"\"SPARQL query.\"\"\" if native : res = self . onto . world . sparql ( query_object ) else : graph = self . onto . world . as_rdflib_graph () res = graph . query ( query_object , ** kwargs ) # TODO: Convert result to expected type return res remove ( self , triple ) \u00b6 Remove all matching triples from the backend. Source code in tripper/backends/ontopy.py def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" s , p , o = triple to_remove = list ( self . onto . _get_triples_spod_spod ( self . onto . _abbreviate ( s ) if ( s ) is not None else None , self . onto . _abbreviate ( p ) if ( s ) is not None else None , self . onto . _abbreviate ( o ) if ( s ) is not None else None , ) ) for s , p , o , datatype in to_remove : if datatype : self . onto . _del_data_triple_spod ( s , p , o , datatype ) else : self . onto . _del_obj_triple_spo ( s , p , o ) serialize ( self , destination = None , format = 'turtle' , ** kwargs ) \u00b6 Serialise to destination. Parameters: Name Type Description Default destination File name or object to write to. If None, the serialisation is returned. None format Format to serialise as. Supported formats, depends on the backend. 'turtle' kwargs Passed to the Ontology.save() method. {} Returns: Type Description Union[None, str] Serialised string if destination is None. Source code in tripper/backends/ontopy.py def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise to destination. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the Ontology.save() method. Returns: Serialised string if `destination` is None. \"\"\" if destination : self . onto . save ( destination , format = format , ** kwargs ) else : # Clumsy implementation due to Windows file locking... filename = None try : with tempfile . NamedTemporaryFile ( delete = False ) as handle : filename = handle . name self . onto . save ( filename , format = format , ** kwargs ) with open ( filename , \"rt\" , encoding = \"utf8\" ) as handle : return handle . read () finally : if filename : os . remove ( filename ) return None triples ( self , triple ) \u00b6 Returns a generator over matching triples. Source code in tripper/backends/ontopy.py def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples.\"\"\" def to_literal ( o , datatype ) -> Literal : \"\"\"Returns a literal from (o, datatype).\"\"\" if isinstance ( datatype , str ) and datatype . startswith ( \"@\" ): return Literal ( o , lang = datatype [ 1 :], datatype = None ) return Literal ( o , lang = None , datatype = datatype ) s , p , o = triple abb = ( None if ( s ) is None else self . onto . _abbreviate ( s ), None if ( p ) is None else self . onto . _abbreviate ( p ), None if ( o ) is None else self . onto . _abbreviate ( o ), ) for s , p , o in self . onto . _get_obj_triples_spo_spo ( * abb ): yield ( _unabbreviate ( self . onto , s ), _unabbreviate ( self . onto , p ), _unabbreviate ( self . onto , o ), ) for s , p , o , datatype in self . onto . _get_data_triples_spod_spod ( * abb , d = \"\" ): yield ( _unabbreviate ( self . onto , s ), _unabbreviate ( self . onto , p ), to_literal ( o , datatype ), ) update ( self , update_object , native = True , ** kwargs ) \u00b6 Update triplestore with SPARQL. Source code in tripper/backends/ontopy.py def update ( self , update_object , native = True , ** kwargs ): \"\"\"Update triplestore with SPARQL.\"\"\" if native : self . onto . world . sparql ( update_object ) else : graph = self . onto . world . as_rdflib_graph () graph . update ( update_object , ** kwargs )","title":"ontopy"},{"location":"api_reference/backends/ontopy/#ontopy","text":"Backend for EMMOntoPy. For developers: The usage of s , p , and o represent the different parts of an RDF Triple: subject, predicate, and object.","title":"ontopy"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy","text":"Triplestore strategy for EMMOntoPy. Parameters: Name Type Description Default base_iri Optional[str] The base iri of the ontology. Default to \"http://example.com/onto#\" if onto is not given. None onto Optional[Ontology] Ontology to initiate the triplestore from. Defaults to an new ontology with the given base_iri . None load bool Whether to load the ontology. False kwargs Keyword arguments passed to the ontology load() method. {} Either the base_iri or onto argument must be provided. Source code in tripper/backends/ontopy.py class OntopyStrategy : \"\"\"Triplestore strategy for EMMOntoPy. Arguments: base_iri: The base iri of the ontology. Default to \"http://example.com/onto#\" if `onto` is not given. onto: Ontology to initiate the triplestore from. Defaults to an new ontology with the given `base_iri`. load: Whether to load the ontology. kwargs: Keyword arguments passed to the ontology load() method. Either the `base_iri` or `onto` argument must be provided. \"\"\" def __init__ ( self , base_iri : \"Optional[str]\" = None , onto : \"Optional[Ontology]\" = None , load : bool = False , ** kwargs , ): if onto is None : if base_iri is None : base_iri = \"http://example.com/onto#\" self . onto = get_ontology ( base_iri ) elif isinstance ( onto , Ontology ): self . onto = onto else : raise TypeError ( \"`onto` must be either an ontology or None\" ) if load : self . onto . load ( ** kwargs ) def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples.\"\"\" def to_literal ( o , datatype ) -> Literal : \"\"\"Returns a literal from (o, datatype).\"\"\" if isinstance ( datatype , str ) and datatype . startswith ( \"@\" ): return Literal ( o , lang = datatype [ 1 :], datatype = None ) return Literal ( o , lang = None , datatype = datatype ) s , p , o = triple abb = ( None if ( s ) is None else self . onto . _abbreviate ( s ), None if ( p ) is None else self . onto . _abbreviate ( p ), None if ( o ) is None else self . onto . _abbreviate ( o ), ) for s , p , o in self . onto . _get_obj_triples_spo_spo ( * abb ): yield ( _unabbreviate ( self . onto , s ), _unabbreviate ( self . onto , p ), _unabbreviate ( self . onto , o ), ) for s , p , o , datatype in self . onto . _get_data_triples_spod_spod ( * abb , d = \"\" ): yield ( _unabbreviate ( self . onto , s ), _unabbreviate ( self . onto , p ), to_literal ( o , datatype ), ) def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" if TYPE_CHECKING : # pragma: no cover datatype : \"Union[int, str]\" for s , p , o in triples : if isinstance ( o , Literal ): if o . lang : datatype = f \"@ { o . lang } \" elif o . datatype : datatype = f \"^^ { o . datatype } \" else : datatype = 0 self . onto . _add_data_triple_spod ( self . onto . _abbreviate ( s ), self . onto . _abbreviate ( p ), self . onto . _abbreviate ( o ), datatype , ) else : self . onto . _add_obj_triple_spo ( self . onto . _abbreviate ( s ), self . onto . _abbreviate ( p ), self . onto . _abbreviate ( o ), ) def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" s , p , o = triple to_remove = list ( self . onto . _get_triples_spod_spod ( self . onto . _abbreviate ( s ) if ( s ) is not None else None , self . onto . _abbreviate ( p ) if ( s ) is not None else None , self . onto . _abbreviate ( o ) if ( s ) is not None else None , ) ) for s , p , o , datatype in to_remove : if datatype : self . onto . _del_data_triple_spod ( s , p , o , datatype ) else : self . onto . _del_obj_triple_spo ( s , p , o ) # Optional methods def parse ( self , source = None , location = None , data = None , format = None , # pylint: disable=redefined-builtin encoding = None , ** kwargs , ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Parameters: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. encoding: Encoding argument to io.open(). kwargs: Additional keyword arguments passed to Ontology.load(). \"\"\" if source : self . onto . load ( filename = source , format = format , ** kwargs ) elif location : self . onto . load ( filename = location , format = format , ** kwargs ) elif data : # s = io.StringIO(data) # self.onto.load(filename=s, format=format, **kwargs) # Could have been done much nicer if it hasn't been for Windows filename = None try : tmpfile_options = { \"delete\" : False } if isinstance ( data , str ): tmpfile_options . update ( mode = \"w+t\" , encoding = encoding ) with tempfile . NamedTemporaryFile ( ** tmpfile_options ) as handle : handle . write ( data ) filename = handle . name self . onto . load ( filename = filename , format = format , ** kwargs ) finally : if filename : os . remove ( filename ) else : raise ValueError ( \"either `source`, `location` or `data` must be given\" ) def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise to destination. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the Ontology.save() method. Returns: Serialised string if `destination` is None. \"\"\" if destination : self . onto . save ( destination , format = format , ** kwargs ) else : # Clumsy implementation due to Windows file locking... filename = None try : with tempfile . NamedTemporaryFile ( delete = False ) as handle : filename = handle . name self . onto . save ( filename , format = format , ** kwargs ) with open ( filename , \"rt\" , encoding = \"utf8\" ) as handle : return handle . read () finally : if filename : os . remove ( filename ) return None def query ( self , query_object , native = True , ** kwargs ): \"\"\"SPARQL query.\"\"\" if native : res = self . onto . world . sparql ( query_object ) else : graph = self . onto . world . as_rdflib_graph () res = graph . query ( query_object , ** kwargs ) # TODO: Convert result to expected type return res def update ( self , update_object , native = True , ** kwargs ): \"\"\"Update triplestore with SPARQL.\"\"\" if native : self . onto . world . sparql ( update_object ) else : graph = self . onto . world . as_rdflib_graph () graph . update ( update_object , ** kwargs )","title":"OntopyStrategy"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.add_triples","text":"Add a sequence of triples. Source code in tripper/backends/ontopy.py def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" if TYPE_CHECKING : # pragma: no cover datatype : \"Union[int, str]\" for s , p , o in triples : if isinstance ( o , Literal ): if o . lang : datatype = f \"@ { o . lang } \" elif o . datatype : datatype = f \"^^ { o . datatype } \" else : datatype = 0 self . onto . _add_data_triple_spod ( self . onto . _abbreviate ( s ), self . onto . _abbreviate ( p ), self . onto . _abbreviate ( o ), datatype , ) else : self . onto . _add_obj_triple_spo ( self . onto . _abbreviate ( s ), self . onto . _abbreviate ( p ), self . onto . _abbreviate ( o ), )","title":"add_triples()"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.parse","text":"Parse source and add the resulting triples to triplestore. The source is specified using one of source , location or data . Parameters: Name Type Description Default source File-like object or file name. None location String with relative or absolute URL to source. None data String containing the data to be parsed. None format Needed if format can not be inferred from source. None encoding Encoding argument to io.open(). None kwargs Additional keyword arguments passed to Ontology.load(). {} Source code in tripper/backends/ontopy.py def parse ( self , source = None , location = None , data = None , format = None , # pylint: disable=redefined-builtin encoding = None , ** kwargs , ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Parameters: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. encoding: Encoding argument to io.open(). kwargs: Additional keyword arguments passed to Ontology.load(). \"\"\" if source : self . onto . load ( filename = source , format = format , ** kwargs ) elif location : self . onto . load ( filename = location , format = format , ** kwargs ) elif data : # s = io.StringIO(data) # self.onto.load(filename=s, format=format, **kwargs) # Could have been done much nicer if it hasn't been for Windows filename = None try : tmpfile_options = { \"delete\" : False } if isinstance ( data , str ): tmpfile_options . update ( mode = \"w+t\" , encoding = encoding ) with tempfile . NamedTemporaryFile ( ** tmpfile_options ) as handle : handle . write ( data ) filename = handle . name self . onto . load ( filename = filename , format = format , ** kwargs ) finally : if filename : os . remove ( filename ) else : raise ValueError ( \"either `source`, `location` or `data` must be given\" )","title":"parse()"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.query","text":"SPARQL query. Source code in tripper/backends/ontopy.py def query ( self , query_object , native = True , ** kwargs ): \"\"\"SPARQL query.\"\"\" if native : res = self . onto . world . sparql ( query_object ) else : graph = self . onto . world . as_rdflib_graph () res = graph . query ( query_object , ** kwargs ) # TODO: Convert result to expected type return res","title":"query()"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.remove","text":"Remove all matching triples from the backend. Source code in tripper/backends/ontopy.py def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" s , p , o = triple to_remove = list ( self . onto . _get_triples_spod_spod ( self . onto . _abbreviate ( s ) if ( s ) is not None else None , self . onto . _abbreviate ( p ) if ( s ) is not None else None , self . onto . _abbreviate ( o ) if ( s ) is not None else None , ) ) for s , p , o , datatype in to_remove : if datatype : self . onto . _del_data_triple_spod ( s , p , o , datatype ) else : self . onto . _del_obj_triple_spo ( s , p , o )","title":"remove()"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.serialize","text":"Serialise to destination. Parameters: Name Type Description Default destination File name or object to write to. If None, the serialisation is returned. None format Format to serialise as. Supported formats, depends on the backend. 'turtle' kwargs Passed to the Ontology.save() method. {} Returns: Type Description Union[None, str] Serialised string if destination is None. Source code in tripper/backends/ontopy.py def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise to destination. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the Ontology.save() method. Returns: Serialised string if `destination` is None. \"\"\" if destination : self . onto . save ( destination , format = format , ** kwargs ) else : # Clumsy implementation due to Windows file locking... filename = None try : with tempfile . NamedTemporaryFile ( delete = False ) as handle : filename = handle . name self . onto . save ( filename , format = format , ** kwargs ) with open ( filename , \"rt\" , encoding = \"utf8\" ) as handle : return handle . read () finally : if filename : os . remove ( filename ) return None","title":"serialize()"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.triples","text":"Returns a generator over matching triples. Source code in tripper/backends/ontopy.py def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples.\"\"\" def to_literal ( o , datatype ) -> Literal : \"\"\"Returns a literal from (o, datatype).\"\"\" if isinstance ( datatype , str ) and datatype . startswith ( \"@\" ): return Literal ( o , lang = datatype [ 1 :], datatype = None ) return Literal ( o , lang = None , datatype = datatype ) s , p , o = triple abb = ( None if ( s ) is None else self . onto . _abbreviate ( s ), None if ( p ) is None else self . onto . _abbreviate ( p ), None if ( o ) is None else self . onto . _abbreviate ( o ), ) for s , p , o in self . onto . _get_obj_triples_spo_spo ( * abb ): yield ( _unabbreviate ( self . onto , s ), _unabbreviate ( self . onto , p ), _unabbreviate ( self . onto , o ), ) for s , p , o , datatype in self . onto . _get_data_triples_spod_spod ( * abb , d = \"\" ): yield ( _unabbreviate ( self . onto , s ), _unabbreviate ( self . onto , p ), to_literal ( o , datatype ), )","title":"triples()"},{"location":"api_reference/backends/ontopy/#tripper.backends.ontopy.OntopyStrategy.update","text":"Update triplestore with SPARQL. Source code in tripper/backends/ontopy.py def update ( self , update_object , native = True , ** kwargs ): \"\"\"Update triplestore with SPARQL.\"\"\" if native : self . onto . world . sparql ( update_object ) else : graph = self . onto . world . as_rdflib_graph () graph . update ( update_object , ** kwargs )","title":"update()"},{"location":"api_reference/backends/rdflib/","text":"rdflib \u00b6 Backend for RDFLib. For developers: The usage of s , p , and o represent the different parts of an RDF Triple: subject, predicate, and object. RdflibStrategy \u00b6 Triplestore strategy for rdflib. Source code in tripper/backends/rdflib.py class RdflibStrategy : \"\"\"Triplestore strategy for rdflib.\"\"\" def __init__ ( self , ** kwargs ) -> None : # pylint: disable=unused-argument self . graph = Graph () def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples.\"\"\" for ( s , p , o ,) in self . graph . triples ( # pylint: disable=not-an-iterable astriple ( triple ) ): yield ( str ( s ), str ( p ), Literal ( o . value , lang = o . language , datatype = o . datatype ) if isinstance ( o , rdflibLiteral ) else str ( o ), ) def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" for triple in triples : self . graph . add ( astriple ( triple )) def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" self . graph . remove ( astriple ( triple )) # Optional methods def parse ( self , source = None , location = None , data = None , format = None , # pylint: disable=redefined-builtin ** kwargs , ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Parameters: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. kwargs: Additional less used keyword arguments. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.parse \"\"\" self . graph . parse ( source = source , location = location , data = data , format = format , ** kwargs ) def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise to destination. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the rdflib.Graph.serialize() method. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.serialize Returns: Serialised string if `destination` is None. \"\"\" result = self . graph . serialize ( destination = destination , format = format , ** kwargs ) if destination is None : # Depending on the version of rdflib the return value of # graph.serialize() man either be a string or a bytes object... return result if isinstance ( result , str ) else result . decode () return None def query ( self , query_object , ** kwargs ): \"\"\"SPARQL query.\"\"\" # TODO: convert to returned object return self . graph . query ( query_object = query_object , ** kwargs ) def update ( self , update_object , ** kwargs ): \"\"\"Update triplestore with SPARQL.\"\"\" return self . graph . update ( update_object = update_object , ** kwargs ) def bind ( self , prefix : str , namespace : str ): \"\"\"Bind prefix to namespace. Should only be defined if the backend supports namespaces. Called by triplestore.bind(). \"\"\" if namespace : self . graph . bind ( prefix , namespace , replace = True ) else : warnings . warn ( \"rdflib does not support removing namespace prefixes\" ) def namespaces ( self ) -> dict : \"\"\"Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. \"\"\" return { prefix : str ( namespace ) for prefix , namespace in self . graph . namespaces ()} add_triples ( self , triples ) \u00b6 Add a sequence of triples. Source code in tripper/backends/rdflib.py def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" for triple in triples : self . graph . add ( astriple ( triple )) bind ( self , prefix , namespace ) \u00b6 Bind prefix to namespace. Should only be defined if the backend supports namespaces. Called by triplestore.bind(). Source code in tripper/backends/rdflib.py def bind ( self , prefix : str , namespace : str ): \"\"\"Bind prefix to namespace. Should only be defined if the backend supports namespaces. Called by triplestore.bind(). \"\"\" if namespace : self . graph . bind ( prefix , namespace , replace = True ) else : warnings . warn ( \"rdflib does not support removing namespace prefixes\" ) namespaces ( self ) \u00b6 Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. Source code in tripper/backends/rdflib.py def namespaces ( self ) -> dict : \"\"\"Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. \"\"\" return { prefix : str ( namespace ) for prefix , namespace in self . graph . namespaces ()} parse ( self , source = None , location = None , data = None , format = None , ** kwargs ) \u00b6 Parse source and add the resulting triples to triplestore. The source is specified using one of source , location or data . Parameters: Name Type Description Default source File-like object or file name. None location String with relative or absolute URL to source. None data String containing the data to be parsed. None format Needed if format can not be inferred from source. None kwargs Additional less used keyword arguments. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.parse {} Source code in tripper/backends/rdflib.py def parse ( self , source = None , location = None , data = None , format = None , # pylint: disable=redefined-builtin ** kwargs , ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Parameters: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. kwargs: Additional less used keyword arguments. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.parse \"\"\" self . graph . parse ( source = source , location = location , data = data , format = format , ** kwargs ) query ( self , query_object , ** kwargs ) \u00b6 SPARQL query. Source code in tripper/backends/rdflib.py def query ( self , query_object , ** kwargs ): \"\"\"SPARQL query.\"\"\" # TODO: convert to returned object return self . graph . query ( query_object = query_object , ** kwargs ) remove ( self , triple ) \u00b6 Remove all matching triples from the backend. Source code in tripper/backends/rdflib.py def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" self . graph . remove ( astriple ( triple )) serialize ( self , destination = None , format = 'turtle' , ** kwargs ) \u00b6 Serialise to destination. Parameters: Name Type Description Default destination File name or object to write to. If None, the serialisation is returned. None format Format to serialise as. Supported formats, depends on the backend. 'turtle' kwargs Passed to the rdflib.Graph.serialize() method. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.serialize {} Returns: Type Description Union[None, str] Serialised string if destination is None. Source code in tripper/backends/rdflib.py def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise to destination. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the rdflib.Graph.serialize() method. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.serialize Returns: Serialised string if `destination` is None. \"\"\" result = self . graph . serialize ( destination = destination , format = format , ** kwargs ) if destination is None : # Depending on the version of rdflib the return value of # graph.serialize() man either be a string or a bytes object... return result if isinstance ( result , str ) else result . decode () return None triples ( self , triple ) \u00b6 Returns a generator over matching triples. Source code in tripper/backends/rdflib.py def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples.\"\"\" for ( s , p , o ,) in self . graph . triples ( # pylint: disable=not-an-iterable astriple ( triple ) ): yield ( str ( s ), str ( p ), Literal ( o . value , lang = o . language , datatype = o . datatype ) if isinstance ( o , rdflibLiteral ) else str ( o ), ) update ( self , update_object , ** kwargs ) \u00b6 Update triplestore with SPARQL. Source code in tripper/backends/rdflib.py def update ( self , update_object , ** kwargs ): \"\"\"Update triplestore with SPARQL.\"\"\" return self . graph . update ( update_object = update_object , ** kwargs ) astriple ( triple ) \u00b6 Help function converting a triple to rdflib triple. Source code in tripper/backends/rdflib.py def astriple ( triple : \"Triple\" ): \"\"\"Help function converting a triple to rdflib triple.\"\"\" s , p , o = triple return asuri ( s ), asuri ( p ), asuri ( o ) asuri ( value ) \u00b6 Help function converting a spo-value to proper rdflib type. Source code in tripper/backends/rdflib.py def asuri ( value : \"Union[None, Literal, str]\" ): \"\"\"Help function converting a spo-value to proper rdflib type.\"\"\" if value is None : return None if isinstance ( value , Literal ): return rdflibLiteral ( value . value , lang = value . lang , datatype = value . datatype ) if value . startswith ( \"_:\" ): return BNode ( value ) return URIRef ( value )","title":"rdflib"},{"location":"api_reference/backends/rdflib/#rdflib","text":"Backend for RDFLib. For developers: The usage of s , p , and o represent the different parts of an RDF Triple: subject, predicate, and object.","title":"rdflib"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy","text":"Triplestore strategy for rdflib. Source code in tripper/backends/rdflib.py class RdflibStrategy : \"\"\"Triplestore strategy for rdflib.\"\"\" def __init__ ( self , ** kwargs ) -> None : # pylint: disable=unused-argument self . graph = Graph () def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples.\"\"\" for ( s , p , o ,) in self . graph . triples ( # pylint: disable=not-an-iterable astriple ( triple ) ): yield ( str ( s ), str ( p ), Literal ( o . value , lang = o . language , datatype = o . datatype ) if isinstance ( o , rdflibLiteral ) else str ( o ), ) def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" for triple in triples : self . graph . add ( astriple ( triple )) def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" self . graph . remove ( astriple ( triple )) # Optional methods def parse ( self , source = None , location = None , data = None , format = None , # pylint: disable=redefined-builtin ** kwargs , ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Parameters: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. kwargs: Additional less used keyword arguments. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.parse \"\"\" self . graph . parse ( source = source , location = location , data = data , format = format , ** kwargs ) def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise to destination. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the rdflib.Graph.serialize() method. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.serialize Returns: Serialised string if `destination` is None. \"\"\" result = self . graph . serialize ( destination = destination , format = format , ** kwargs ) if destination is None : # Depending on the version of rdflib the return value of # graph.serialize() man either be a string or a bytes object... return result if isinstance ( result , str ) else result . decode () return None def query ( self , query_object , ** kwargs ): \"\"\"SPARQL query.\"\"\" # TODO: convert to returned object return self . graph . query ( query_object = query_object , ** kwargs ) def update ( self , update_object , ** kwargs ): \"\"\"Update triplestore with SPARQL.\"\"\" return self . graph . update ( update_object = update_object , ** kwargs ) def bind ( self , prefix : str , namespace : str ): \"\"\"Bind prefix to namespace. Should only be defined if the backend supports namespaces. Called by triplestore.bind(). \"\"\" if namespace : self . graph . bind ( prefix , namespace , replace = True ) else : warnings . warn ( \"rdflib does not support removing namespace prefixes\" ) def namespaces ( self ) -> dict : \"\"\"Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. \"\"\" return { prefix : str ( namespace ) for prefix , namespace in self . graph . namespaces ()}","title":"RdflibStrategy"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.add_triples","text":"Add a sequence of triples. Source code in tripper/backends/rdflib.py def add_triples ( self , triples : \"Sequence[Triple]\" ): \"\"\"Add a sequence of triples.\"\"\" for triple in triples : self . graph . add ( astriple ( triple ))","title":"add_triples()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.bind","text":"Bind prefix to namespace. Should only be defined if the backend supports namespaces. Called by triplestore.bind(). Source code in tripper/backends/rdflib.py def bind ( self , prefix : str , namespace : str ): \"\"\"Bind prefix to namespace. Should only be defined if the backend supports namespaces. Called by triplestore.bind(). \"\"\" if namespace : self . graph . bind ( prefix , namespace , replace = True ) else : warnings . warn ( \"rdflib does not support removing namespace prefixes\" )","title":"bind()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.namespaces","text":"Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. Source code in tripper/backends/rdflib.py def namespaces ( self ) -> dict : \"\"\"Returns a dict mapping prefixes to namespaces. Should only be defined if the backend supports namespaces. Used by triplestore.parse() to get prefixes after reading triples from an external source. \"\"\" return { prefix : str ( namespace ) for prefix , namespace in self . graph . namespaces ()}","title":"namespaces()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.parse","text":"Parse source and add the resulting triples to triplestore. The source is specified using one of source , location or data . Parameters: Name Type Description Default source File-like object or file name. None location String with relative or absolute URL to source. None data String containing the data to be parsed. None format Needed if format can not be inferred from source. None kwargs Additional less used keyword arguments. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.parse {} Source code in tripper/backends/rdflib.py def parse ( self , source = None , location = None , data = None , format = None , # pylint: disable=redefined-builtin ** kwargs , ): \"\"\"Parse source and add the resulting triples to triplestore. The source is specified using one of `source`, `location` or `data`. Parameters: source: File-like object or file name. location: String with relative or absolute URL to source. data: String containing the data to be parsed. format: Needed if format can not be inferred from source. kwargs: Additional less used keyword arguments. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.parse \"\"\" self . graph . parse ( source = source , location = location , data = data , format = format , ** kwargs )","title":"parse()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.query","text":"SPARQL query. Source code in tripper/backends/rdflib.py def query ( self , query_object , ** kwargs ): \"\"\"SPARQL query.\"\"\" # TODO: convert to returned object return self . graph . query ( query_object = query_object , ** kwargs )","title":"query()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.remove","text":"Remove all matching triples from the backend. Source code in tripper/backends/rdflib.py def remove ( self , triple : \"Triple\" ): \"\"\"Remove all matching triples from the backend.\"\"\" self . graph . remove ( astriple ( triple ))","title":"remove()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.serialize","text":"Serialise to destination. Parameters: Name Type Description Default destination File name or object to write to. If None, the serialisation is returned. None format Format to serialise as. Supported formats, depends on the backend. 'turtle' kwargs Passed to the rdflib.Graph.serialize() method. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.serialize {} Returns: Type Description Union[None, str] Serialised string if destination is None. Source code in tripper/backends/rdflib.py def serialize ( self , destination = None , format = \"turtle\" , # pylint: disable=redefined-builtin ** kwargs , ) -> \"Union[None, str]\" : \"\"\"Serialise to destination. Parameters: destination: File name or object to write to. If None, the serialisation is returned. format: Format to serialise as. Supported formats, depends on the backend. kwargs: Passed to the rdflib.Graph.serialize() method. See https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.Graph.serialize Returns: Serialised string if `destination` is None. \"\"\" result = self . graph . serialize ( destination = destination , format = format , ** kwargs ) if destination is None : # Depending on the version of rdflib the return value of # graph.serialize() man either be a string or a bytes object... return result if isinstance ( result , str ) else result . decode () return None","title":"serialize()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.triples","text":"Returns a generator over matching triples. Source code in tripper/backends/rdflib.py def triples ( self , triple : \"Triple\" ) -> \"Generator\" : \"\"\"Returns a generator over matching triples.\"\"\" for ( s , p , o ,) in self . graph . triples ( # pylint: disable=not-an-iterable astriple ( triple ) ): yield ( str ( s ), str ( p ), Literal ( o . value , lang = o . language , datatype = o . datatype ) if isinstance ( o , rdflibLiteral ) else str ( o ), )","title":"triples()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.RdflibStrategy.update","text":"Update triplestore with SPARQL. Source code in tripper/backends/rdflib.py def update ( self , update_object , ** kwargs ): \"\"\"Update triplestore with SPARQL.\"\"\" return self . graph . update ( update_object = update_object , ** kwargs )","title":"update()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.astriple","text":"Help function converting a triple to rdflib triple. Source code in tripper/backends/rdflib.py def astriple ( triple : \"Triple\" ): \"\"\"Help function converting a triple to rdflib triple.\"\"\" s , p , o = triple return asuri ( s ), asuri ( p ), asuri ( o )","title":"astriple()"},{"location":"api_reference/backends/rdflib/#tripper.backends.rdflib.asuri","text":"Help function converting a spo-value to proper rdflib type. Source code in tripper/backends/rdflib.py def asuri ( value : \"Union[None, Literal, str]\" ): \"\"\"Help function converting a spo-value to proper rdflib type.\"\"\" if value is None : return None if isinstance ( value , Literal ): return rdflibLiteral ( value . value , lang = value . lang , datatype = value . datatype ) if value . startswith ( \"_:\" ): return BNode ( value ) return URIRef ( value )","title":"asuri()"}]}